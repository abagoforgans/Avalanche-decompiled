contract main {




// =====================  Runtime code  =====================


#
#  - sub_0de9fac6(?)
#  - sub_3419ba23(?)
#  - sub_348645d1(?)
#  - approveToken(address arg1, address arg2, uint256 arg3)
#  - sub_ed866cef(?)
#
address owner;
mapping of uint8 stor1;
address stor2;
mapping of address sub_af88dc47;
array of address sub_c42fa7f4;
mapping of uint8 stor5;
mapping of uint8 stor6;
mapping of address sub_e676ea95;

function owner() {
    return owner
}

function executors(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor1[arg1])
}

function sub_ae59ef9a(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor6[arg1])
}

function sub_af88dc47(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_af88dc47[arg1]
}

function sub_c42fa7f4(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < uint256(sub_c42fa7f4[arg1])
    return address(sub_c42fa7f4[arg1][arg2])
}

function sub_e676ea95(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_e676ea95[arg1]
}

function sub_eaafe247(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor5[arg1])
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function addExecutor(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit ExecutorUpdated(1, arg1);
    stor1[address(arg1)] = 1
}

function removeExecutor(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit ExecutorUpdated(0, arg1);
    stor1[address(arg1)] = 0
}

function sub_f2a38f65(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_e676ea95[address(arg1)] = address(arg2)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_00eb8ba4(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    idx = 0
    while idx < uint256(sub_c42fa7f4[address(arg1)]):
        require idx < uint256(sub_c42fa7f4[address(arg1)])
        if address(sub_c42fa7f4[address(arg1)][idx]) == address(arg2):
            return idx
        mem[0] = address(arg1)
        mem[32] = 4
        idx = idx + 1
        continue 
    revert with 0, 'Missing coin'
}

function currentBalance(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg1:
        return eth.balance(this.address)
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function stake(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    require ext_code.size(arg1)
    call arg1.0xb6b55f25 with:
         gas gas_remaining wei
        args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function unstake(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    require ext_code.size(arg1)
    call arg1.withdraw(uint256 arg1) with:
         gas gas_remaining wei
        args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_0e801ee1(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    require ext_code.size(stor2)
    call stor2.toggle_approve_mint(address arg1) with:
         gas gas_remaining wei
        args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_1c58db4f(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
    call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.0xd0e30db0 with:
       value arg1 wei
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function unwrapWETH(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
    call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function execute(address arg1, uint256 arg2, bytes arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require ceil32(arg3.length) + 128 >= 96 and ceil32(arg3.length) + 128 <= test266151307()
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(arg3.length) + 128 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
    if ceil32(arg3.length) > arg3.length:
        mem[arg3.length + ceil32(arg3.length) + 128] = 0
    call arg1 with:
       funct Mask(32, -(8 * ceil32(arg3.length) + -arg3.length + 4) + 256, 0) >> -(8 * ceil32(arg3.length) + -arg3.length + 4) + 256
       value arg2 wei
         gas gas_remaining wei
        args mem[ceil32(arg3.length) + 132 len arg3.length - 4]
}

function sub_c351666f(?) {
    require calldata.size - 4 >= 160
    require cd[4] == address(cd[4])
    require cd[36] == address(cd[36])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require (32 * ('cd', 68).length) + 128 >= 96 and (32 * ('cd', 68).length) + 128 <= test266151307()
    require calldata.size >= cd[68] + (32 * ('cd', 68).length) + 36
    idx = 0
    s = cd[68] + 36
    t = 128
    while idx < ('cd', 68).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] == bool(cd[100])
    require cd[132] == bool(cd[132])
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0, 'Executable: caller is not the executor'
    sub_af88dc47[address(cd[4])] = address(cd[36])
    uint256(sub_c42fa7f4[address(cd[4])]) = ('cd', 68).length
    if not ('cd', 68).length:
        idx = 0
        while uint256(sub_c42fa7f4[address(cd[4])]) > idx:
            address(sub_c42fa7f4[address(cd[4])][idx]) = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * ('cd', 68).length) + 128 > idx:
            address(sub_c42fa7f4[address(cd[4])][s]) = mem[idx + 12 len 20]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 68).length) + 31) >> 5
        while uint256(sub_c42fa7f4[address(cd[4])]) > idx:
            address(sub_c42fa7f4[address(cd[4])][idx]) = 0
            idx = idx + 1
            continue 
    stor5[address(cd[4])] = uint8(bool(cd[100]))
    stor6[address(cd[4])] = uint8(bool(cd[132]))
}

function withdraw(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not msg.sender:
        revert with 0, 'Invalid address'
    if not arg1:
        if eth.balance(this.address) < arg2:
            revert with 0, 'Insufficient funds'
        call msg.sender with:
           value arg2 wei
             gas gas_remaining wei
        if not ext_call.success:
            revert with 0, 'Native transfer failed.'
    else:
        mem[100] = this.address
        require ext_code.size(arg1)
        staticcall arg1.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < arg2:
            revert with 0, 'Insufficient funds'
        mem[ceil32(return_data.size) + 132] = msg.sender
        mem[ceil32(return_data.size) + 164] = arg2
        mem[ceil32(return_data.size) + 96] = 68
        mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
        mem[ceil32(return_data.size) + 196] = 32
        mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
        if not ext_code.size(arg1):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, arg2, 0
        mem[ceil32(return_data.size) + 328] = 0
        call arg1 with:
           funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, arg2, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, arg2, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                if not mem[ceil32(return_data.size) + 292]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    emit LogWithdraw(arg2, msg.sender, arg1);
}

function withdrawTo(address arg1, uint256 arg2, address arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg3 == arg3
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg3:
        revert with 0, 'Invalid address'
    if not arg1:
        if eth.balance(this.address) < arg2:
            revert with 0, 'Insufficient funds'
        call arg3 with:
           value arg2 wei
             gas gas_remaining wei
        if not ext_call.success:
            revert with 0, 'Native transfer failed.'
    else:
        mem[100] = this.address
        require ext_code.size(arg1)
        staticcall arg1.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < arg2:
            revert with 0, 'Insufficient funds'
        mem[ceil32(return_data.size) + 132] = arg3
        mem[ceil32(return_data.size) + 164] = arg2
        mem[ceil32(return_data.size) + 96] = 68
        mem[ceil32(return_data.size) + 132 len 28] = address(arg3) << 64
        mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
        mem[ceil32(return_data.size) + 196] = 32
        mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
        if not ext_code.size(arg1):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, arg2, 0
        mem[ceil32(return_data.size) + 328] = 0
        call arg1 with:
           funct Mask(32, 224, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, arg2, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, unknown_0xa9059cbb(?????), address(arg3) << 64, 0, arg2, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                if not mem[ceil32(return_data.size) + 292]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    emit LogWithdraw(arg2, arg3, arg1);
}

function sub_077d97d7(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 36).length) + 160 >= 128 and (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160 <= test266151307()
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 36).length
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    idx = 0
    s = cd[36] + 36
    t = (32 * ('cd', 4).length) + 160
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require calldata.size > cd[68] + 35
    require ('cd', 68).length <= test266151307()
    require (32 * ('cd', 68).length) + 192 >= 160 and (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 192 <= test266151307()
    mem[64] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 192
    mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160] = ('cd', 68).length
    idx = 0
    s = cd[68] + 36
    t = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
    while idx < ('cd', 68).length:
        require cd[68] + cd[s] + 67 < calldata.size
        require cd[(cd[68] + cd[s] + 36)] <= test266151307()
        _58 = mem[64]
        require mem[64] + ceil32(cd[(cd[68] + cd[s] + 36)]) + 32 >= mem[64] and mem[64] + ceil32(cd[(cd[68] + cd[s] + 36)]) + 32 <= test266151307()
        mem[64] = mem[64] + ceil32(cd[(cd[68] + cd[s] + 36)]) + 32
        mem[_58] = cd[(cd[68] + cd[s] + 36)]
        require cd[68] + cd[s] + cd[(cd[68] + cd[s] + 36)] + 68 <= calldata.size
        mem[_58 + 32 len cd[(cd[68] + cd[s] + 36)]] = call.data[cd[68] + cd[s] + 68 len cd[(cd[68] + cd[s] + 36)]]
        mem[_58 + cd[(cd[68] + cd[s] + 36)] + 32] = 0
        mem[t] = _58
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _75 = mem[96]
    idx = 0
    while idx < _75:
        require idx < mem[96]
        _77 = mem[(32 * idx) + 128]
        require idx < mem[(32 * ('cd', 4).length) + 128]
        _79 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
        require idx < mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        _81 = mem[(32 * idx) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192]
        _82 = mem[64]
        _83 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192]]
        s = 0
        while s < _83:
            mem[s + _82] = mem[s + _81 + 32]
            _75 = mem[96]
            s = s + 32
            continue 
        if ceil32(_83) <= _83:
            call address(_77).mem[mem[64] len 4] with:
               value _79 wei
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _83 + _82 + -mem[64] - 4]
            if return_data.size:
                _92 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_92] = return_data.size
                mem[_92 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        else:
            mem[_83 + _82] = 0
            call address(_77).mem[mem[64] len 4] with:
               value _79 wei
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _83 + _82 + -mem[64] - 4]
            if return_data.size:
                _93 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_93] = return_data.size
                mem[_93 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        _75 = mem[96]
        idx = idx + 1
        continue 
}

function sub_14a08b36(?) {
    require calldata.size - 4 >= 64
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 36).length) + 128 >= 96 and (32 * ('cd', 36).length) + 128 <= test266151307()
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0, 'Executable: caller is not the executor'
    if sub_e676ea95[address(cd[4])]:
        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
            if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
                mem[(32 * ('cd', 36).length) + 128 len 64] = call.data[calldata.size len 64]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 160] = mem[160]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0
                    else:
                        call address(cd[4]).0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0
                    else:
                        call sub_e676ea95[address(cd[4])].0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0, 1
            else:
                if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                    revert with 0, 'Missing implementation'
                mem[(32 * ('cd', 36).length) + 128 len 96] = call.data[calldata.size len 96]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 160] = mem[160]
                require 2 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 192] = mem[192]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0
                    else:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0
                    else:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            emit 0x8a07cc96: Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length]), address(cd[4])
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            require ext_code.size(sub_af88dc47[address(cd[4])])
            staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if eth.balance(this.address) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            return (ext_call.return_data[0] - eth.balance(this.address))
        mem[(32 * ('cd', 36).length) + 132] = this.address
        require ext_code.size(sub_af88dc47[address(cd[4])])
        staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[(32 * ('cd', 36).length) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 160] = mem[160]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0
                else:
                    call address(cd[4]).0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0
                else:
                    call sub_e676ea95[address(cd[4])].0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0, 1
        else:
            if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                revert with 0, 'Missing implementation'
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 160] = mem[160]
            require 2 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 192] = mem[192]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0
                else:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0
                else:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0, 1
    else:
        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                gas gas_remaining wei
        mem[(32 * ('cd', 36).length) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 132] = address(cd[4])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                gas gas_remaining wei
               args address(cd[4])
        mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
            if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0
                    else:
                        call address(cd[4]).0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0
                    else:
                        call sub_e676ea95[address(cd[4])].0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0, 1
            else:
                if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                    revert with 0, 'Missing implementation'
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                require 2 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0
                    else:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0
                    else:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            emit 0x8a07cc96: Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length]), address(cd[4])
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            require ext_code.size(sub_af88dc47[address(cd[4])])
            staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if eth.balance(this.address) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            return (ext_call.return_data[0] - eth.balance(this.address))
        mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 132] = this.address
        require ext_code.size(sub_af88dc47[address(cd[4])])
        staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 160] = mem[160]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0
                else:
                    call address(cd[4]).0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0
                else:
                    call sub_e676ea95[address(cd[4])].0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0, 1
        else:
            if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                revert with 0, 'Missing implementation'
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 160] = mem[160]
            require 2 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 192] = mem[192]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0
                else:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0
                else:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0, 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit 0x8a07cc96: Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length]), address(cd[4])
    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
        if ext_call.return_data[0] > eth.balance(this.address):
            revert with 0, 'SafeMath: subtraction overflow'
        return (eth.balance(this.address) - ext_call.return_data[0])
    require ext_code.size(sub_af88dc47[address(cd[4])])
    staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > ext_call.return_data[0]:
        revert with 0, 'SafeMath: subtraction overflow'
    return 0
}

function removeLiquidity(address arg1, address arg2, uint256 arg3) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    mem[0] = arg1
    mem[32] = 4
    if not sub_e676ea95[address(arg1)]:
        idx = 0
        while idx < uint256(sub_c42fa7f4[address(arg1)]):
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                mem[0] = arg1
                mem[32] = 4
                idx = idx + 1
                continue 
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
                mem[100] = arg3
                if not stor5[address(arg1)]:
                    mem[132] = ('signextend', 15, ('var', 0))
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(arg1)
                        call arg1.remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, ('signextend', 15, ('var', 0)), 0
                    else:
                        mem[196] = 1
                        require ext_code.size(arg1)
                        call arg1.remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), ('signextend', 15, ('var', 0)), 0, 1
                else:
                    mem[132] = idx
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(arg1)
                        call arg1.remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, idx, 0
                    else:
                        mem[196] = 1
                        require ext_code.size(arg1)
                        call arg1.remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), idx, 0, 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
                    if eth.balance(this.address) > eth.balance(this.address):
                        revert with 0, 'SafeMath: subtraction overflow'
                    require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                    if uint256(sub_c42fa7f4[address(arg1)]):
                        mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = 0
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                    idx = 0
                    s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                    t = 128
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[s] = mem[t]
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    emit 0xd2602de0: mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
                    return 0
                mem[100] = this.address
                require ext_code.size(arg2)
                staticcall arg2.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if eth.balance(this.address) > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = ext_call.return_data[0] - eth.balance(this.address)
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = arg1
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
                return (ext_call.return_data[0] - eth.balance(this.address))
            require ext_code.size(arg2)
            staticcall arg2.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = arg3
            if not stor5[address(arg1)]:
                mem[ceil32(return_data.size) + 132] = ('signextend', 15, ('var', 0))
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(arg1)
                    call arg1.remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(arg1)
                    call arg1.remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0, 1
            else:
                mem[ceil32(return_data.size) + 132] = idx
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(arg1)
                    call arg1.remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, idx, 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(arg1)
                    call arg1.remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, idx, 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
                if ext_call.return_data[0] > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = eth.balance(this.address) - ext_call.return_data[0]
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = arg1
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
                return (eth.balance(this.address) - ext_call.return_data[0])
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(arg2)
            staticcall arg2.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
            if uint256(sub_c42fa7f4[address(arg1)]):
                mem[(2 * ceil32(return_data.size)) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
            idx = 0
            s = (2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
            t = (2 * ceil32(return_data.size)) + 128
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[s] = mem[t]
                mem[0] = arg1
                mem[32] = 4
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            emit 0xd2602de0: mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
            return 0
    else:
        idx = 0
        while idx < uint256(sub_c42fa7f4[address(arg1)]):
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                mem[0] = arg1
                mem[32] = 4
                idx = idx + 1
                continue 
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
                mem[100] = arg3
                if not stor5[address(arg1)]:
                    mem[132] = ('signextend', 15, ('var', 0))
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, ('signextend', 15, ('var', 0)), 0
                    else:
                        mem[196] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), ('signextend', 15, ('var', 0)), 0, 1
                else:
                    mem[132] = idx
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, idx, 0
                    else:
                        mem[196] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), idx, 0, 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
                    if eth.balance(this.address) > eth.balance(this.address):
                        revert with 0, 'SafeMath: subtraction overflow'
                    require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                    if uint256(sub_c42fa7f4[address(arg1)]):
                        mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = 0
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                    idx = 0
                    s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                    t = 128
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[s] = mem[t]
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    emit 0xd2602de0: mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
                    return 0
                mem[100] = this.address
                require ext_code.size(arg2)
                staticcall arg2.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if eth.balance(this.address) > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = ext_call.return_data[0] - eth.balance(this.address)
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = arg1
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
                return (ext_call.return_data[0] - eth.balance(this.address))
            require ext_code.size(arg2)
            staticcall arg2.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = arg3
            if not stor5[address(arg1)]:
                mem[ceil32(return_data.size) + 132] = ('signextend', 15, ('var', 0))
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0, 1
            else:
                mem[ceil32(return_data.size) + 132] = idx
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, idx, 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, idx, 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
                if ext_call.return_data[0] > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = eth.balance(this.address) - ext_call.return_data[0]
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = arg1
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
                return (eth.balance(this.address) - ext_call.return_data[0])
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(arg2)
            staticcall arg2.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
            if uint256(sub_c42fa7f4[address(arg1)]):
                mem[(2 * ceil32(return_data.size)) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
            idx = 0
            s = (2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
            t = (2 * ceil32(return_data.size)) + 128
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[s] = mem[t]
                mem[0] = arg1
                mem[32] = 4
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            emit 0xd2602de0: mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], arg1
            return 0
    revert with 0, 'Missing coin'
}

function sub_67974ca4(?) {
    require calldata.size - 4 >= 96
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 36).length) + 128 >= 96 and (32 * ('cd', 36).length) + 128 <= test266151307()
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] == address(cd[68])
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0, 'Executable: caller is not the executor'
        if owner != msg.sender:
            if not stor1[msg.sender]:
                revert with 0, 'Executable: caller is not the executor'
    if sub_e676ea95[address(cd[4])]:
        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
            if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
                mem[(32 * ('cd', 36).length) + 128 len 64] = call.data[calldata.size len 64]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 160] = mem[160]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0
                    else:
                        call address(cd[4]).0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0
                    else:
                        call sub_e676ea95[address(cd[4])].0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 64], 0, 1
            else:
                if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                    revert with 0, 'Missing implementation'
                mem[(32 * ('cd', 36).length) + 128 len 96] = call.data[calldata.size len 96]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 160] = mem[160]
                require 2 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + 192] = mem[192]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0
                    else:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0
                    else:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + 128 len 96], 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            emit 0x8a07cc96: Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length]), address(cd[4])
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                if owner != msg.sender:
                    if not stor1[msg.sender]:
                        revert with 0, 'Executable: caller is not the executor'
                require ext_code.size(address(cd[68]))
                call address(cd[68]).0xb6b55f25 with:
                     gas gas_remaining wei
                    args 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                else:
                    return 0
            require ext_code.size(sub_af88dc47[address(cd[4])])
            staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if eth.balance(this.address) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if owner != msg.sender:
                if not stor1[msg.sender]:
                    revert with 0, 'Executable: caller is not the executor'
            require ext_code.size(address(cd[68]))
            call address(cd[68]).0xb6b55f25 with:
                 gas gas_remaining wei
                args (ext_call.return_data[0] - eth.balance(this.address))
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return (ext_call.return_data[0] - eth.balance(this.address))
        mem[(32 * ('cd', 36).length) + 132] = this.address
        require ext_code.size(sub_af88dc47[address(cd[4])])
        staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[(32 * ('cd', 36).length) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 160] = mem[160]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0
                else:
                    call address(cd[4]).0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0
                else:
                    call sub_e676ea95[address(cd[4])].0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 64], 0, 1
        else:
            if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                revert with 0, 'Missing implementation'
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 160] = mem[160]
            require 2 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 192] = mem[192]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0
                else:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0
                else:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128 len 96], 0, 1
    else:
        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                gas gas_remaining wei
        mem[(32 * ('cd', 36).length) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 132] = address(cd[4])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                gas gas_remaining wei
               args address(cd[4])
        mem[(32 * ('cd', 36).length) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
            if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0
                    else:
                        call address(cd[4]).0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].'L~M' with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0
                    else:
                        call sub_e676ea95[address(cd[4])].0xee22be23 with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 64], 0, 1
            else:
                if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                    revert with 0, 'Missing implementation'
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                require 0 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                require 1 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                require 2 < ('cd', 36).length
                mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                if not sub_e676ea95[address(cd[4])]:
                    require ext_code.size(address(cd[4]))
                    if not stor6[address(cd[4])]:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0
                    else:
                        call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0, 1
                else:
                    require ext_code.size(sub_e676ea95[address(cd[4])])
                    if not stor6[address(cd[4])]:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0
                    else:
                        call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                             gas gas_remaining wei
                            args mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128 len 96], 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            emit 0x8a07cc96: Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length]), address(cd[4])
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                if owner != msg.sender:
                    if not stor1[msg.sender]:
                        revert with 0, 'Executable: caller is not the executor'
                require ext_code.size(address(cd[68]))
                call address(cd[68]).0xb6b55f25 with:
                     gas gas_remaining wei
                    args 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                else:
                    return 0
            require ext_code.size(sub_af88dc47[address(cd[4])])
            staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if eth.balance(this.address) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if owner != msg.sender:
                if not stor1[msg.sender]:
                    revert with 0, 'Executable: caller is not the executor'
            require ext_code.size(address(cd[68]))
            call address(cd[68]).0xb6b55f25 with:
                 gas gas_remaining wei
                args (ext_call.return_data[0] - eth.balance(this.address))
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return (ext_call.return_data[0] - eth.balance(this.address))
        mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 132] = this.address
        require ext_code.size(sub_af88dc47[address(cd[4])])
        staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(sub_c42fa7f4[address(cd[4])]) == 2:
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 160] = mem[160]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0
                else:
                    call address(cd[4]).0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].'L~M' with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0
                else:
                    call sub_e676ea95[address(cd[4])].0xee22be23 with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 64], 0, 1
        else:
            if uint256(sub_c42fa7f4[address(cd[4])]) != 3:
                revert with 0, 'Missing implementation'
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
            require 0 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128] = mem[128]
            require 1 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 160] = mem[160]
            require 2 < ('cd', 36).length
            mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 192] = mem[192]
            if not sub_e676ea95[address(cd[4])]:
                require ext_code.size(address(cd[4]))
                if not stor6[address(cd[4])]:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0
                else:
                    call address(cd[4]).add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0, 1
            else:
                require ext_code.size(sub_e676ea95[address(cd[4])])
                if not stor6[address(cd[4])]:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0
                else:
                    call sub_e676ea95[address(cd[4])].add_liquidity(uint256[3] arg1, uint256 arg2, bool arg3) with:
                         gas gas_remaining wei
                        args mem[(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 128 len 96], 0, 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit 0x8a07cc96: Array(len=('cd', 36).length, data=mem[128 len 32 * ('cd', 36).length]), address(cd[4])
    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(cd[4])]:
        if ext_call.return_data[0] > eth.balance(this.address):
            revert with 0, 'SafeMath: subtraction overflow'
        if owner != msg.sender:
            if not stor1[msg.sender]:
                revert with 0, 'Executable: caller is not the executor'
        require ext_code.size(address(cd[68]))
        call address(cd[68]).0xb6b55f25 with:
             gas gas_remaining wei
            args (eth.balance(this.address) - ext_call.return_data[0])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        return (eth.balance(this.address) - ext_call.return_data[0])
    require ext_code.size(sub_af88dc47[address(cd[4])])
    staticcall sub_af88dc47[address(cd[4])].0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > ext_call.return_data[0]:
        revert with 0, 'SafeMath: subtraction overflow'
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0, 'Executable: caller is not the executor'
    require ext_code.size(address(cd[68]))
    call address(cd[68]).0xb6b55f25 with:
         gas gas_remaining wei
        args 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    return 0
}

function sub_12a9aa49(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg4 == address(arg4)
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
        if owner != msg.sender:
            if not stor1[msg.sender]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    mem[96] = 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000
    mem[100] = arg3
    require ext_code.size(address(arg4))
    call address(arg4).withdraw(uint256 arg1) with:
         gas gas_remaining wei
        args arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if owner != msg.sender:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
    mem[0] = address(arg1)
    mem[32] = 4
    if not sub_e676ea95[address(arg1)]:
        idx = 0
        while idx < uint256(sub_c42fa7f4[address(arg1)]):
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            if address(sub_c42fa7f4[address(arg1)][idx]) != address(arg2):
                mem[0] = address(arg1)
                mem[32] = 4
                idx = idx + 1
                continue 
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(arg2):
                mem[100] = arg3
                if not stor5[address(arg1)]:
                    mem[132] = ('signextend', 15, ('var', 0))
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, ('signextend', 15, ('var', 0)), 0
                    else:
                        mem[196] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), ('signextend', 15, ('var', 0)), 0, 1
                else:
                    mem[132] = idx
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, idx, 0
                    else:
                        mem[196] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), idx, 0, 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(arg2):
                    if eth.balance(this.address) > eth.balance(this.address):
                        revert with 0, 'SafeMath: subtraction overflow'
                    require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                    if uint256(sub_c42fa7f4[address(arg1)]):
                        mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = 0
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                    idx = 0
                    s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                    t = 128
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[s] = mem[t]
                        mem[0] = address(arg1)
                        mem[32] = 4
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    emit 0xd2602de0: mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
                    return 0
                mem[100] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if eth.balance(this.address) > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = ext_call.return_data[0] - eth.balance(this.address)
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = address(arg1)
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
                return (ext_call.return_data[0] - eth.balance(this.address))
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = arg3
            if not stor5[address(arg1)]:
                mem[ceil32(return_data.size) + 132] = ('signextend', 15, ('var', 0))
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(address(arg1))
                    call address(arg1).remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(address(arg1))
                    call address(arg1).remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0, 1
            else:
                mem[ceil32(return_data.size) + 132] = idx
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(address(arg1))
                    call address(arg1).remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, idx, 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(address(arg1))
                    call address(arg1).remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, idx, 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(arg2):
                if ext_call.return_data[0] > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = eth.balance(this.address) - ext_call.return_data[0]
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = address(arg1)
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
                return (eth.balance(this.address) - ext_call.return_data[0])
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
            if uint256(sub_c42fa7f4[address(arg1)]):
                mem[(2 * ceil32(return_data.size)) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
            idx = 0
            s = (2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
            t = (2 * ceil32(return_data.size)) + 128
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[s] = mem[t]
                mem[0] = address(arg1)
                mem[32] = 4
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            emit 0xd2602de0: mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
            return 0
    else:
        idx = 0
        while idx < uint256(sub_c42fa7f4[address(arg1)]):
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            if address(sub_c42fa7f4[address(arg1)][idx]) != address(arg2):
                mem[0] = address(arg1)
                mem[32] = 4
                idx = idx + 1
                continue 
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(arg2):
                mem[100] = arg3
                if not stor5[address(arg1)]:
                    mem[132] = ('signextend', 15, ('var', 0))
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, ('signextend', 15, ('var', 0)), 0
                    else:
                        mem[196] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), ('signextend', 15, ('var', 0)), 0, 1
                else:
                    mem[132] = idx
                    mem[164] = 0
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args arg3, idx, 0
                    else:
                        mem[196] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                             gas gas_remaining wei
                            args 0, uint32(arg3), idx, 0, 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(arg2):
                    if eth.balance(this.address) > eth.balance(this.address):
                        revert with 0, 'SafeMath: subtraction overflow'
                    require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                    if uint256(sub_c42fa7f4[address(arg1)]):
                        mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = 0
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                    mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                    idx = 0
                    s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                    t = 128
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[s] = mem[t]
                        mem[0] = address(arg1)
                        mem[32] = 4
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    emit 0xd2602de0: mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
                    return 0
                mem[100] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if eth.balance(this.address) > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = ext_call.return_data[0] - eth.balance(this.address)
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = address(arg1)
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
                return (ext_call.return_data[0] - eth.balance(this.address))
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = arg3
            if not stor5[address(arg1)]:
                mem[ceil32(return_data.size) + 132] = ('signextend', 15, ('var', 0))
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, int128 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, ('signextend', 15, ('var', 0)), 0, 1
            else:
                mem[ceil32(return_data.size) + 132] = idx
                mem[ceil32(return_data.size) + 164] = 0
                if not stor6[address(arg1)]:
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args arg3, idx, 0
                else:
                    mem[ceil32(return_data.size) + 196] = 1
                    require ext_code.size(sub_e676ea95[address(arg1)])
                    call sub_e676ea95[address(arg1)].remove_liquidity_one_coin(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4) with:
                         gas gas_remaining wei
                        args arg3, idx, 0, 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(arg2):
                if ext_call.return_data[0] > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow'
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                if uint256(sub_c42fa7f4[address(arg1)]):
                    mem[ceil32(return_data.size) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[(32 * idx) + ceil32(return_data.size) + 128] = eth.balance(this.address) - ext_call.return_data[0]
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
                mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
                idx = 0
                s = ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                t = ceil32(return_data.size) + 128
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[s] = mem[t]
                    mem[0] = address(arg1)
                    mem[32] = 4
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xd2602de0: mem[ceil32(return_data.size) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
                return (eth.balance(this.address) - ext_call.return_data[0])
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
            if uint256(sub_c42fa7f4[address(arg1)]):
                mem[(2 * ceil32(return_data.size)) + 128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
            require idx < uint256(sub_c42fa7f4[address(arg1)])
            mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = 32
            mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = uint256(sub_c42fa7f4[address(arg1)])
            idx = 0
            s = (2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
            t = (2 * ceil32(return_data.size)) + 128
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[s] = mem[t]
                mem[0] = address(arg1)
                mem[32] = 4
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            emit 0xd2602de0: mem[(2 * ceil32(return_data.size)) + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len (96 * uint256(sub_c42fa7f4[address(arg1)])) + 64], address(arg1)
            return 0
    revert with 0, 'Missing coin'
}

function sub_171c3318(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if owner == msg.sender:
        mem[0] = address(arg1)
        mem[32] = 4
        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
        mem[96] = uint256(sub_c42fa7f4[address(arg1)])
        mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
        if not uint256(sub_c42fa7f4[address(arg1)]):
            idx = 0
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[32] = 4
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[0] = sha3(address(arg1), 4)
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = eth.balance(this.address)
                else:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _234 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[_234]
                idx = idx + 1
                continue 
            if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _196 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_196 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _378 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1713 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_378]
                                    mem[(32 * idx) + _378 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2216 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1713 > mem[_2216]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_378]
                                    mem[(32 * idx) + _378 + 32] = mem[_2216] - _1713
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1712 = mem[_378]
                            mem[mem[64] + 32] = mem[_378]
                            mem[mem[64] + 64 len 32 * _1712] = mem[_378 + 32 len 32 * _1712]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1712) + 32], address(arg1)
                        else:
                            mem[_378 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1716 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_378]
                                    mem[(32 * idx) + _378 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2218 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1716 > mem[_2218]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_378]
                                    mem[(32 * idx) + _378 + 32] = mem[_2218] - _1716
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1715 = mem[_378]
                            mem[mem[64] + 32] = mem[_378]
                            mem[mem[64] + 64 len 32 * _1715] = mem[_378 + 32 len 32 * _1715]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1715) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _394 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1719 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_394]
                                    mem[(32 * idx) + _394 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2220 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1719 > mem[_2220]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_394]
                                    mem[(32 * idx) + _394 + 32] = mem[_2220] - _1719
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1718 = mem[_394]
                            mem[mem[64] + 32] = mem[_394]
                            mem[mem[64] + 64 len 32 * _1718] = mem[_394 + 32 len 32 * _1718]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1718) + 32], address(arg1)
                        else:
                            mem[_394 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1722 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_394]
                                    mem[(32 * idx) + _394 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2222 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1722 > mem[_2222]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_394]
                                    mem[(32 * idx) + _394 + 32] = mem[_2222] - _1722
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1721 = mem[_394]
                            mem[mem[64] + 32] = mem[_394]
                            mem[mem[64] + 64 len 32 * _1721] = mem[_394 + 32 len 32 * _1721]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1721) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _197 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_197 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _379 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1725 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_379]
                                    mem[(32 * idx) + _379 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2224 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1725 > mem[_2224]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_379]
                                    mem[(32 * idx) + _379 + 32] = mem[_2224] - _1725
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1724 = mem[_379]
                            mem[mem[64] + 32] = mem[_379]
                            mem[mem[64] + 64 len 32 * _1724] = mem[_379 + 32 len 32 * _1724]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1724) + 32], address(arg1)
                        else:
                            mem[_379 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1728 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_379]
                                    mem[(32 * idx) + _379 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2226 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1728 > mem[_2226]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_379]
                                    mem[(32 * idx) + _379 + 32] = mem[_2226] - _1728
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1727 = mem[_379]
                            mem[mem[64] + 32] = mem[_379]
                            mem[mem[64] + 64 len 32 * _1727] = mem[_379 + 32 len 32 * _1727]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1727) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _395 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1731 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_395]
                                    mem[(32 * idx) + _395 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2228 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1731 > mem[_2228]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_395]
                                    mem[(32 * idx) + _395 + 32] = mem[_2228] - _1731
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1730 = mem[_395]
                            mem[mem[64] + 32] = mem[_395]
                            mem[mem[64] + 64 len 32 * _1730] = mem[_395 + 32 len 32 * _1730]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1730) + 32], address(arg1)
                        else:
                            mem[_395 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1734 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_395]
                                    mem[(32 * idx) + _395 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2230 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1734 > mem[_2230]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_395]
                                    mem[(32 * idx) + _395 + 32] = mem[_2230] - _1734
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1733 = mem[_395]
                            mem[mem[64] + 32] = mem[_395]
                            mem[mem[64] + 64 len 32 * _1733] = mem[_395 + 32 len 32 * _1733]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1733) + 32], address(arg1)
            else:
                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                    revert with 0, 'Missing implementation'
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _212 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_212 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _376 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1689 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_376]
                                    mem[(32 * idx) + _376 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2200 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1689 > mem[_2200]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_376]
                                    mem[(32 * idx) + _376 + 32] = mem[_2200] - _1689
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1688 = mem[_376]
                            mem[mem[64] + 32] = mem[_376]
                            mem[mem[64] + 64 len 32 * _1688] = mem[_376 + 32 len 32 * _1688]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1688) + 32], address(arg1)
                        else:
                            mem[_376 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1692 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_376]
                                    mem[(32 * idx) + _376 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2202 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1692 > mem[_2202]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_376]
                                    mem[(32 * idx) + _376 + 32] = mem[_2202] - _1692
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1691 = mem[_376]
                            mem[mem[64] + 32] = mem[_376]
                            mem[mem[64] + 64 len 32 * _1691] = mem[_376 + 32 len 32 * _1691]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1691) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _392 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1695 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_392]
                                    mem[(32 * idx) + _392 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2204 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1695 > mem[_2204]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_392]
                                    mem[(32 * idx) + _392 + 32] = mem[_2204] - _1695
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1694 = mem[_392]
                            mem[mem[64] + 32] = mem[_392]
                            mem[mem[64] + 64 len 32 * _1694] = mem[_392 + 32 len 32 * _1694]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1694) + 32], address(arg1)
                        else:
                            mem[_392 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1698 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_392]
                                    mem[(32 * idx) + _392 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2206 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1698 > mem[_2206]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_392]
                                    mem[(32 * idx) + _392 + 32] = mem[_2206] - _1698
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1697 = mem[_392]
                            mem[mem[64] + 32] = mem[_392]
                            mem[mem[64] + 64 len 32 * _1697] = mem[_392 + 32 len 32 * _1697]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1697) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _213 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_213 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _377 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1701 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_377]
                                    mem[(32 * idx) + _377 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2208 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1701 > mem[_2208]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_377]
                                    mem[(32 * idx) + _377 + 32] = mem[_2208] - _1701
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1700 = mem[_377]
                            mem[mem[64] + 32] = mem[_377]
                            mem[mem[64] + 64 len 32 * _1700] = mem[_377 + 32 len 32 * _1700]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1700) + 32], address(arg1)
                        else:
                            mem[_377 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1704 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_377]
                                    mem[(32 * idx) + _377 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2210 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1704 > mem[_2210]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_377]
                                    mem[(32 * idx) + _377 + 32] = mem[_2210] - _1704
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1703 = mem[_377]
                            mem[mem[64] + 32] = mem[_377]
                            mem[mem[64] + 64 len 32 * _1703] = mem[_377 + 32 len 32 * _1703]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1703) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _393 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1707 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_393]
                                    mem[(32 * idx) + _393 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2212 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1707 > mem[_2212]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_393]
                                    mem[(32 * idx) + _393 + 32] = mem[_2212] - _1707
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1706 = mem[_393]
                            mem[mem[64] + 32] = mem[_393]
                            mem[mem[64] + 64 len 32 * _1706] = mem[_393 + 32 len 32 * _1706]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1706) + 32], address(arg1)
                        else:
                            mem[_393 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1710 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_393]
                                    mem[(32 * idx) + _393 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2214 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1710 > mem[_2214]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_393]
                                    mem[(32 * idx) + _393 + 32] = mem[_2214] - _1710
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1709 = mem[_393]
                            mem[mem[64] + 32] = mem[_393]
                            mem[mem[64] + 64 len 32 * _1709] = mem[_393 + 32 len 32 * _1709]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1709) + 32], address(arg1)
        else:
            mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
            idx = 0
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[32] = 4
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[0] = sha3(address(arg1), 4)
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = eth.balance(this.address)
                else:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _241 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[_241]
                idx = idx + 1
                continue 
            if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _200 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_200 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _382 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1761 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_382]
                                    mem[(32 * idx) + _382 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2248 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1761 > mem[_2248]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_382]
                                    mem[(32 * idx) + _382 + 32] = mem[_2248] - _1761
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1760 = mem[_382]
                            mem[mem[64] + 32] = mem[_382]
                            mem[mem[64] + 64 len 32 * _1760] = mem[_382 + 32 len 32 * _1760]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1760) + 32], address(arg1)
                        else:
                            mem[_382 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1764 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_382]
                                    mem[(32 * idx) + _382 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2250 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1764 > mem[_2250]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_382]
                                    mem[(32 * idx) + _382 + 32] = mem[_2250] - _1764
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1763 = mem[_382]
                            mem[mem[64] + 32] = mem[_382]
                            mem[mem[64] + 64 len 32 * _1763] = mem[_382 + 32 len 32 * _1763]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1763) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _398 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1767 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_398]
                                    mem[(32 * idx) + _398 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2252 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1767 > mem[_2252]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_398]
                                    mem[(32 * idx) + _398 + 32] = mem[_2252] - _1767
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1766 = mem[_398]
                            mem[mem[64] + 32] = mem[_398]
                            mem[mem[64] + 64 len 32 * _1766] = mem[_398 + 32 len 32 * _1766]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1766) + 32], address(arg1)
                        else:
                            mem[_398 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1770 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_398]
                                    mem[(32 * idx) + _398 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2254 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1770 > mem[_2254]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_398]
                                    mem[(32 * idx) + _398 + 32] = mem[_2254] - _1770
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1769 = mem[_398]
                            mem[mem[64] + 32] = mem[_398]
                            mem[mem[64] + 64 len 32 * _1769] = mem[_398 + 32 len 32 * _1769]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1769) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _201 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_201 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _383 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1773 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_383]
                                    mem[(32 * idx) + _383 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2256 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1773 > mem[_2256]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_383]
                                    mem[(32 * idx) + _383 + 32] = mem[_2256] - _1773
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1772 = mem[_383]
                            mem[mem[64] + 32] = mem[_383]
                            mem[mem[64] + 64 len 32 * _1772] = mem[_383 + 32 len 32 * _1772]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1772) + 32], address(arg1)
                        else:
                            mem[_383 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1776 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_383]
                                    mem[(32 * idx) + _383 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2258 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1776 > mem[_2258]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_383]
                                    mem[(32 * idx) + _383 + 32] = mem[_2258] - _1776
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1775 = mem[_383]
                            mem[mem[64] + 32] = mem[_383]
                            mem[mem[64] + 64 len 32 * _1775] = mem[_383 + 32 len 32 * _1775]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1775) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _399 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1779 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_399]
                                    mem[(32 * idx) + _399 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2260 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1779 > mem[_2260]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_399]
                                    mem[(32 * idx) + _399 + 32] = mem[_2260] - _1779
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1778 = mem[_399]
                            mem[mem[64] + 32] = mem[_399]
                            mem[mem[64] + 64 len 32 * _1778] = mem[_399 + 32 len 32 * _1778]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1778) + 32], address(arg1)
                        else:
                            mem[_399 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1782 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_399]
                                    mem[(32 * idx) + _399 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2262 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1782 > mem[_2262]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_399]
                                    mem[(32 * idx) + _399 + 32] = mem[_2262] - _1782
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1781 = mem[_399]
                            mem[mem[64] + 32] = mem[_399]
                            mem[mem[64] + 64 len 32 * _1781] = mem[_399 + 32 len 32 * _1781]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1781) + 32], address(arg1)
            else:
                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                    revert with 0, 'Missing implementation'
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _216 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_216 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _380 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1737 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_380]
                                    mem[(32 * idx) + _380 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2232 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1737 > mem[_2232]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_380]
                                    mem[(32 * idx) + _380 + 32] = mem[_2232] - _1737
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1736 = mem[_380]
                            mem[mem[64] + 32] = mem[_380]
                            mem[mem[64] + 64 len 32 * _1736] = mem[_380 + 32 len 32 * _1736]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1736) + 32], address(arg1)
                        else:
                            mem[_380 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1740 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_380]
                                    mem[(32 * idx) + _380 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2234 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1740 > mem[_2234]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_380]
                                    mem[(32 * idx) + _380 + 32] = mem[_2234] - _1740
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1739 = mem[_380]
                            mem[mem[64] + 32] = mem[_380]
                            mem[mem[64] + 64 len 32 * _1739] = mem[_380 + 32 len 32 * _1739]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1739) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _396 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1743 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_396]
                                    mem[(32 * idx) + _396 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2236 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1743 > mem[_2236]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_396]
                                    mem[(32 * idx) + _396 + 32] = mem[_2236] - _1743
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1742 = mem[_396]
                            mem[mem[64] + 32] = mem[_396]
                            mem[mem[64] + 64 len 32 * _1742] = mem[_396 + 32 len 32 * _1742]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1742) + 32], address(arg1)
                        else:
                            mem[_396 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1746 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_396]
                                    mem[(32 * idx) + _396 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2238 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1746 > mem[_2238]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_396]
                                    mem[(32 * idx) + _396 + 32] = mem[_2238] - _1746
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1745 = mem[_396]
                            mem[mem[64] + 32] = mem[_396]
                            mem[mem[64] + 64 len 32 * _1745] = mem[_396 + 32 len 32 * _1745]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1745) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _217 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_217 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _381 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1749 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_381]
                                    mem[(32 * idx) + _381 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2240 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1749 > mem[_2240]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_381]
                                    mem[(32 * idx) + _381 + 32] = mem[_2240] - _1749
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1748 = mem[_381]
                            mem[mem[64] + 32] = mem[_381]
                            mem[mem[64] + 64 len 32 * _1748] = mem[_381 + 32 len 32 * _1748]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1748) + 32], address(arg1)
                        else:
                            mem[_381 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1752 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_381]
                                    mem[(32 * idx) + _381 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2242 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1752 > mem[_2242]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_381]
                                    mem[(32 * idx) + _381 + 32] = mem[_2242] - _1752
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1751 = mem[_381]
                            mem[mem[64] + 32] = mem[_381]
                            mem[mem[64] + 64 len 32 * _1751] = mem[_381 + 32 len 32 * _1751]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1751) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _397 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1755 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_397]
                                    mem[(32 * idx) + _397 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2244 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1755 > mem[_2244]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_397]
                                    mem[(32 * idx) + _397 + 32] = mem[_2244] - _1755
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1754 = mem[_397]
                            mem[mem[64] + 32] = mem[_397]
                            mem[mem[64] + 64 len 32 * _1754] = mem[_397 + 32 len 32 * _1754]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1754) + 32], address(arg1)
                        else:
                            mem[_397 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1758 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_397]
                                    mem[(32 * idx) + _397 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2246 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1758 > mem[_2246]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_397]
                                    mem[(32 * idx) + _397 + 32] = mem[_2246] - _1758
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1757 = mem[_397]
                            mem[mem[64] + 32] = mem[_397]
                            mem[mem[64] + 64 len 32 * _1757] = mem[_397 + 32 len 32 * _1757]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1757) + 32], address(arg1)
    else:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
        mem[0] = address(arg1)
        mem[32] = 4
        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
        mem[96] = uint256(sub_c42fa7f4[address(arg1)])
        mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
        if not uint256(sub_c42fa7f4[address(arg1)]):
            idx = 0
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[32] = 4
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[0] = sha3(address(arg1), 4)
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = eth.balance(this.address)
                else:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _248 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[_248]
                idx = idx + 1
                continue 
            if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _204 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_204 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _386 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1809 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_386]
                                    mem[(32 * idx) + _386 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2280 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1809 > mem[_2280]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_386]
                                    mem[(32 * idx) + _386 + 32] = mem[_2280] - _1809
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1808 = mem[_386]
                            mem[mem[64] + 32] = mem[_386]
                            mem[mem[64] + 64 len 32 * _1808] = mem[_386 + 32 len 32 * _1808]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1808) + 32], address(arg1)
                        else:
                            mem[_386 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1812 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_386]
                                    mem[(32 * idx) + _386 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2282 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1812 > mem[_2282]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_386]
                                    mem[(32 * idx) + _386 + 32] = mem[_2282] - _1812
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1811 = mem[_386]
                            mem[mem[64] + 32] = mem[_386]
                            mem[mem[64] + 64 len 32 * _1811] = mem[_386 + 32 len 32 * _1811]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1811) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _402 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1815 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_402]
                                    mem[(32 * idx) + _402 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2284 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1815 > mem[_2284]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_402]
                                    mem[(32 * idx) + _402 + 32] = mem[_2284] - _1815
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1814 = mem[_402]
                            mem[mem[64] + 32] = mem[_402]
                            mem[mem[64] + 64 len 32 * _1814] = mem[_402 + 32 len 32 * _1814]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1814) + 32], address(arg1)
                        else:
                            mem[_402 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1818 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_402]
                                    mem[(32 * idx) + _402 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2286 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1818 > mem[_2286]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_402]
                                    mem[(32 * idx) + _402 + 32] = mem[_2286] - _1818
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1817 = mem[_402]
                            mem[mem[64] + 32] = mem[_402]
                            mem[mem[64] + 64 len 32 * _1817] = mem[_402 + 32 len 32 * _1817]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1817) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _205 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_205 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _387 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1821 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_387]
                                    mem[(32 * idx) + _387 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2288 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1821 > mem[_2288]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_387]
                                    mem[(32 * idx) + _387 + 32] = mem[_2288] - _1821
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1820 = mem[_387]
                            mem[mem[64] + 32] = mem[_387]
                            mem[mem[64] + 64 len 32 * _1820] = mem[_387 + 32 len 32 * _1820]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1820) + 32], address(arg1)
                        else:
                            mem[_387 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1824 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_387]
                                    mem[(32 * idx) + _387 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2290 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1824 > mem[_2290]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_387]
                                    mem[(32 * idx) + _387 + 32] = mem[_2290] - _1824
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1823 = mem[_387]
                            mem[mem[64] + 32] = mem[_387]
                            mem[mem[64] + 64 len 32 * _1823] = mem[_387 + 32 len 32 * _1823]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1823) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _403 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1827 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_403]
                                    mem[(32 * idx) + _403 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2292 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1827 > mem[_2292]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_403]
                                    mem[(32 * idx) + _403 + 32] = mem[_2292] - _1827
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1826 = mem[_403]
                            mem[mem[64] + 32] = mem[_403]
                            mem[mem[64] + 64 len 32 * _1826] = mem[_403 + 32 len 32 * _1826]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1826) + 32], address(arg1)
                        else:
                            mem[_403 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1830 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_403]
                                    mem[(32 * idx) + _403 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2294 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1830 > mem[_2294]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_403]
                                    mem[(32 * idx) + _403 + 32] = mem[_2294] - _1830
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1829 = mem[_403]
                            mem[mem[64] + 32] = mem[_403]
                            mem[mem[64] + 64 len 32 * _1829] = mem[_403 + 32 len 32 * _1829]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1829) + 32], address(arg1)
            else:
                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                    revert with 0, 'Missing implementation'
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _220 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_220 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _384 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1785 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_384]
                                    mem[(32 * idx) + _384 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2264 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1785 > mem[_2264]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_384]
                                    mem[(32 * idx) + _384 + 32] = mem[_2264] - _1785
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1784 = mem[_384]
                            mem[mem[64] + 32] = mem[_384]
                            mem[mem[64] + 64 len 32 * _1784] = mem[_384 + 32 len 32 * _1784]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1784) + 32], address(arg1)
                        else:
                            mem[_384 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1788 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_384]
                                    mem[(32 * idx) + _384 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2266 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1788 > mem[_2266]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_384]
                                    mem[(32 * idx) + _384 + 32] = mem[_2266] - _1788
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1787 = mem[_384]
                            mem[mem[64] + 32] = mem[_384]
                            mem[mem[64] + 64 len 32 * _1787] = mem[_384 + 32 len 32 * _1787]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1787) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _400 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1791 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_400]
                                    mem[(32 * idx) + _400 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2268 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1791 > mem[_2268]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_400]
                                    mem[(32 * idx) + _400 + 32] = mem[_2268] - _1791
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1790 = mem[_400]
                            mem[mem[64] + 32] = mem[_400]
                            mem[mem[64] + 64 len 32 * _1790] = mem[_400 + 32 len 32 * _1790]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1790) + 32], address(arg1)
                        else:
                            mem[_400 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1794 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_400]
                                    mem[(32 * idx) + _400 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2270 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1794 > mem[_2270]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_400]
                                    mem[(32 * idx) + _400 + 32] = mem[_2270] - _1794
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1793 = mem[_400]
                            mem[mem[64] + 32] = mem[_400]
                            mem[mem[64] + 64 len 32 * _1793] = mem[_400 + 32 len 32 * _1793]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1793) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _221 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_221 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _385 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1797 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_385]
                                    mem[(32 * idx) + _385 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2272 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1797 > mem[_2272]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_385]
                                    mem[(32 * idx) + _385 + 32] = mem[_2272] - _1797
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1796 = mem[_385]
                            mem[mem[64] + 32] = mem[_385]
                            mem[mem[64] + 64 len 32 * _1796] = mem[_385 + 32 len 32 * _1796]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1796) + 32], address(arg1)
                        else:
                            mem[_385 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1800 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_385]
                                    mem[(32 * idx) + _385 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2274 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1800 > mem[_2274]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_385]
                                    mem[(32 * idx) + _385 + 32] = mem[_2274] - _1800
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1799 = mem[_385]
                            mem[mem[64] + 32] = mem[_385]
                            mem[mem[64] + 64 len 32 * _1799] = mem[_385 + 32 len 32 * _1799]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1799) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _401 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1803 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_401]
                                    mem[(32 * idx) + _401 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2276 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1803 > mem[_2276]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_401]
                                    mem[(32 * idx) + _401 + 32] = mem[_2276] - _1803
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1802 = mem[_401]
                            mem[mem[64] + 32] = mem[_401]
                            mem[mem[64] + 64 len 32 * _1802] = mem[_401 + 32 len 32 * _1802]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1802) + 32], address(arg1)
                        else:
                            mem[_401 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1806 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_401]
                                    mem[(32 * idx) + _401 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2278 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1806 > mem[_2278]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_401]
                                    mem[(32 * idx) + _401 + 32] = mem[_2278] - _1806
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1805 = mem[_401]
                            mem[mem[64] + 32] = mem[_401]
                            mem[mem[64] + 64 len 32 * _1805] = mem[_401 + 32 len 32 * _1805]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1805) + 32], address(arg1)
        else:
            mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
            idx = 0
            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                mem[32] = 4
                require idx < uint256(sub_c42fa7f4[address(arg1)])
                mem[0] = sha3(address(arg1), 4)
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = eth.balance(this.address)
                else:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _255 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[_255]
                idx = idx + 1
                continue 
            if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_208 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _390 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1857 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_390]
                                    mem[(32 * idx) + _390 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2312 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1857 > mem[_2312]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_390]
                                    mem[(32 * idx) + _390 + 32] = mem[_2312] - _1857
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1856 = mem[_390]
                            mem[mem[64] + 32] = mem[_390]
                            mem[mem[64] + 64 len 32 * _1856] = mem[_390 + 32 len 32 * _1856]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1856) + 32], address(arg1)
                        else:
                            mem[_390 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1860 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_390]
                                    mem[(32 * idx) + _390 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2314 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1860 > mem[_2314]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_390]
                                    mem[(32 * idx) + _390 + 32] = mem[_2314] - _1860
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1859 = mem[_390]
                            mem[mem[64] + 32] = mem[_390]
                            mem[mem[64] + 64 len 32 * _1859] = mem[_390 + 32 len 32 * _1859]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1859) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _406 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1863 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_406]
                                    mem[(32 * idx) + _406 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2316 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1863 > mem[_2316]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_406]
                                    mem[(32 * idx) + _406 + 32] = mem[_2316] - _1863
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1862 = mem[_406]
                            mem[mem[64] + 32] = mem[_406]
                            mem[mem[64] + 64 len 32 * _1862] = mem[_406 + 32 len 32 * _1862]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1862) + 32], address(arg1)
                        else:
                            mem[_406 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1866 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_406]
                                    mem[(32 * idx) + _406 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2318 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1866 > mem[_2318]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_406]
                                    mem[(32 * idx) + _406 + 32] = mem[_2318] - _1866
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1865 = mem[_406]
                            mem[mem[64] + 32] = mem[_406]
                            mem[mem[64] + 64 len 32 * _1865] = mem[_406 + 32 len 32 * _1865]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1865) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _209 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_209 len 64] = call.data[calldata.size len 64]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _391 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1869 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_391]
                                    mem[(32 * idx) + _391 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2320 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1869 > mem[_2320]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_391]
                                    mem[(32 * idx) + _391 + 32] = mem[_2320] - _1869
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1868 = mem[_391]
                            mem[mem[64] + 32] = mem[_391]
                            mem[mem[64] + 64 len 32 * _1868] = mem[_391 + 32 len 32 * _1868]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1868) + 32], address(arg1)
                        else:
                            mem[_391 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1872 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_391]
                                    mem[(32 * idx) + _391 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2322 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1872 > mem[_2322]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_391]
                                    mem[(32 * idx) + _391 + 32] = mem[_2322] - _1872
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1871 = mem[_391]
                            mem[mem[64] + 32] = mem[_391]
                            mem[mem[64] + 64 len 32 * _1871] = mem[_391 + 32 len 32 * _1871]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1871) + 32], address(arg1)
                    else:
                        mem[mem[64] + 100] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].0x269b5581 with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 64], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _407 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1875 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_407]
                                    mem[(32 * idx) + _407 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2324 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1875 > mem[_2324]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_407]
                                    mem[(32 * idx) + _407 + 32] = mem[_2324] - _1875
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1874 = mem[_407]
                            mem[mem[64] + 32] = mem[_407]
                            mem[mem[64] + 64 len 32 * _1874] = mem[_407 + 32 len 32 * _1874]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1874) + 32], address(arg1)
                        else:
                            mem[_407 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1878 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_407]
                                    mem[(32 * idx) + _407 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2326 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1878 > mem[_2326]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_407]
                                    mem[(32 * idx) + _407 + 32] = mem[_2326] - _1878
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1877 = mem[_407]
                            mem[mem[64] + 32] = mem[_407]
                            mem[mem[64] + 64 len 32 * _1877] = mem[_407 + 32 len 32 * _1877]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1877) + 32], address(arg1)
            else:
                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                    revert with 0, 'Missing implementation'
                mem[0] = address(arg1)
                if not sub_e676ea95[address(arg1)]:
                    _224 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_224 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _388 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1833 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_388]
                                    mem[(32 * idx) + _388 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2296 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1833 > mem[_2296]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_388]
                                    mem[(32 * idx) + _388 + 32] = mem[_2296] - _1833
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1832 = mem[_388]
                            mem[mem[64] + 32] = mem[_388]
                            mem[mem[64] + 64 len 32 * _1832] = mem[_388 + 32 len 32 * _1832]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1832) + 32], address(arg1)
                        else:
                            mem[_388 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1836 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_388]
                                    mem[(32 * idx) + _388 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2298 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1836 > mem[_2298]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_388]
                                    mem[(32 * idx) + _388 + 32] = mem[_2298] - _1836
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1835 = mem[_388]
                            mem[mem[64] + 32] = mem[_388]
                            mem[mem[64] + 64 len 32 * _1835] = mem[_388 + 32 len 32 * _1835]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1835) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(address(arg1))
                        call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _404 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1839 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_404]
                                    mem[(32 * idx) + _404 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2300 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1839 > mem[_2300]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_404]
                                    mem[(32 * idx) + _404 + 32] = mem[_2300] - _1839
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1838 = mem[_404]
                            mem[mem[64] + 32] = mem[_404]
                            mem[mem[64] + 64 len 32 * _1838] = mem[_404 + 32 len 32 * _1838]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1838) + 32], address(arg1)
                        else:
                            mem[_404 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1842 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_404]
                                    mem[(32 * idx) + _404 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2302 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1842 > mem[_2302]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_404]
                                    mem[(32 * idx) + _404 + 32] = mem[_2302] - _1842
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1841 = mem[_404]
                            mem[mem[64] + 32] = mem[_404]
                            mem[mem[64] + 64 len 32 * _1841] = mem[_404 + 32 len 32 * _1841]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1841) + 32], address(arg1)
                else:
                    mem[0] = address(arg1)
                    _225 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_225 len 96] = call.data[calldata.size len 96]
                    mem[0] = address(arg1)
                    mem[32] = 6
                    mem[mem[64] + 4] = arg2
                    mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                    if not stor6[address(arg1)]:
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _389 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1845 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_389]
                                    mem[(32 * idx) + _389 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2304 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1845 > mem[_2304]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_389]
                                    mem[(32 * idx) + _389 + 32] = mem[_2304] - _1845
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1844 = mem[_389]
                            mem[mem[64] + 32] = mem[_389]
                            mem[mem[64] + 64 len 32 * _1844] = mem[_389 + 32 len 32 * _1844]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1844) + 32], address(arg1)
                        else:
                            mem[_389 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1848 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_389]
                                    mem[(32 * idx) + _389 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2306 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1848 > mem[_2306]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_389]
                                    mem[(32 * idx) + _389 + 32] = mem[_2306] - _1848
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1847 = mem[_389]
                            mem[mem[64] + 32] = mem[_389]
                            mem[mem[64] + 64 len 32 * _1847] = mem[_389 + 32 len 32 * _1847]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1847) + 32], address(arg1)
                    else:
                        mem[mem[64] + 132] = 1
                        require ext_code.size(sub_e676ea95[address(arg1)])
                        call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                             gas gas_remaining wei
                            args arg2, call.data[calldata.size len 96], 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                        _405 = mem[64]
                        mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                        mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                        if not uint256(sub_c42fa7f4[address(arg1)]):
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1851 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_405]
                                    mem[(32 * idx) + _405 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2308 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1851 > mem[_2308]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_405]
                                    mem[(32 * idx) + _405 + 32] = mem[_2308] - _1851
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1850 = mem[_405]
                            mem[mem[64] + 32] = mem[_405]
                            mem[mem[64] + 64 len 32 * _1850] = mem[_405 + 32 len 32 * _1850]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1850) + 32], address(arg1)
                        else:
                            mem[_405 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                            idx = 0
                            while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                require idx < mem[96]
                                _1854 = mem[(32 * idx) + 128]
                                mem[32] = 4
                                require idx < uint256(sub_c42fa7f4[address(arg1)])
                                mem[0] = sha3(address(arg1), 4)
                                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                    if mem[(32 * idx) + 128] > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_405]
                                    mem[(32 * idx) + _405 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                else:
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                    staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2310 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _1854 > mem[_2310]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require idx < mem[_405]
                                    mem[(32 * idx) + _405 + 32] = mem[_2310] - _1854
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 32
                            _1853 = mem[_405]
                            mem[mem[64] + 32] = mem[_405]
                            mem[mem[64] + 64 len 32 * _1853] = mem[_405 + 32 len 32 * _1853]
                            emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _1853) + 32], address(arg1)
}

function sub_0fd9a255(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 == address(arg3)
    if owner == msg.sender:
        mem[100] = arg2
        require ext_code.size(address(arg3))
        call address(arg3).withdraw(uint256 arg1) with:
             gas gas_remaining wei
            args arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if owner == msg.sender:
            mem[0] = address(arg1)
            mem[32] = 4
            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
            mem[96] = uint256(sub_c42fa7f4[address(arg1)])
            mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
            if not uint256(sub_c42fa7f4[address(arg1)]):
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[32] = 4
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[0] = sha3(address(arg1), 4)
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = eth.balance(this.address)
                    else:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _700 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = mem[_700]
                    idx = idx + 1
                    continue 
                if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_598 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1140 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5483 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1140]
                                        mem[(32 * idx) + _1140 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7211 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5483 > mem[_7211]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1140]
                                        mem[(32 * idx) + _1140 + 32] = mem[_7211] - _5483
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5482 = mem[_1140]
                                mem[mem[64] + 32] = mem[_1140]
                                mem[mem[64] + 64 len 32 * _5482] = mem[_1140 + 32 len 32 * _5482]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5482) + 32], address(arg1)
                            else:
                                mem[_1140 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5486 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1140]
                                        mem[(32 * idx) + _1140 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7214 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5486 > mem[_7214]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1140]
                                        mem[(32 * idx) + _1140 + 32] = mem[_7214] - _5486
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5485 = mem[_1140]
                                mem[mem[64] + 32] = mem[_1140]
                                mem[mem[64] + 64 len 32 * _5485] = mem[_1140 + 32 len 32 * _5485]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5485) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1188 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5489 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1188]
                                        mem[(32 * idx) + _1188 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7217 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5489 > mem[_7217]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1188]
                                        mem[(32 * idx) + _1188 + 32] = mem[_7217] - _5489
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5488 = mem[_1188]
                                mem[mem[64] + 32] = mem[_1188]
                                mem[mem[64] + 64 len 32 * _5488] = mem[_1188 + 32 len 32 * _5488]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5488) + 32], address(arg1)
                            else:
                                mem[_1188 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5492 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1188]
                                        mem[(32 * idx) + _1188 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7220 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5492 > mem[_7220]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1188]
                                        mem[(32 * idx) + _1188 + 32] = mem[_7220] - _5492
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5491 = mem[_1188]
                                mem[mem[64] + 32] = mem[_1188]
                                mem[mem[64] + 64 len 32 * _5491] = mem[_1188 + 32 len 32 * _5491]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5491) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _599 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_599 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1141 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5495 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1141]
                                        mem[(32 * idx) + _1141 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7223 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5495 > mem[_7223]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1141]
                                        mem[(32 * idx) + _1141 + 32] = mem[_7223] - _5495
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5494 = mem[_1141]
                                mem[mem[64] + 32] = mem[_1141]
                                mem[mem[64] + 64 len 32 * _5494] = mem[_1141 + 32 len 32 * _5494]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5494) + 32], address(arg1)
                            else:
                                mem[_1141 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5498 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1141]
                                        mem[(32 * idx) + _1141 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7226 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5498 > mem[_7226]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1141]
                                        mem[(32 * idx) + _1141 + 32] = mem[_7226] - _5498
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5497 = mem[_1141]
                                mem[mem[64] + 32] = mem[_1141]
                                mem[mem[64] + 64 len 32 * _5497] = mem[_1141 + 32 len 32 * _5497]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5497) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1189 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5501 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1189]
                                        mem[(32 * idx) + _1189 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7229 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5501 > mem[_7229]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1189]
                                        mem[(32 * idx) + _1189 + 32] = mem[_7229] - _5501
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5500 = mem[_1189]
                                mem[mem[64] + 32] = mem[_1189]
                                mem[mem[64] + 64 len 32 * _5500] = mem[_1189 + 32 len 32 * _5500]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5500) + 32], address(arg1)
                            else:
                                mem[_1189 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5504 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1189]
                                        mem[(32 * idx) + _1189 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7232 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5504 > mem[_7232]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1189]
                                        mem[(32 * idx) + _1189 + 32] = mem[_7232] - _5504
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5503 = mem[_1189]
                                mem[mem[64] + 32] = mem[_1189]
                                mem[mem[64] + 64 len 32 * _5503] = mem[_1189 + 32 len 32 * _5503]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5503) + 32], address(arg1)
                else:
                    if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                        revert with 0, 'Missing implementation'
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _646 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_646 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1138 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5459 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1138]
                                        mem[(32 * idx) + _1138 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7187 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5459 > mem[_7187]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1138]
                                        mem[(32 * idx) + _1138 + 32] = mem[_7187] - _5459
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5458 = mem[_1138]
                                mem[mem[64] + 32] = mem[_1138]
                                mem[mem[64] + 64 len 32 * _5458] = mem[_1138 + 32 len 32 * _5458]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5458) + 32], address(arg1)
                            else:
                                mem[_1138 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5462 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1138]
                                        mem[(32 * idx) + _1138 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7190 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5462 > mem[_7190]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1138]
                                        mem[(32 * idx) + _1138 + 32] = mem[_7190] - _5462
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5461 = mem[_1138]
                                mem[mem[64] + 32] = mem[_1138]
                                mem[mem[64] + 64 len 32 * _5461] = mem[_1138 + 32 len 32 * _5461]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5461) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1186 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5465 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1186]
                                        mem[(32 * idx) + _1186 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7193 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5465 > mem[_7193]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1186]
                                        mem[(32 * idx) + _1186 + 32] = mem[_7193] - _5465
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5464 = mem[_1186]
                                mem[mem[64] + 32] = mem[_1186]
                                mem[mem[64] + 64 len 32 * _5464] = mem[_1186 + 32 len 32 * _5464]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5464) + 32], address(arg1)
                            else:
                                mem[_1186 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5468 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1186]
                                        mem[(32 * idx) + _1186 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7196 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5468 > mem[_7196]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1186]
                                        mem[(32 * idx) + _1186 + 32] = mem[_7196] - _5468
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5467 = mem[_1186]
                                mem[mem[64] + 32] = mem[_1186]
                                mem[mem[64] + 64 len 32 * _5467] = mem[_1186 + 32 len 32 * _5467]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5467) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _647 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_647 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1139 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5471 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1139]
                                        mem[(32 * idx) + _1139 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7199 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5471 > mem[_7199]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1139]
                                        mem[(32 * idx) + _1139 + 32] = mem[_7199] - _5471
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5470 = mem[_1139]
                                mem[mem[64] + 32] = mem[_1139]
                                mem[mem[64] + 64 len 32 * _5470] = mem[_1139 + 32 len 32 * _5470]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5470) + 32], address(arg1)
                            else:
                                mem[_1139 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5474 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1139]
                                        mem[(32 * idx) + _1139 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7202 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5474 > mem[_7202]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1139]
                                        mem[(32 * idx) + _1139 + 32] = mem[_7202] - _5474
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5473 = mem[_1139]
                                mem[mem[64] + 32] = mem[_1139]
                                mem[mem[64] + 64 len 32 * _5473] = mem[_1139 + 32 len 32 * _5473]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5473) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1187 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5477 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1187]
                                        mem[(32 * idx) + _1187 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7205 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5477 > mem[_7205]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1187]
                                        mem[(32 * idx) + _1187 + 32] = mem[_7205] - _5477
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5476 = mem[_1187]
                                mem[mem[64] + 32] = mem[_1187]
                                mem[mem[64] + 64 len 32 * _5476] = mem[_1187 + 32 len 32 * _5476]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5476) + 32], address(arg1)
                            else:
                                mem[_1187 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5480 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1187]
                                        mem[(32 * idx) + _1187 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7208 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5480 > mem[_7208]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1187]
                                        mem[(32 * idx) + _1187 + 32] = mem[_7208] - _5480
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5479 = mem[_1187]
                                mem[mem[64] + 32] = mem[_1187]
                                mem[mem[64] + 64 len 32 * _5479] = mem[_1187 + 32 len 32 * _5479]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5479) + 32], address(arg1)
            else:
                mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[32] = 4
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[0] = sha3(address(arg1), 4)
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = eth.balance(this.address)
                    else:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _707 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = mem[_707]
                    idx = idx + 1
                    continue 
                if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_602 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1144 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5531 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1144]
                                        mem[(32 * idx) + _1144 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7259 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5531 > mem[_7259]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1144]
                                        mem[(32 * idx) + _1144 + 32] = mem[_7259] - _5531
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5530 = mem[_1144]
                                mem[mem[64] + 32] = mem[_1144]
                                mem[mem[64] + 64 len 32 * _5530] = mem[_1144 + 32 len 32 * _5530]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5530) + 32], address(arg1)
                            else:
                                mem[_1144 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5534 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1144]
                                        mem[(32 * idx) + _1144 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7262 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5534 > mem[_7262]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1144]
                                        mem[(32 * idx) + _1144 + 32] = mem[_7262] - _5534
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5533 = mem[_1144]
                                mem[mem[64] + 32] = mem[_1144]
                                mem[mem[64] + 64 len 32 * _5533] = mem[_1144 + 32 len 32 * _5533]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5533) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1192 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5537 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1192]
                                        mem[(32 * idx) + _1192 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7265 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5537 > mem[_7265]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1192]
                                        mem[(32 * idx) + _1192 + 32] = mem[_7265] - _5537
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5536 = mem[_1192]
                                mem[mem[64] + 32] = mem[_1192]
                                mem[mem[64] + 64 len 32 * _5536] = mem[_1192 + 32 len 32 * _5536]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5536) + 32], address(arg1)
                            else:
                                mem[_1192 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5540 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1192]
                                        mem[(32 * idx) + _1192 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7268 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5540 > mem[_7268]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1192]
                                        mem[(32 * idx) + _1192 + 32] = mem[_7268] - _5540
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5539 = mem[_1192]
                                mem[mem[64] + 32] = mem[_1192]
                                mem[mem[64] + 64 len 32 * _5539] = mem[_1192 + 32 len 32 * _5539]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5539) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _603 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_603 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1145 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5543 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1145]
                                        mem[(32 * idx) + _1145 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7271 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5543 > mem[_7271]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1145]
                                        mem[(32 * idx) + _1145 + 32] = mem[_7271] - _5543
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5542 = mem[_1145]
                                mem[mem[64] + 32] = mem[_1145]
                                mem[mem[64] + 64 len 32 * _5542] = mem[_1145 + 32 len 32 * _5542]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5542) + 32], address(arg1)
                            else:
                                mem[_1145 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5546 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1145]
                                        mem[(32 * idx) + _1145 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7274 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5546 > mem[_7274]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1145]
                                        mem[(32 * idx) + _1145 + 32] = mem[_7274] - _5546
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5545 = mem[_1145]
                                mem[mem[64] + 32] = mem[_1145]
                                mem[mem[64] + 64 len 32 * _5545] = mem[_1145 + 32 len 32 * _5545]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5545) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1193 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5549 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1193]
                                        mem[(32 * idx) + _1193 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7277 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5549 > mem[_7277]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1193]
                                        mem[(32 * idx) + _1193 + 32] = mem[_7277] - _5549
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5548 = mem[_1193]
                                mem[mem[64] + 32] = mem[_1193]
                                mem[mem[64] + 64 len 32 * _5548] = mem[_1193 + 32 len 32 * _5548]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5548) + 32], address(arg1)
                            else:
                                mem[_1193 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5552 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1193]
                                        mem[(32 * idx) + _1193 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7280 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5552 > mem[_7280]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1193]
                                        mem[(32 * idx) + _1193 + 32] = mem[_7280] - _5552
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5551 = mem[_1193]
                                mem[mem[64] + 32] = mem[_1193]
                                mem[mem[64] + 64 len 32 * _5551] = mem[_1193 + 32 len 32 * _5551]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5551) + 32], address(arg1)
                else:
                    if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                        revert with 0, 'Missing implementation'
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _650 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_650 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1142 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5507 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1142]
                                        mem[(32 * idx) + _1142 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7235 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5507 > mem[_7235]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1142]
                                        mem[(32 * idx) + _1142 + 32] = mem[_7235] - _5507
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5506 = mem[_1142]
                                mem[mem[64] + 32] = mem[_1142]
                                mem[mem[64] + 64 len 32 * _5506] = mem[_1142 + 32 len 32 * _5506]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5506) + 32], address(arg1)
                            else:
                                mem[_1142 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5510 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1142]
                                        mem[(32 * idx) + _1142 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7238 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5510 > mem[_7238]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1142]
                                        mem[(32 * idx) + _1142 + 32] = mem[_7238] - _5510
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5509 = mem[_1142]
                                mem[mem[64] + 32] = mem[_1142]
                                mem[mem[64] + 64 len 32 * _5509] = mem[_1142 + 32 len 32 * _5509]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5509) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1190 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5513 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1190]
                                        mem[(32 * idx) + _1190 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7241 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5513 > mem[_7241]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1190]
                                        mem[(32 * idx) + _1190 + 32] = mem[_7241] - _5513
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5512 = mem[_1190]
                                mem[mem[64] + 32] = mem[_1190]
                                mem[mem[64] + 64 len 32 * _5512] = mem[_1190 + 32 len 32 * _5512]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5512) + 32], address(arg1)
                            else:
                                mem[_1190 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5516 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1190]
                                        mem[(32 * idx) + _1190 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7244 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5516 > mem[_7244]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1190]
                                        mem[(32 * idx) + _1190 + 32] = mem[_7244] - _5516
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5515 = mem[_1190]
                                mem[mem[64] + 32] = mem[_1190]
                                mem[mem[64] + 64 len 32 * _5515] = mem[_1190 + 32 len 32 * _5515]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5515) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _651 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_651 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1143 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5519 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1143]
                                        mem[(32 * idx) + _1143 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7247 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5519 > mem[_7247]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1143]
                                        mem[(32 * idx) + _1143 + 32] = mem[_7247] - _5519
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5518 = mem[_1143]
                                mem[mem[64] + 32] = mem[_1143]
                                mem[mem[64] + 64 len 32 * _5518] = mem[_1143 + 32 len 32 * _5518]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5518) + 32], address(arg1)
                            else:
                                mem[_1143 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5522 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1143]
                                        mem[(32 * idx) + _1143 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7250 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5522 > mem[_7250]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1143]
                                        mem[(32 * idx) + _1143 + 32] = mem[_7250] - _5522
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5521 = mem[_1143]
                                mem[mem[64] + 32] = mem[_1143]
                                mem[mem[64] + 64 len 32 * _5521] = mem[_1143 + 32 len 32 * _5521]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5521) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1191 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5525 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1191]
                                        mem[(32 * idx) + _1191 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7253 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5525 > mem[_7253]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1191]
                                        mem[(32 * idx) + _1191 + 32] = mem[_7253] - _5525
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5524 = mem[_1191]
                                mem[mem[64] + 32] = mem[_1191]
                                mem[mem[64] + 64 len 32 * _5524] = mem[_1191 + 32 len 32 * _5524]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5524) + 32], address(arg1)
                            else:
                                mem[_1191 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5528 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1191]
                                        mem[(32 * idx) + _1191 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7256 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5528 > mem[_7256]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1191]
                                        mem[(32 * idx) + _1191 + 32] = mem[_7256] - _5528
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5527 = mem[_1191]
                                mem[mem[64] + 32] = mem[_1191]
                                mem[mem[64] + 64 len 32 * _5527] = mem[_1191 + 32 len 32 * _5527]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5527) + 32], address(arg1)
        else:
            if not stor1[msg.sender]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
            mem[0] = address(arg1)
            mem[32] = 4
            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
            mem[96] = uint256(sub_c42fa7f4[address(arg1)])
            mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
            if not uint256(sub_c42fa7f4[address(arg1)]):
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[32] = 4
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[0] = sha3(address(arg1), 4)
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = eth.balance(this.address)
                    else:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _714 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = mem[_714]
                    idx = idx + 1
                    continue 
                if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _606 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_606 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1148 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5579 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1148]
                                        mem[(32 * idx) + _1148 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7307 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5579 > mem[_7307]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1148]
                                        mem[(32 * idx) + _1148 + 32] = mem[_7307] - _5579
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5578 = mem[_1148]
                                mem[mem[64] + 32] = mem[_1148]
                                mem[mem[64] + 64 len 32 * _5578] = mem[_1148 + 32 len 32 * _5578]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5578) + 32], address(arg1)
                            else:
                                mem[_1148 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5582 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1148]
                                        mem[(32 * idx) + _1148 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7310 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5582 > mem[_7310]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1148]
                                        mem[(32 * idx) + _1148 + 32] = mem[_7310] - _5582
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5581 = mem[_1148]
                                mem[mem[64] + 32] = mem[_1148]
                                mem[mem[64] + 64 len 32 * _5581] = mem[_1148 + 32 len 32 * _5581]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5581) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1196 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5585 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1196]
                                        mem[(32 * idx) + _1196 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7313 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5585 > mem[_7313]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1196]
                                        mem[(32 * idx) + _1196 + 32] = mem[_7313] - _5585
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5584 = mem[_1196]
                                mem[mem[64] + 32] = mem[_1196]
                                mem[mem[64] + 64 len 32 * _5584] = mem[_1196 + 32 len 32 * _5584]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5584) + 32], address(arg1)
                            else:
                                mem[_1196 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5588 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1196]
                                        mem[(32 * idx) + _1196 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7316 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5588 > mem[_7316]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1196]
                                        mem[(32 * idx) + _1196 + 32] = mem[_7316] - _5588
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5587 = mem[_1196]
                                mem[mem[64] + 32] = mem[_1196]
                                mem[mem[64] + 64 len 32 * _5587] = mem[_1196 + 32 len 32 * _5587]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5587) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_607 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1149 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5591 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1149]
                                        mem[(32 * idx) + _1149 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7319 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5591 > mem[_7319]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1149]
                                        mem[(32 * idx) + _1149 + 32] = mem[_7319] - _5591
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5590 = mem[_1149]
                                mem[mem[64] + 32] = mem[_1149]
                                mem[mem[64] + 64 len 32 * _5590] = mem[_1149 + 32 len 32 * _5590]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5590) + 32], address(arg1)
                            else:
                                mem[_1149 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5594 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1149]
                                        mem[(32 * idx) + _1149 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7322 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5594 > mem[_7322]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1149]
                                        mem[(32 * idx) + _1149 + 32] = mem[_7322] - _5594
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5593 = mem[_1149]
                                mem[mem[64] + 32] = mem[_1149]
                                mem[mem[64] + 64 len 32 * _5593] = mem[_1149 + 32 len 32 * _5593]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5593) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1197 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5597 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1197]
                                        mem[(32 * idx) + _1197 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7325 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5597 > mem[_7325]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1197]
                                        mem[(32 * idx) + _1197 + 32] = mem[_7325] - _5597
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5596 = mem[_1197]
                                mem[mem[64] + 32] = mem[_1197]
                                mem[mem[64] + 64 len 32 * _5596] = mem[_1197 + 32 len 32 * _5596]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5596) + 32], address(arg1)
                            else:
                                mem[_1197 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5600 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1197]
                                        mem[(32 * idx) + _1197 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7328 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5600 > mem[_7328]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1197]
                                        mem[(32 * idx) + _1197 + 32] = mem[_7328] - _5600
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5599 = mem[_1197]
                                mem[mem[64] + 32] = mem[_1197]
                                mem[mem[64] + 64 len 32 * _5599] = mem[_1197 + 32 len 32 * _5599]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5599) + 32], address(arg1)
                else:
                    if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                        revert with 0, 'Missing implementation'
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _654 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_654 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1146 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5555 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1146]
                                        mem[(32 * idx) + _1146 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7283 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5555 > mem[_7283]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1146]
                                        mem[(32 * idx) + _1146 + 32] = mem[_7283] - _5555
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5554 = mem[_1146]
                                mem[mem[64] + 32] = mem[_1146]
                                mem[mem[64] + 64 len 32 * _5554] = mem[_1146 + 32 len 32 * _5554]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5554) + 32], address(arg1)
                            else:
                                mem[_1146 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5558 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1146]
                                        mem[(32 * idx) + _1146 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7286 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5558 > mem[_7286]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1146]
                                        mem[(32 * idx) + _1146 + 32] = mem[_7286] - _5558
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5557 = mem[_1146]
                                mem[mem[64] + 32] = mem[_1146]
                                mem[mem[64] + 64 len 32 * _5557] = mem[_1146 + 32 len 32 * _5557]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5557) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1194 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5561 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1194]
                                        mem[(32 * idx) + _1194 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7289 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5561 > mem[_7289]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1194]
                                        mem[(32 * idx) + _1194 + 32] = mem[_7289] - _5561
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5560 = mem[_1194]
                                mem[mem[64] + 32] = mem[_1194]
                                mem[mem[64] + 64 len 32 * _5560] = mem[_1194 + 32 len 32 * _5560]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5560) + 32], address(arg1)
                            else:
                                mem[_1194 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5564 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1194]
                                        mem[(32 * idx) + _1194 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7292 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5564 > mem[_7292]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1194]
                                        mem[(32 * idx) + _1194 + 32] = mem[_7292] - _5564
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5563 = mem[_1194]
                                mem[mem[64] + 32] = mem[_1194]
                                mem[mem[64] + 64 len 32 * _5563] = mem[_1194 + 32 len 32 * _5563]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5563) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _655 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_655 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1147 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5567 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1147]
                                        mem[(32 * idx) + _1147 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7295 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5567 > mem[_7295]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1147]
                                        mem[(32 * idx) + _1147 + 32] = mem[_7295] - _5567
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5566 = mem[_1147]
                                mem[mem[64] + 32] = mem[_1147]
                                mem[mem[64] + 64 len 32 * _5566] = mem[_1147 + 32 len 32 * _5566]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5566) + 32], address(arg1)
                            else:
                                mem[_1147 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5570 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1147]
                                        mem[(32 * idx) + _1147 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7298 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5570 > mem[_7298]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1147]
                                        mem[(32 * idx) + _1147 + 32] = mem[_7298] - _5570
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5569 = mem[_1147]
                                mem[mem[64] + 32] = mem[_1147]
                                mem[mem[64] + 64 len 32 * _5569] = mem[_1147 + 32 len 32 * _5569]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5569) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1195 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5573 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1195]
                                        mem[(32 * idx) + _1195 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7301 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5573 > mem[_7301]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1195]
                                        mem[(32 * idx) + _1195 + 32] = mem[_7301] - _5573
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5572 = mem[_1195]
                                mem[mem[64] + 32] = mem[_1195]
                                mem[mem[64] + 64 len 32 * _5572] = mem[_1195 + 32 len 32 * _5572]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5572) + 32], address(arg1)
                            else:
                                mem[_1195 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5576 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1195]
                                        mem[(32 * idx) + _1195 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7304 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5576 > mem[_7304]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1195]
                                        mem[(32 * idx) + _1195 + 32] = mem[_7304] - _5576
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5575 = mem[_1195]
                                mem[mem[64] + 32] = mem[_1195]
                                mem[mem[64] + 64 len 32 * _5575] = mem[_1195 + 32 len 32 * _5575]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5575) + 32], address(arg1)
            else:
                mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    mem[32] = 4
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[0] = sha3(address(arg1), 4)
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = eth.balance(this.address)
                    else:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _721 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = mem[_721]
                    idx = idx + 1
                    continue 
                if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_610 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1152 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5627 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1152]
                                        mem[(32 * idx) + _1152 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7355 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5627 > mem[_7355]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1152]
                                        mem[(32 * idx) + _1152 + 32] = mem[_7355] - _5627
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5626 = mem[_1152]
                                mem[mem[64] + 32] = mem[_1152]
                                mem[mem[64] + 64 len 32 * _5626] = mem[_1152 + 32 len 32 * _5626]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5626) + 32], address(arg1)
                            else:
                                mem[_1152 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5630 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1152]
                                        mem[(32 * idx) + _1152 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7358 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5630 > mem[_7358]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1152]
                                        mem[(32 * idx) + _1152 + 32] = mem[_7358] - _5630
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5629 = mem[_1152]
                                mem[mem[64] + 32] = mem[_1152]
                                mem[mem[64] + 64 len 32 * _5629] = mem[_1152 + 32 len 32 * _5629]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5629) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1200 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5633 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1200]
                                        mem[(32 * idx) + _1200 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7361 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5633 > mem[_7361]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1200]
                                        mem[(32 * idx) + _1200 + 32] = mem[_7361] - _5633
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5632 = mem[_1200]
                                mem[mem[64] + 32] = mem[_1200]
                                mem[mem[64] + 64 len 32 * _5632] = mem[_1200 + 32 len 32 * _5632]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5632) + 32], address(arg1)
                            else:
                                mem[_1200 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5636 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1200]
                                        mem[(32 * idx) + _1200 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7364 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5636 > mem[_7364]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1200]
                                        mem[(32 * idx) + _1200 + 32] = mem[_7364] - _5636
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5635 = mem[_1200]
                                mem[mem[64] + 32] = mem[_1200]
                                mem[mem[64] + 64 len 32 * _5635] = mem[_1200 + 32 len 32 * _5635]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5635) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_611 len 64] = call.data[calldata.size len 64]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1153 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5639 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1153]
                                        mem[(32 * idx) + _1153 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7367 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5639 > mem[_7367]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1153]
                                        mem[(32 * idx) + _1153 + 32] = mem[_7367] - _5639
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5638 = mem[_1153]
                                mem[mem[64] + 32] = mem[_1153]
                                mem[mem[64] + 64 len 32 * _5638] = mem[_1153 + 32 len 32 * _5638]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5638) + 32], address(arg1)
                            else:
                                mem[_1153 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5642 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1153]
                                        mem[(32 * idx) + _1153 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7370 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5642 > mem[_7370]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1153]
                                        mem[(32 * idx) + _1153 + 32] = mem[_7370] - _5642
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5641 = mem[_1153]
                                mem[mem[64] + 32] = mem[_1153]
                                mem[mem[64] + 64 len 32 * _5641] = mem[_1153 + 32 len 32 * _5641]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5641) + 32], address(arg1)
                        else:
                            mem[mem[64] + 100] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].0x269b5581 with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 64], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1201 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5645 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1201]
                                        mem[(32 * idx) + _1201 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7373 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5645 > mem[_7373]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1201]
                                        mem[(32 * idx) + _1201 + 32] = mem[_7373] - _5645
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5644 = mem[_1201]
                                mem[mem[64] + 32] = mem[_1201]
                                mem[mem[64] + 64 len 32 * _5644] = mem[_1201 + 32 len 32 * _5644]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5644) + 32], address(arg1)
                            else:
                                mem[_1201 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5648 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1201]
                                        mem[(32 * idx) + _1201 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7376 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5648 > mem[_7376]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1201]
                                        mem[(32 * idx) + _1201 + 32] = mem[_7376] - _5648
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5647 = mem[_1201]
                                mem[mem[64] + 32] = mem[_1201]
                                mem[mem[64] + 64 len 32 * _5647] = mem[_1201 + 32 len 32 * _5647]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5647) + 32], address(arg1)
                else:
                    if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                        revert with 0, 'Missing implementation'
                    mem[0] = address(arg1)
                    if not sub_e676ea95[address(arg1)]:
                        _658 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_658 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1150 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5603 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1150]
                                        mem[(32 * idx) + _1150 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7331 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5603 > mem[_7331]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1150]
                                        mem[(32 * idx) + _1150 + 32] = mem[_7331] - _5603
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5602 = mem[_1150]
                                mem[mem[64] + 32] = mem[_1150]
                                mem[mem[64] + 64 len 32 * _5602] = mem[_1150 + 32 len 32 * _5602]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5602) + 32], address(arg1)
                            else:
                                mem[_1150 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5606 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1150]
                                        mem[(32 * idx) + _1150 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7334 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5606 > mem[_7334]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1150]
                                        mem[(32 * idx) + _1150 + 32] = mem[_7334] - _5606
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5605 = mem[_1150]
                                mem[mem[64] + 32] = mem[_1150]
                                mem[mem[64] + 64 len 32 * _5605] = mem[_1150 + 32 len 32 * _5605]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5605) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(address(arg1))
                            call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1198 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5609 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1198]
                                        mem[(32 * idx) + _1198 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7337 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5609 > mem[_7337]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1198]
                                        mem[(32 * idx) + _1198 + 32] = mem[_7337] - _5609
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5608 = mem[_1198]
                                mem[mem[64] + 32] = mem[_1198]
                                mem[mem[64] + 64 len 32 * _5608] = mem[_1198 + 32 len 32 * _5608]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5608) + 32], address(arg1)
                            else:
                                mem[_1198 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5612 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1198]
                                        mem[(32 * idx) + _1198 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7340 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5612 > mem[_7340]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1198]
                                        mem[(32 * idx) + _1198 + 32] = mem[_7340] - _5612
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5611 = mem[_1198]
                                mem[mem[64] + 32] = mem[_1198]
                                mem[mem[64] + 64 len 32 * _5611] = mem[_1198 + 32 len 32 * _5611]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5611) + 32], address(arg1)
                    else:
                        mem[0] = address(arg1)
                        _659 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_659 len 96] = call.data[calldata.size len 96]
                        mem[0] = address(arg1)
                        mem[32] = 6
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                        if not stor6[address(arg1)]:
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1151 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5615 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1151]
                                        mem[(32 * idx) + _1151 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7343 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5615 > mem[_7343]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1151]
                                        mem[(32 * idx) + _1151 + 32] = mem[_7343] - _5615
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5614 = mem[_1151]
                                mem[mem[64] + 32] = mem[_1151]
                                mem[mem[64] + 64 len 32 * _5614] = mem[_1151 + 32 len 32 * _5614]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5614) + 32], address(arg1)
                            else:
                                mem[_1151 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5618 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1151]
                                        mem[(32 * idx) + _1151 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7346 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5618 > mem[_7346]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1151]
                                        mem[(32 * idx) + _1151 + 32] = mem[_7346] - _5618
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5617 = mem[_1151]
                                mem[mem[64] + 32] = mem[_1151]
                                mem[mem[64] + 64 len 32 * _5617] = mem[_1151 + 32 len 32 * _5617]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5617) + 32], address(arg1)
                        else:
                            mem[mem[64] + 132] = 1
                            require ext_code.size(sub_e676ea95[address(arg1)])
                            call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                 gas gas_remaining wei
                                args arg2, call.data[calldata.size len 96], 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                            _1199 = mem[64]
                            mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                            mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                            if not uint256(sub_c42fa7f4[address(arg1)]):
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5621 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1199]
                                        mem[(32 * idx) + _1199 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7349 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5621 > mem[_7349]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1199]
                                        mem[(32 * idx) + _1199 + 32] = mem[_7349] - _5621
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5620 = mem[_1199]
                                mem[mem[64] + 32] = mem[_1199]
                                mem[mem[64] + 64 len 32 * _5620] = mem[_1199 + 32 len 32 * _5620]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5620) + 32], address(arg1)
                            else:
                                mem[_1199 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                idx = 0
                                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                    require idx < mem[96]
                                    _5624 = mem[(32 * idx) + 128]
                                    mem[32] = 4
                                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                                    mem[0] = sha3(address(arg1), 4)
                                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                        if mem[(32 * idx) + 128] > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1199]
                                        mem[(32 * idx) + _1199 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                    else:
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                        staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7352 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _5624 > mem[_7352]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require idx < mem[_1199]
                                        mem[(32 * idx) + _1199 + 32] = mem[_7352] - _5624
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 32
                                _5623 = mem[_1199]
                                mem[mem[64] + 32] = mem[_1199]
                                mem[mem[64] + 64 len 32 * _5623] = mem[_1199 + 32 len 32 * _5623]
                                emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5623) + 32], address(arg1)
    else:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
        if owner == msg.sender:
            mem[100] = arg2
            require ext_code.size(address(arg3))
            call address(arg3).withdraw(uint256 arg1) with:
                 gas gas_remaining wei
                args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if owner == msg.sender:
                mem[0] = address(arg1)
                mem[32] = 4
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                mem[96] = uint256(sub_c42fa7f4[address(arg1)])
                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                if not uint256(sub_c42fa7f4[address(arg1)]):
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _728 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_728]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_614 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1156 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5675 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1156]
                                            mem[(32 * idx) + _1156 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7403 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5675 > mem[_7403]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1156]
                                            mem[(32 * idx) + _1156 + 32] = mem[_7403] - _5675
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5674 = mem[_1156]
                                    mem[mem[64] + 32] = mem[_1156]
                                    mem[mem[64] + 64 len 32 * _5674] = mem[_1156 + 32 len 32 * _5674]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5674) + 32], address(arg1)
                                else:
                                    mem[_1156 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5678 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1156]
                                            mem[(32 * idx) + _1156 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7406 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5678 > mem[_7406]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1156]
                                            mem[(32 * idx) + _1156 + 32] = mem[_7406] - _5678
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5677 = mem[_1156]
                                    mem[mem[64] + 32] = mem[_1156]
                                    mem[mem[64] + 64 len 32 * _5677] = mem[_1156 + 32 len 32 * _5677]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5677) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1204 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5681 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1204]
                                            mem[(32 * idx) + _1204 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7409 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5681 > mem[_7409]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1204]
                                            mem[(32 * idx) + _1204 + 32] = mem[_7409] - _5681
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5680 = mem[_1204]
                                    mem[mem[64] + 32] = mem[_1204]
                                    mem[mem[64] + 64 len 32 * _5680] = mem[_1204 + 32 len 32 * _5680]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5680) + 32], address(arg1)
                                else:
                                    mem[_1204 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5684 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1204]
                                            mem[(32 * idx) + _1204 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7412 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5684 > mem[_7412]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1204]
                                            mem[(32 * idx) + _1204 + 32] = mem[_7412] - _5684
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5683 = mem[_1204]
                                    mem[mem[64] + 32] = mem[_1204]
                                    mem[mem[64] + 64 len 32 * _5683] = mem[_1204 + 32 len 32 * _5683]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5683) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _615 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_615 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1157 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5687 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1157]
                                            mem[(32 * idx) + _1157 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7415 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5687 > mem[_7415]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1157]
                                            mem[(32 * idx) + _1157 + 32] = mem[_7415] - _5687
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5686 = mem[_1157]
                                    mem[mem[64] + 32] = mem[_1157]
                                    mem[mem[64] + 64 len 32 * _5686] = mem[_1157 + 32 len 32 * _5686]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5686) + 32], address(arg1)
                                else:
                                    mem[_1157 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5690 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1157]
                                            mem[(32 * idx) + _1157 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7418 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5690 > mem[_7418]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1157]
                                            mem[(32 * idx) + _1157 + 32] = mem[_7418] - _5690
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5689 = mem[_1157]
                                    mem[mem[64] + 32] = mem[_1157]
                                    mem[mem[64] + 64 len 32 * _5689] = mem[_1157 + 32 len 32 * _5689]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5689) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1205 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5693 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1205]
                                            mem[(32 * idx) + _1205 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7421 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5693 > mem[_7421]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1205]
                                            mem[(32 * idx) + _1205 + 32] = mem[_7421] - _5693
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5692 = mem[_1205]
                                    mem[mem[64] + 32] = mem[_1205]
                                    mem[mem[64] + 64 len 32 * _5692] = mem[_1205 + 32 len 32 * _5692]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5692) + 32], address(arg1)
                                else:
                                    mem[_1205 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5696 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1205]
                                            mem[(32 * idx) + _1205 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7424 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5696 > mem[_7424]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1205]
                                            mem[(32 * idx) + _1205 + 32] = mem[_7424] - _5696
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5695 = mem[_1205]
                                    mem[mem[64] + 32] = mem[_1205]
                                    mem[mem[64] + 64 len 32 * _5695] = mem[_1205 + 32 len 32 * _5695]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5695) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _662 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_662 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1154 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5651 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1154]
                                            mem[(32 * idx) + _1154 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7379 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5651 > mem[_7379]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1154]
                                            mem[(32 * idx) + _1154 + 32] = mem[_7379] - _5651
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5650 = mem[_1154]
                                    mem[mem[64] + 32] = mem[_1154]
                                    mem[mem[64] + 64 len 32 * _5650] = mem[_1154 + 32 len 32 * _5650]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5650) + 32], address(arg1)
                                else:
                                    mem[_1154 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5654 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1154]
                                            mem[(32 * idx) + _1154 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7382 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5654 > mem[_7382]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1154]
                                            mem[(32 * idx) + _1154 + 32] = mem[_7382] - _5654
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5653 = mem[_1154]
                                    mem[mem[64] + 32] = mem[_1154]
                                    mem[mem[64] + 64 len 32 * _5653] = mem[_1154 + 32 len 32 * _5653]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5653) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1202 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5657 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1202]
                                            mem[(32 * idx) + _1202 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7385 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5657 > mem[_7385]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1202]
                                            mem[(32 * idx) + _1202 + 32] = mem[_7385] - _5657
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5656 = mem[_1202]
                                    mem[mem[64] + 32] = mem[_1202]
                                    mem[mem[64] + 64 len 32 * _5656] = mem[_1202 + 32 len 32 * _5656]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5656) + 32], address(arg1)
                                else:
                                    mem[_1202 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5660 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1202]
                                            mem[(32 * idx) + _1202 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7388 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5660 > mem[_7388]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1202]
                                            mem[(32 * idx) + _1202 + 32] = mem[_7388] - _5660
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5659 = mem[_1202]
                                    mem[mem[64] + 32] = mem[_1202]
                                    mem[mem[64] + 64 len 32 * _5659] = mem[_1202 + 32 len 32 * _5659]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5659) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _663 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_663 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1155 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5663 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1155]
                                            mem[(32 * idx) + _1155 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7391 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5663 > mem[_7391]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1155]
                                            mem[(32 * idx) + _1155 + 32] = mem[_7391] - _5663
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5662 = mem[_1155]
                                    mem[mem[64] + 32] = mem[_1155]
                                    mem[mem[64] + 64 len 32 * _5662] = mem[_1155 + 32 len 32 * _5662]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5662) + 32], address(arg1)
                                else:
                                    mem[_1155 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5666 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1155]
                                            mem[(32 * idx) + _1155 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7394 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5666 > mem[_7394]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1155]
                                            mem[(32 * idx) + _1155 + 32] = mem[_7394] - _5666
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5665 = mem[_1155]
                                    mem[mem[64] + 32] = mem[_1155]
                                    mem[mem[64] + 64 len 32 * _5665] = mem[_1155 + 32 len 32 * _5665]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5665) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1203 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5669 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1203]
                                            mem[(32 * idx) + _1203 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7397 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5669 > mem[_7397]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1203]
                                            mem[(32 * idx) + _1203 + 32] = mem[_7397] - _5669
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5668 = mem[_1203]
                                    mem[mem[64] + 32] = mem[_1203]
                                    mem[mem[64] + 64 len 32 * _5668] = mem[_1203 + 32 len 32 * _5668]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5668) + 32], address(arg1)
                                else:
                                    mem[_1203 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5672 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1203]
                                            mem[(32 * idx) + _1203 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7400 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5672 > mem[_7400]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1203]
                                            mem[(32 * idx) + _1203 + 32] = mem[_7400] - _5672
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5671 = mem[_1203]
                                    mem[mem[64] + 32] = mem[_1203]
                                    mem[mem[64] + 64 len 32 * _5671] = mem[_1203 + 32 len 32 * _5671]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5671) + 32], address(arg1)
                else:
                    mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _735 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_735]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _618 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_618 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1160 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5723 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1160]
                                            mem[(32 * idx) + _1160 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7451 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5723 > mem[_7451]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1160]
                                            mem[(32 * idx) + _1160 + 32] = mem[_7451] - _5723
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5722 = mem[_1160]
                                    mem[mem[64] + 32] = mem[_1160]
                                    mem[mem[64] + 64 len 32 * _5722] = mem[_1160 + 32 len 32 * _5722]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5722) + 32], address(arg1)
                                else:
                                    mem[_1160 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5726 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1160]
                                            mem[(32 * idx) + _1160 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7454 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5726 > mem[_7454]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1160]
                                            mem[(32 * idx) + _1160 + 32] = mem[_7454] - _5726
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5725 = mem[_1160]
                                    mem[mem[64] + 32] = mem[_1160]
                                    mem[mem[64] + 64 len 32 * _5725] = mem[_1160 + 32 len 32 * _5725]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5725) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1208 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5729 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1208]
                                            mem[(32 * idx) + _1208 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7457 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5729 > mem[_7457]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1208]
                                            mem[(32 * idx) + _1208 + 32] = mem[_7457] - _5729
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5728 = mem[_1208]
                                    mem[mem[64] + 32] = mem[_1208]
                                    mem[mem[64] + 64 len 32 * _5728] = mem[_1208 + 32 len 32 * _5728]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5728) + 32], address(arg1)
                                else:
                                    mem[_1208 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5732 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1208]
                                            mem[(32 * idx) + _1208 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7460 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5732 > mem[_7460]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1208]
                                            mem[(32 * idx) + _1208 + 32] = mem[_7460] - _5732
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5731 = mem[_1208]
                                    mem[mem[64] + 32] = mem[_1208]
                                    mem[mem[64] + 64 len 32 * _5731] = mem[_1208 + 32 len 32 * _5731]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5731) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_619 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1161 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5735 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1161]
                                            mem[(32 * idx) + _1161 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7463 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5735 > mem[_7463]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1161]
                                            mem[(32 * idx) + _1161 + 32] = mem[_7463] - _5735
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5734 = mem[_1161]
                                    mem[mem[64] + 32] = mem[_1161]
                                    mem[mem[64] + 64 len 32 * _5734] = mem[_1161 + 32 len 32 * _5734]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5734) + 32], address(arg1)
                                else:
                                    mem[_1161 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5738 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1161]
                                            mem[(32 * idx) + _1161 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7466 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5738 > mem[_7466]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1161]
                                            mem[(32 * idx) + _1161 + 32] = mem[_7466] - _5738
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5737 = mem[_1161]
                                    mem[mem[64] + 32] = mem[_1161]
                                    mem[mem[64] + 64 len 32 * _5737] = mem[_1161 + 32 len 32 * _5737]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5737) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1209 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5741 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1209]
                                            mem[(32 * idx) + _1209 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7469 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5741 > mem[_7469]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1209]
                                            mem[(32 * idx) + _1209 + 32] = mem[_7469] - _5741
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5740 = mem[_1209]
                                    mem[mem[64] + 32] = mem[_1209]
                                    mem[mem[64] + 64 len 32 * _5740] = mem[_1209 + 32 len 32 * _5740]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5740) + 32], address(arg1)
                                else:
                                    mem[_1209 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5744 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1209]
                                            mem[(32 * idx) + _1209 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7472 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5744 > mem[_7472]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1209]
                                            mem[(32 * idx) + _1209 + 32] = mem[_7472] - _5744
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5743 = mem[_1209]
                                    mem[mem[64] + 32] = mem[_1209]
                                    mem[mem[64] + 64 len 32 * _5743] = mem[_1209 + 32 len 32 * _5743]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5743) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _666 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_666 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1158 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5699 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1158]
                                            mem[(32 * idx) + _1158 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7427 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5699 > mem[_7427]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1158]
                                            mem[(32 * idx) + _1158 + 32] = mem[_7427] - _5699
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5698 = mem[_1158]
                                    mem[mem[64] + 32] = mem[_1158]
                                    mem[mem[64] + 64 len 32 * _5698] = mem[_1158 + 32 len 32 * _5698]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5698) + 32], address(arg1)
                                else:
                                    mem[_1158 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5702 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1158]
                                            mem[(32 * idx) + _1158 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7430 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5702 > mem[_7430]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1158]
                                            mem[(32 * idx) + _1158 + 32] = mem[_7430] - _5702
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5701 = mem[_1158]
                                    mem[mem[64] + 32] = mem[_1158]
                                    mem[mem[64] + 64 len 32 * _5701] = mem[_1158 + 32 len 32 * _5701]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5701) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1206 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5705 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1206]
                                            mem[(32 * idx) + _1206 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7433 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5705 > mem[_7433]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1206]
                                            mem[(32 * idx) + _1206 + 32] = mem[_7433] - _5705
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5704 = mem[_1206]
                                    mem[mem[64] + 32] = mem[_1206]
                                    mem[mem[64] + 64 len 32 * _5704] = mem[_1206 + 32 len 32 * _5704]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5704) + 32], address(arg1)
                                else:
                                    mem[_1206 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5708 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1206]
                                            mem[(32 * idx) + _1206 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7436 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5708 > mem[_7436]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1206]
                                            mem[(32 * idx) + _1206 + 32] = mem[_7436] - _5708
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5707 = mem[_1206]
                                    mem[mem[64] + 32] = mem[_1206]
                                    mem[mem[64] + 64 len 32 * _5707] = mem[_1206 + 32 len 32 * _5707]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5707) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _667 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_667 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1159 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5711 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1159]
                                            mem[(32 * idx) + _1159 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7439 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5711 > mem[_7439]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1159]
                                            mem[(32 * idx) + _1159 + 32] = mem[_7439] - _5711
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5710 = mem[_1159]
                                    mem[mem[64] + 32] = mem[_1159]
                                    mem[mem[64] + 64 len 32 * _5710] = mem[_1159 + 32 len 32 * _5710]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5710) + 32], address(arg1)
                                else:
                                    mem[_1159 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5714 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1159]
                                            mem[(32 * idx) + _1159 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7442 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5714 > mem[_7442]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1159]
                                            mem[(32 * idx) + _1159 + 32] = mem[_7442] - _5714
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5713 = mem[_1159]
                                    mem[mem[64] + 32] = mem[_1159]
                                    mem[mem[64] + 64 len 32 * _5713] = mem[_1159 + 32 len 32 * _5713]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5713) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1207 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5717 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1207]
                                            mem[(32 * idx) + _1207 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7445 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5717 > mem[_7445]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1207]
                                            mem[(32 * idx) + _1207 + 32] = mem[_7445] - _5717
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5716 = mem[_1207]
                                    mem[mem[64] + 32] = mem[_1207]
                                    mem[mem[64] + 64 len 32 * _5716] = mem[_1207 + 32 len 32 * _5716]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5716) + 32], address(arg1)
                                else:
                                    mem[_1207 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5720 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1207]
                                            mem[(32 * idx) + _1207 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7448 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5720 > mem[_7448]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1207]
                                            mem[(32 * idx) + _1207 + 32] = mem[_7448] - _5720
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5719 = mem[_1207]
                                    mem[mem[64] + 32] = mem[_1207]
                                    mem[mem[64] + 64 len 32 * _5719] = mem[_1207 + 32 len 32 * _5719]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5719) + 32], address(arg1)
            else:
                if not stor1[msg.sender]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
                mem[0] = address(arg1)
                mem[32] = 4
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                mem[96] = uint256(sub_c42fa7f4[address(arg1)])
                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                if not uint256(sub_c42fa7f4[address(arg1)]):
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _742 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_742]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _622 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_622 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1164 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5771 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1164]
                                            mem[(32 * idx) + _1164 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7499 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5771 > mem[_7499]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1164]
                                            mem[(32 * idx) + _1164 + 32] = mem[_7499] - _5771
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5770 = mem[_1164]
                                    mem[mem[64] + 32] = mem[_1164]
                                    mem[mem[64] + 64 len 32 * _5770] = mem[_1164 + 32 len 32 * _5770]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5770) + 32], address(arg1)
                                else:
                                    mem[_1164 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5774 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1164]
                                            mem[(32 * idx) + _1164 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7502 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5774 > mem[_7502]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1164]
                                            mem[(32 * idx) + _1164 + 32] = mem[_7502] - _5774
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5773 = mem[_1164]
                                    mem[mem[64] + 32] = mem[_1164]
                                    mem[mem[64] + 64 len 32 * _5773] = mem[_1164 + 32 len 32 * _5773]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5773) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1212 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5777 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1212]
                                            mem[(32 * idx) + _1212 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7505 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5777 > mem[_7505]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1212]
                                            mem[(32 * idx) + _1212 + 32] = mem[_7505] - _5777
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5776 = mem[_1212]
                                    mem[mem[64] + 32] = mem[_1212]
                                    mem[mem[64] + 64 len 32 * _5776] = mem[_1212 + 32 len 32 * _5776]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5776) + 32], address(arg1)
                                else:
                                    mem[_1212 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5780 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1212]
                                            mem[(32 * idx) + _1212 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7508 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5780 > mem[_7508]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1212]
                                            mem[(32 * idx) + _1212 + 32] = mem[_7508] - _5780
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5779 = mem[_1212]
                                    mem[mem[64] + 32] = mem[_1212]
                                    mem[mem[64] + 64 len 32 * _5779] = mem[_1212 + 32 len 32 * _5779]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5779) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _623 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_623 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1165 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5783 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1165]
                                            mem[(32 * idx) + _1165 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7511 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5783 > mem[_7511]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1165]
                                            mem[(32 * idx) + _1165 + 32] = mem[_7511] - _5783
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5782 = mem[_1165]
                                    mem[mem[64] + 32] = mem[_1165]
                                    mem[mem[64] + 64 len 32 * _5782] = mem[_1165 + 32 len 32 * _5782]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5782) + 32], address(arg1)
                                else:
                                    mem[_1165 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5786 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1165]
                                            mem[(32 * idx) + _1165 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7514 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5786 > mem[_7514]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1165]
                                            mem[(32 * idx) + _1165 + 32] = mem[_7514] - _5786
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5785 = mem[_1165]
                                    mem[mem[64] + 32] = mem[_1165]
                                    mem[mem[64] + 64 len 32 * _5785] = mem[_1165 + 32 len 32 * _5785]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5785) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1213 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5789 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1213]
                                            mem[(32 * idx) + _1213 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7517 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5789 > mem[_7517]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1213]
                                            mem[(32 * idx) + _1213 + 32] = mem[_7517] - _5789
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5788 = mem[_1213]
                                    mem[mem[64] + 32] = mem[_1213]
                                    mem[mem[64] + 64 len 32 * _5788] = mem[_1213 + 32 len 32 * _5788]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5788) + 32], address(arg1)
                                else:
                                    mem[_1213 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5792 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1213]
                                            mem[(32 * idx) + _1213 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7520 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5792 > mem[_7520]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1213]
                                            mem[(32 * idx) + _1213 + 32] = mem[_7520] - _5792
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5791 = mem[_1213]
                                    mem[mem[64] + 32] = mem[_1213]
                                    mem[mem[64] + 64 len 32 * _5791] = mem[_1213 + 32 len 32 * _5791]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5791) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _670 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_670 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1162 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5747 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1162]
                                            mem[(32 * idx) + _1162 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7475 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5747 > mem[_7475]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1162]
                                            mem[(32 * idx) + _1162 + 32] = mem[_7475] - _5747
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5746 = mem[_1162]
                                    mem[mem[64] + 32] = mem[_1162]
                                    mem[mem[64] + 64 len 32 * _5746] = mem[_1162 + 32 len 32 * _5746]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5746) + 32], address(arg1)
                                else:
                                    mem[_1162 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5750 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1162]
                                            mem[(32 * idx) + _1162 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7478 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5750 > mem[_7478]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1162]
                                            mem[(32 * idx) + _1162 + 32] = mem[_7478] - _5750
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5749 = mem[_1162]
                                    mem[mem[64] + 32] = mem[_1162]
                                    mem[mem[64] + 64 len 32 * _5749] = mem[_1162 + 32 len 32 * _5749]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5749) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1210 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5753 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1210]
                                            mem[(32 * idx) + _1210 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7481 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5753 > mem[_7481]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1210]
                                            mem[(32 * idx) + _1210 + 32] = mem[_7481] - _5753
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5752 = mem[_1210]
                                    mem[mem[64] + 32] = mem[_1210]
                                    mem[mem[64] + 64 len 32 * _5752] = mem[_1210 + 32 len 32 * _5752]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5752) + 32], address(arg1)
                                else:
                                    mem[_1210 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5756 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1210]
                                            mem[(32 * idx) + _1210 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7484 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5756 > mem[_7484]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1210]
                                            mem[(32 * idx) + _1210 + 32] = mem[_7484] - _5756
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5755 = mem[_1210]
                                    mem[mem[64] + 32] = mem[_1210]
                                    mem[mem[64] + 64 len 32 * _5755] = mem[_1210 + 32 len 32 * _5755]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5755) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _671 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_671 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1163 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5759 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1163]
                                            mem[(32 * idx) + _1163 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7487 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5759 > mem[_7487]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1163]
                                            mem[(32 * idx) + _1163 + 32] = mem[_7487] - _5759
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5758 = mem[_1163]
                                    mem[mem[64] + 32] = mem[_1163]
                                    mem[mem[64] + 64 len 32 * _5758] = mem[_1163 + 32 len 32 * _5758]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5758) + 32], address(arg1)
                                else:
                                    mem[_1163 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5762 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1163]
                                            mem[(32 * idx) + _1163 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7490 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5762 > mem[_7490]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1163]
                                            mem[(32 * idx) + _1163 + 32] = mem[_7490] - _5762
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5761 = mem[_1163]
                                    mem[mem[64] + 32] = mem[_1163]
                                    mem[mem[64] + 64 len 32 * _5761] = mem[_1163 + 32 len 32 * _5761]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5761) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1211 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5765 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1211]
                                            mem[(32 * idx) + _1211 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7493 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5765 > mem[_7493]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1211]
                                            mem[(32 * idx) + _1211 + 32] = mem[_7493] - _5765
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5764 = mem[_1211]
                                    mem[mem[64] + 32] = mem[_1211]
                                    mem[mem[64] + 64 len 32 * _5764] = mem[_1211 + 32 len 32 * _5764]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5764) + 32], address(arg1)
                                else:
                                    mem[_1211 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5768 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1211]
                                            mem[(32 * idx) + _1211 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7496 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5768 > mem[_7496]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1211]
                                            mem[(32 * idx) + _1211 + 32] = mem[_7496] - _5768
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5767 = mem[_1211]
                                    mem[mem[64] + 32] = mem[_1211]
                                    mem[mem[64] + 64 len 32 * _5767] = mem[_1211 + 32 len 32 * _5767]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5767) + 32], address(arg1)
                else:
                    mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _749 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_749]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _626 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_626 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1168 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5819 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1168]
                                            mem[(32 * idx) + _1168 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7547 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5819 > mem[_7547]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1168]
                                            mem[(32 * idx) + _1168 + 32] = mem[_7547] - _5819
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5818 = mem[_1168]
                                    mem[mem[64] + 32] = mem[_1168]
                                    mem[mem[64] + 64 len 32 * _5818] = mem[_1168 + 32 len 32 * _5818]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5818) + 32], address(arg1)
                                else:
                                    mem[_1168 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5822 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1168]
                                            mem[(32 * idx) + _1168 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7550 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5822 > mem[_7550]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1168]
                                            mem[(32 * idx) + _1168 + 32] = mem[_7550] - _5822
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5821 = mem[_1168]
                                    mem[mem[64] + 32] = mem[_1168]
                                    mem[mem[64] + 64 len 32 * _5821] = mem[_1168 + 32 len 32 * _5821]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5821) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1216 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5825 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1216]
                                            mem[(32 * idx) + _1216 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7553 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5825 > mem[_7553]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1216]
                                            mem[(32 * idx) + _1216 + 32] = mem[_7553] - _5825
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5824 = mem[_1216]
                                    mem[mem[64] + 32] = mem[_1216]
                                    mem[mem[64] + 64 len 32 * _5824] = mem[_1216 + 32 len 32 * _5824]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5824) + 32], address(arg1)
                                else:
                                    mem[_1216 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5828 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1216]
                                            mem[(32 * idx) + _1216 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7556 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5828 > mem[_7556]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1216]
                                            mem[(32 * idx) + _1216 + 32] = mem[_7556] - _5828
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5827 = mem[_1216]
                                    mem[mem[64] + 32] = mem[_1216]
                                    mem[mem[64] + 64 len 32 * _5827] = mem[_1216 + 32 len 32 * _5827]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5827) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_627 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1169 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5831 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1169]
                                            mem[(32 * idx) + _1169 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7559 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5831 > mem[_7559]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1169]
                                            mem[(32 * idx) + _1169 + 32] = mem[_7559] - _5831
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5830 = mem[_1169]
                                    mem[mem[64] + 32] = mem[_1169]
                                    mem[mem[64] + 64 len 32 * _5830] = mem[_1169 + 32 len 32 * _5830]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5830) + 32], address(arg1)
                                else:
                                    mem[_1169 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5834 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1169]
                                            mem[(32 * idx) + _1169 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7562 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5834 > mem[_7562]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1169]
                                            mem[(32 * idx) + _1169 + 32] = mem[_7562] - _5834
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5833 = mem[_1169]
                                    mem[mem[64] + 32] = mem[_1169]
                                    mem[mem[64] + 64 len 32 * _5833] = mem[_1169 + 32 len 32 * _5833]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5833) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1217 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5837 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1217]
                                            mem[(32 * idx) + _1217 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7565 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5837 > mem[_7565]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1217]
                                            mem[(32 * idx) + _1217 + 32] = mem[_7565] - _5837
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5836 = mem[_1217]
                                    mem[mem[64] + 32] = mem[_1217]
                                    mem[mem[64] + 64 len 32 * _5836] = mem[_1217 + 32 len 32 * _5836]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5836) + 32], address(arg1)
                                else:
                                    mem[_1217 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5840 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1217]
                                            mem[(32 * idx) + _1217 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7568 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5840 > mem[_7568]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1217]
                                            mem[(32 * idx) + _1217 + 32] = mem[_7568] - _5840
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5839 = mem[_1217]
                                    mem[mem[64] + 32] = mem[_1217]
                                    mem[mem[64] + 64 len 32 * _5839] = mem[_1217 + 32 len 32 * _5839]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5839) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _674 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_674 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1166 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5795 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1166]
                                            mem[(32 * idx) + _1166 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7523 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5795 > mem[_7523]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1166]
                                            mem[(32 * idx) + _1166 + 32] = mem[_7523] - _5795
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5794 = mem[_1166]
                                    mem[mem[64] + 32] = mem[_1166]
                                    mem[mem[64] + 64 len 32 * _5794] = mem[_1166 + 32 len 32 * _5794]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5794) + 32], address(arg1)
                                else:
                                    mem[_1166 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5798 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1166]
                                            mem[(32 * idx) + _1166 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7526 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5798 > mem[_7526]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1166]
                                            mem[(32 * idx) + _1166 + 32] = mem[_7526] - _5798
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5797 = mem[_1166]
                                    mem[mem[64] + 32] = mem[_1166]
                                    mem[mem[64] + 64 len 32 * _5797] = mem[_1166 + 32 len 32 * _5797]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5797) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1214 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5801 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1214]
                                            mem[(32 * idx) + _1214 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7529 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5801 > mem[_7529]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1214]
                                            mem[(32 * idx) + _1214 + 32] = mem[_7529] - _5801
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5800 = mem[_1214]
                                    mem[mem[64] + 32] = mem[_1214]
                                    mem[mem[64] + 64 len 32 * _5800] = mem[_1214 + 32 len 32 * _5800]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5800) + 32], address(arg1)
                                else:
                                    mem[_1214 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5804 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1214]
                                            mem[(32 * idx) + _1214 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7532 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5804 > mem[_7532]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1214]
                                            mem[(32 * idx) + _1214 + 32] = mem[_7532] - _5804
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5803 = mem[_1214]
                                    mem[mem[64] + 32] = mem[_1214]
                                    mem[mem[64] + 64 len 32 * _5803] = mem[_1214 + 32 len 32 * _5803]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5803) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _675 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_675 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1167 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5807 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1167]
                                            mem[(32 * idx) + _1167 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7535 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5807 > mem[_7535]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1167]
                                            mem[(32 * idx) + _1167 + 32] = mem[_7535] - _5807
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5806 = mem[_1167]
                                    mem[mem[64] + 32] = mem[_1167]
                                    mem[mem[64] + 64 len 32 * _5806] = mem[_1167 + 32 len 32 * _5806]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5806) + 32], address(arg1)
                                else:
                                    mem[_1167 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5810 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1167]
                                            mem[(32 * idx) + _1167 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7538 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5810 > mem[_7538]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1167]
                                            mem[(32 * idx) + _1167 + 32] = mem[_7538] - _5810
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5809 = mem[_1167]
                                    mem[mem[64] + 32] = mem[_1167]
                                    mem[mem[64] + 64 len 32 * _5809] = mem[_1167 + 32 len 32 * _5809]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5809) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1215 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5813 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1215]
                                            mem[(32 * idx) + _1215 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7541 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5813 > mem[_7541]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1215]
                                            mem[(32 * idx) + _1215 + 32] = mem[_7541] - _5813
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5812 = mem[_1215]
                                    mem[mem[64] + 32] = mem[_1215]
                                    mem[mem[64] + 64 len 32 * _5812] = mem[_1215 + 32 len 32 * _5812]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5812) + 32], address(arg1)
                                else:
                                    mem[_1215 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5816 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1215]
                                            mem[(32 * idx) + _1215 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7544 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5816 > mem[_7544]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1215]
                                            mem[(32 * idx) + _1215 + 32] = mem[_7544] - _5816
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5815 = mem[_1215]
                                    mem[mem[64] + 32] = mem[_1215]
                                    mem[mem[64] + 64 len 32 * _5815] = mem[_1215 + 32 len 32 * _5815]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5815) + 32], address(arg1)
        else:
            if not stor1[msg.sender]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
            mem[100] = arg2
            require ext_code.size(address(arg3))
            call address(arg3).withdraw(uint256 arg1) with:
                 gas gas_remaining wei
                args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if owner == msg.sender:
                mem[0] = address(arg1)
                mem[32] = 4
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                mem[96] = uint256(sub_c42fa7f4[address(arg1)])
                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                if not uint256(sub_c42fa7f4[address(arg1)]):
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _756 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_756]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_630 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1172 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5867 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1172]
                                            mem[(32 * idx) + _1172 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7595 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5867 > mem[_7595]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1172]
                                            mem[(32 * idx) + _1172 + 32] = mem[_7595] - _5867
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5866 = mem[_1172]
                                    mem[mem[64] + 32] = mem[_1172]
                                    mem[mem[64] + 64 len 32 * _5866] = mem[_1172 + 32 len 32 * _5866]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5866) + 32], address(arg1)
                                else:
                                    mem[_1172 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5870 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1172]
                                            mem[(32 * idx) + _1172 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7598 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5870 > mem[_7598]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1172]
                                            mem[(32 * idx) + _1172 + 32] = mem[_7598] - _5870
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5869 = mem[_1172]
                                    mem[mem[64] + 32] = mem[_1172]
                                    mem[mem[64] + 64 len 32 * _5869] = mem[_1172 + 32 len 32 * _5869]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5869) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1220 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5873 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1220]
                                            mem[(32 * idx) + _1220 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7601 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5873 > mem[_7601]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1220]
                                            mem[(32 * idx) + _1220 + 32] = mem[_7601] - _5873
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5872 = mem[_1220]
                                    mem[mem[64] + 32] = mem[_1220]
                                    mem[mem[64] + 64 len 32 * _5872] = mem[_1220 + 32 len 32 * _5872]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5872) + 32], address(arg1)
                                else:
                                    mem[_1220 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5876 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1220]
                                            mem[(32 * idx) + _1220 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7604 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5876 > mem[_7604]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1220]
                                            mem[(32 * idx) + _1220 + 32] = mem[_7604] - _5876
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5875 = mem[_1220]
                                    mem[mem[64] + 32] = mem[_1220]
                                    mem[mem[64] + 64 len 32 * _5875] = mem[_1220 + 32 len 32 * _5875]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5875) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _631 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_631 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1173 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5879 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1173]
                                            mem[(32 * idx) + _1173 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7607 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5879 > mem[_7607]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1173]
                                            mem[(32 * idx) + _1173 + 32] = mem[_7607] - _5879
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5878 = mem[_1173]
                                    mem[mem[64] + 32] = mem[_1173]
                                    mem[mem[64] + 64 len 32 * _5878] = mem[_1173 + 32 len 32 * _5878]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5878) + 32], address(arg1)
                                else:
                                    mem[_1173 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5882 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1173]
                                            mem[(32 * idx) + _1173 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7610 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5882 > mem[_7610]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1173]
                                            mem[(32 * idx) + _1173 + 32] = mem[_7610] - _5882
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5881 = mem[_1173]
                                    mem[mem[64] + 32] = mem[_1173]
                                    mem[mem[64] + 64 len 32 * _5881] = mem[_1173 + 32 len 32 * _5881]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5881) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1221 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5885 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1221]
                                            mem[(32 * idx) + _1221 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7613 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5885 > mem[_7613]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1221]
                                            mem[(32 * idx) + _1221 + 32] = mem[_7613] - _5885
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5884 = mem[_1221]
                                    mem[mem[64] + 32] = mem[_1221]
                                    mem[mem[64] + 64 len 32 * _5884] = mem[_1221 + 32 len 32 * _5884]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5884) + 32], address(arg1)
                                else:
                                    mem[_1221 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5888 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1221]
                                            mem[(32 * idx) + _1221 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7616 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5888 > mem[_7616]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1221]
                                            mem[(32 * idx) + _1221 + 32] = mem[_7616] - _5888
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5887 = mem[_1221]
                                    mem[mem[64] + 32] = mem[_1221]
                                    mem[mem[64] + 64 len 32 * _5887] = mem[_1221 + 32 len 32 * _5887]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5887) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _678 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_678 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1170 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5843 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1170]
                                            mem[(32 * idx) + _1170 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7571 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5843 > mem[_7571]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1170]
                                            mem[(32 * idx) + _1170 + 32] = mem[_7571] - _5843
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5842 = mem[_1170]
                                    mem[mem[64] + 32] = mem[_1170]
                                    mem[mem[64] + 64 len 32 * _5842] = mem[_1170 + 32 len 32 * _5842]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5842) + 32], address(arg1)
                                else:
                                    mem[_1170 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5846 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1170]
                                            mem[(32 * idx) + _1170 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7574 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5846 > mem[_7574]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1170]
                                            mem[(32 * idx) + _1170 + 32] = mem[_7574] - _5846
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5845 = mem[_1170]
                                    mem[mem[64] + 32] = mem[_1170]
                                    mem[mem[64] + 64 len 32 * _5845] = mem[_1170 + 32 len 32 * _5845]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5845) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1218 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5849 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1218]
                                            mem[(32 * idx) + _1218 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7577 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5849 > mem[_7577]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1218]
                                            mem[(32 * idx) + _1218 + 32] = mem[_7577] - _5849
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5848 = mem[_1218]
                                    mem[mem[64] + 32] = mem[_1218]
                                    mem[mem[64] + 64 len 32 * _5848] = mem[_1218 + 32 len 32 * _5848]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5848) + 32], address(arg1)
                                else:
                                    mem[_1218 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5852 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1218]
                                            mem[(32 * idx) + _1218 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7580 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5852 > mem[_7580]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1218]
                                            mem[(32 * idx) + _1218 + 32] = mem[_7580] - _5852
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5851 = mem[_1218]
                                    mem[mem[64] + 32] = mem[_1218]
                                    mem[mem[64] + 64 len 32 * _5851] = mem[_1218 + 32 len 32 * _5851]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5851) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _679 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_679 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1171 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5855 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1171]
                                            mem[(32 * idx) + _1171 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7583 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5855 > mem[_7583]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1171]
                                            mem[(32 * idx) + _1171 + 32] = mem[_7583] - _5855
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5854 = mem[_1171]
                                    mem[mem[64] + 32] = mem[_1171]
                                    mem[mem[64] + 64 len 32 * _5854] = mem[_1171 + 32 len 32 * _5854]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5854) + 32], address(arg1)
                                else:
                                    mem[_1171 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5858 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1171]
                                            mem[(32 * idx) + _1171 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7586 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5858 > mem[_7586]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1171]
                                            mem[(32 * idx) + _1171 + 32] = mem[_7586] - _5858
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5857 = mem[_1171]
                                    mem[mem[64] + 32] = mem[_1171]
                                    mem[mem[64] + 64 len 32 * _5857] = mem[_1171 + 32 len 32 * _5857]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5857) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1219 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5861 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1219]
                                            mem[(32 * idx) + _1219 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7589 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5861 > mem[_7589]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1219]
                                            mem[(32 * idx) + _1219 + 32] = mem[_7589] - _5861
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5860 = mem[_1219]
                                    mem[mem[64] + 32] = mem[_1219]
                                    mem[mem[64] + 64 len 32 * _5860] = mem[_1219 + 32 len 32 * _5860]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5860) + 32], address(arg1)
                                else:
                                    mem[_1219 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5864 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1219]
                                            mem[(32 * idx) + _1219 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7592 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5864 > mem[_7592]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1219]
                                            mem[(32 * idx) + _1219 + 32] = mem[_7592] - _5864
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5863 = mem[_1219]
                                    mem[mem[64] + 32] = mem[_1219]
                                    mem[mem[64] + 64 len 32 * _5863] = mem[_1219 + 32 len 32 * _5863]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5863) + 32], address(arg1)
                else:
                    mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _763 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_763]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_634 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1176 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5915 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1176]
                                            mem[(32 * idx) + _1176 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7643 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5915 > mem[_7643]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1176]
                                            mem[(32 * idx) + _1176 + 32] = mem[_7643] - _5915
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5914 = mem[_1176]
                                    mem[mem[64] + 32] = mem[_1176]
                                    mem[mem[64] + 64 len 32 * _5914] = mem[_1176 + 32 len 32 * _5914]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5914) + 32], address(arg1)
                                else:
                                    mem[_1176 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5918 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1176]
                                            mem[(32 * idx) + _1176 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7646 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5918 > mem[_7646]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1176]
                                            mem[(32 * idx) + _1176 + 32] = mem[_7646] - _5918
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5917 = mem[_1176]
                                    mem[mem[64] + 32] = mem[_1176]
                                    mem[mem[64] + 64 len 32 * _5917] = mem[_1176 + 32 len 32 * _5917]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5917) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1224 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5921 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1224]
                                            mem[(32 * idx) + _1224 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7649 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5921 > mem[_7649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1224]
                                            mem[(32 * idx) + _1224 + 32] = mem[_7649] - _5921
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5920 = mem[_1224]
                                    mem[mem[64] + 32] = mem[_1224]
                                    mem[mem[64] + 64 len 32 * _5920] = mem[_1224 + 32 len 32 * _5920]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5920) + 32], address(arg1)
                                else:
                                    mem[_1224 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5924 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1224]
                                            mem[(32 * idx) + _1224 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7652 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5924 > mem[_7652]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1224]
                                            mem[(32 * idx) + _1224 + 32] = mem[_7652] - _5924
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5923 = mem[_1224]
                                    mem[mem[64] + 32] = mem[_1224]
                                    mem[mem[64] + 64 len 32 * _5923] = mem[_1224 + 32 len 32 * _5923]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5923) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_635 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1177 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5927 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1177]
                                            mem[(32 * idx) + _1177 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7655 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5927 > mem[_7655]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1177]
                                            mem[(32 * idx) + _1177 + 32] = mem[_7655] - _5927
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5926 = mem[_1177]
                                    mem[mem[64] + 32] = mem[_1177]
                                    mem[mem[64] + 64 len 32 * _5926] = mem[_1177 + 32 len 32 * _5926]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5926) + 32], address(arg1)
                                else:
                                    mem[_1177 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5930 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1177]
                                            mem[(32 * idx) + _1177 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7658 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5930 > mem[_7658]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1177]
                                            mem[(32 * idx) + _1177 + 32] = mem[_7658] - _5930
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5929 = mem[_1177]
                                    mem[mem[64] + 32] = mem[_1177]
                                    mem[mem[64] + 64 len 32 * _5929] = mem[_1177 + 32 len 32 * _5929]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5929) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1225 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5933 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1225]
                                            mem[(32 * idx) + _1225 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7661 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5933 > mem[_7661]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1225]
                                            mem[(32 * idx) + _1225 + 32] = mem[_7661] - _5933
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5932 = mem[_1225]
                                    mem[mem[64] + 32] = mem[_1225]
                                    mem[mem[64] + 64 len 32 * _5932] = mem[_1225 + 32 len 32 * _5932]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5932) + 32], address(arg1)
                                else:
                                    mem[_1225 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5936 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1225]
                                            mem[(32 * idx) + _1225 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7664 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5936 > mem[_7664]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1225]
                                            mem[(32 * idx) + _1225 + 32] = mem[_7664] - _5936
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5935 = mem[_1225]
                                    mem[mem[64] + 32] = mem[_1225]
                                    mem[mem[64] + 64 len 32 * _5935] = mem[_1225 + 32 len 32 * _5935]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5935) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _682 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_682 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1174 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5891 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1174]
                                            mem[(32 * idx) + _1174 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7619 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5891 > mem[_7619]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1174]
                                            mem[(32 * idx) + _1174 + 32] = mem[_7619] - _5891
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5890 = mem[_1174]
                                    mem[mem[64] + 32] = mem[_1174]
                                    mem[mem[64] + 64 len 32 * _5890] = mem[_1174 + 32 len 32 * _5890]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5890) + 32], address(arg1)
                                else:
                                    mem[_1174 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5894 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1174]
                                            mem[(32 * idx) + _1174 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7622 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5894 > mem[_7622]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1174]
                                            mem[(32 * idx) + _1174 + 32] = mem[_7622] - _5894
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5893 = mem[_1174]
                                    mem[mem[64] + 32] = mem[_1174]
                                    mem[mem[64] + 64 len 32 * _5893] = mem[_1174 + 32 len 32 * _5893]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5893) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1222 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5897 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1222]
                                            mem[(32 * idx) + _1222 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7625 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5897 > mem[_7625]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1222]
                                            mem[(32 * idx) + _1222 + 32] = mem[_7625] - _5897
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5896 = mem[_1222]
                                    mem[mem[64] + 32] = mem[_1222]
                                    mem[mem[64] + 64 len 32 * _5896] = mem[_1222 + 32 len 32 * _5896]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5896) + 32], address(arg1)
                                else:
                                    mem[_1222 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5900 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1222]
                                            mem[(32 * idx) + _1222 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7628 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5900 > mem[_7628]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1222]
                                            mem[(32 * idx) + _1222 + 32] = mem[_7628] - _5900
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5899 = mem[_1222]
                                    mem[mem[64] + 32] = mem[_1222]
                                    mem[mem[64] + 64 len 32 * _5899] = mem[_1222 + 32 len 32 * _5899]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5899) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _683 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_683 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1175 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5903 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1175]
                                            mem[(32 * idx) + _1175 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7631 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5903 > mem[_7631]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1175]
                                            mem[(32 * idx) + _1175 + 32] = mem[_7631] - _5903
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5902 = mem[_1175]
                                    mem[mem[64] + 32] = mem[_1175]
                                    mem[mem[64] + 64 len 32 * _5902] = mem[_1175 + 32 len 32 * _5902]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5902) + 32], address(arg1)
                                else:
                                    mem[_1175 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5906 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1175]
                                            mem[(32 * idx) + _1175 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7634 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5906 > mem[_7634]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1175]
                                            mem[(32 * idx) + _1175 + 32] = mem[_7634] - _5906
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5905 = mem[_1175]
                                    mem[mem[64] + 32] = mem[_1175]
                                    mem[mem[64] + 64 len 32 * _5905] = mem[_1175 + 32 len 32 * _5905]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5905) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1223 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5909 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1223]
                                            mem[(32 * idx) + _1223 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7637 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5909 > mem[_7637]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1223]
                                            mem[(32 * idx) + _1223 + 32] = mem[_7637] - _5909
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5908 = mem[_1223]
                                    mem[mem[64] + 32] = mem[_1223]
                                    mem[mem[64] + 64 len 32 * _5908] = mem[_1223 + 32 len 32 * _5908]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5908) + 32], address(arg1)
                                else:
                                    mem[_1223 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5912 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1223]
                                            mem[(32 * idx) + _1223 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7640 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5912 > mem[_7640]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1223]
                                            mem[(32 * idx) + _1223 + 32] = mem[_7640] - _5912
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5911 = mem[_1223]
                                    mem[mem[64] + 32] = mem[_1223]
                                    mem[mem[64] + 64 len 32 * _5911] = mem[_1223 + 32 len 32 * _5911]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5911) + 32], address(arg1)
            else:
                if not stor1[msg.sender]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
                mem[0] = address(arg1)
                mem[32] = 4
                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                mem[96] = uint256(sub_c42fa7f4[address(arg1)])
                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                if not uint256(sub_c42fa7f4[address(arg1)]):
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _770 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_770]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_638 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1180 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5963 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1180]
                                            mem[(32 * idx) + _1180 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7691 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5963 > mem[_7691]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1180]
                                            mem[(32 * idx) + _1180 + 32] = mem[_7691] - _5963
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5962 = mem[_1180]
                                    mem[mem[64] + 32] = mem[_1180]
                                    mem[mem[64] + 64 len 32 * _5962] = mem[_1180 + 32 len 32 * _5962]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5962) + 32], address(arg1)
                                else:
                                    mem[_1180 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5966 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1180]
                                            mem[(32 * idx) + _1180 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7694 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5966 > mem[_7694]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1180]
                                            mem[(32 * idx) + _1180 + 32] = mem[_7694] - _5966
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5965 = mem[_1180]
                                    mem[mem[64] + 32] = mem[_1180]
                                    mem[mem[64] + 64 len 32 * _5965] = mem[_1180 + 32 len 32 * _5965]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5965) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1228 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5969 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1228]
                                            mem[(32 * idx) + _1228 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7697 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5969 > mem[_7697]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1228]
                                            mem[(32 * idx) + _1228 + 32] = mem[_7697] - _5969
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5968 = mem[_1228]
                                    mem[mem[64] + 32] = mem[_1228]
                                    mem[mem[64] + 64 len 32 * _5968] = mem[_1228 + 32 len 32 * _5968]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5968) + 32], address(arg1)
                                else:
                                    mem[_1228 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5972 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1228]
                                            mem[(32 * idx) + _1228 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7700 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5972 > mem[_7700]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1228]
                                            mem[(32 * idx) + _1228 + 32] = mem[_7700] - _5972
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5971 = mem[_1228]
                                    mem[mem[64] + 32] = mem[_1228]
                                    mem[mem[64] + 64 len 32 * _5971] = mem[_1228 + 32 len 32 * _5971]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5971) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_639 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1181 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5975 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1181]
                                            mem[(32 * idx) + _1181 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7703 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5975 > mem[_7703]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1181]
                                            mem[(32 * idx) + _1181 + 32] = mem[_7703] - _5975
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5974 = mem[_1181]
                                    mem[mem[64] + 32] = mem[_1181]
                                    mem[mem[64] + 64 len 32 * _5974] = mem[_1181 + 32 len 32 * _5974]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5974) + 32], address(arg1)
                                else:
                                    mem[_1181 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5978 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1181]
                                            mem[(32 * idx) + _1181 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7706 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5978 > mem[_7706]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1181]
                                            mem[(32 * idx) + _1181 + 32] = mem[_7706] - _5978
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5977 = mem[_1181]
                                    mem[mem[64] + 32] = mem[_1181]
                                    mem[mem[64] + 64 len 32 * _5977] = mem[_1181 + 32 len 32 * _5977]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5977) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1229 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5981 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1229]
                                            mem[(32 * idx) + _1229 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7709 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5981 > mem[_7709]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1229]
                                            mem[(32 * idx) + _1229 + 32] = mem[_7709] - _5981
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5980 = mem[_1229]
                                    mem[mem[64] + 32] = mem[_1229]
                                    mem[mem[64] + 64 len 32 * _5980] = mem[_1229 + 32 len 32 * _5980]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5980) + 32], address(arg1)
                                else:
                                    mem[_1229 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5984 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1229]
                                            mem[(32 * idx) + _1229 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7712 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5984 > mem[_7712]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1229]
                                            mem[(32 * idx) + _1229 + 32] = mem[_7712] - _5984
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5983 = mem[_1229]
                                    mem[mem[64] + 32] = mem[_1229]
                                    mem[mem[64] + 64 len 32 * _5983] = mem[_1229 + 32 len 32 * _5983]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5983) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _686 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_686 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1178 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5939 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1178]
                                            mem[(32 * idx) + _1178 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7667 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5939 > mem[_7667]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1178]
                                            mem[(32 * idx) + _1178 + 32] = mem[_7667] - _5939
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5938 = mem[_1178]
                                    mem[mem[64] + 32] = mem[_1178]
                                    mem[mem[64] + 64 len 32 * _5938] = mem[_1178 + 32 len 32 * _5938]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5938) + 32], address(arg1)
                                else:
                                    mem[_1178 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5942 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1178]
                                            mem[(32 * idx) + _1178 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7670 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5942 > mem[_7670]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1178]
                                            mem[(32 * idx) + _1178 + 32] = mem[_7670] - _5942
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5941 = mem[_1178]
                                    mem[mem[64] + 32] = mem[_1178]
                                    mem[mem[64] + 64 len 32 * _5941] = mem[_1178 + 32 len 32 * _5941]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5941) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1226 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5945 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1226]
                                            mem[(32 * idx) + _1226 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7673 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5945 > mem[_7673]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1226]
                                            mem[(32 * idx) + _1226 + 32] = mem[_7673] - _5945
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5944 = mem[_1226]
                                    mem[mem[64] + 32] = mem[_1226]
                                    mem[mem[64] + 64 len 32 * _5944] = mem[_1226 + 32 len 32 * _5944]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5944) + 32], address(arg1)
                                else:
                                    mem[_1226 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5948 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1226]
                                            mem[(32 * idx) + _1226 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7676 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5948 > mem[_7676]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1226]
                                            mem[(32 * idx) + _1226 + 32] = mem[_7676] - _5948
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5947 = mem[_1226]
                                    mem[mem[64] + 32] = mem[_1226]
                                    mem[mem[64] + 64 len 32 * _5947] = mem[_1226 + 32 len 32 * _5947]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5947) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _687 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_687 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1179 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5951 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1179]
                                            mem[(32 * idx) + _1179 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7679 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5951 > mem[_7679]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1179]
                                            mem[(32 * idx) + _1179 + 32] = mem[_7679] - _5951
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5950 = mem[_1179]
                                    mem[mem[64] + 32] = mem[_1179]
                                    mem[mem[64] + 64 len 32 * _5950] = mem[_1179 + 32 len 32 * _5950]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5950) + 32], address(arg1)
                                else:
                                    mem[_1179 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5954 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1179]
                                            mem[(32 * idx) + _1179 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7682 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5954 > mem[_7682]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1179]
                                            mem[(32 * idx) + _1179 + 32] = mem[_7682] - _5954
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5953 = mem[_1179]
                                    mem[mem[64] + 32] = mem[_1179]
                                    mem[mem[64] + 64 len 32 * _5953] = mem[_1179 + 32 len 32 * _5953]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5953) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1227 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5957 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1227]
                                            mem[(32 * idx) + _1227 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7685 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5957 > mem[_7685]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1227]
                                            mem[(32 * idx) + _1227 + 32] = mem[_7685] - _5957
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5956 = mem[_1227]
                                    mem[mem[64] + 32] = mem[_1227]
                                    mem[mem[64] + 64 len 32 * _5956] = mem[_1227 + 32 len 32 * _5956]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5956) + 32], address(arg1)
                                else:
                                    mem[_1227 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5960 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1227]
                                            mem[(32 * idx) + _1227 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7688 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5960 > mem[_7688]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1227]
                                            mem[(32 * idx) + _1227 + 32] = mem[_7688] - _5960
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5959 = mem[_1227]
                                    mem[mem[64] + 32] = mem[_1227]
                                    mem[mem[64] + 64 len 32 * _5959] = mem[_1227 + 32 len 32 * _5959]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5959) + 32], address(arg1)
                else:
                    mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                    idx = 0
                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                        mem[32] = 4
                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                        mem[0] = sha3(address(arg1), 4)
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = eth.balance(this.address)
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _777 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require idx < mem[96]
                            mem[(32 * idx) + 128] = mem[_777]
                        idx = idx + 1
                        continue 
                    if 2 == uint256(sub_c42fa7f4[address(arg1)]):
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_642 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1184 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6011 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1184]
                                            mem[(32 * idx) + _1184 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7739 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6011 > mem[_7739]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1184]
                                            mem[(32 * idx) + _1184 + 32] = mem[_7739] - _6011
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6010 = mem[_1184]
                                    mem[mem[64] + 32] = mem[_1184]
                                    mem[mem[64] + 64 len 32 * _6010] = mem[_1184 + 32 len 32 * _6010]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6010) + 32], address(arg1)
                                else:
                                    mem[_1184 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6014 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1184]
                                            mem[(32 * idx) + _1184 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7742 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6014 > mem[_7742]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1184]
                                            mem[(32 * idx) + _1184 + 32] = mem[_7742] - _6014
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6013 = mem[_1184]
                                    mem[mem[64] + 32] = mem[_1184]
                                    mem[mem[64] + 64 len 32 * _6013] = mem[_1184 + 32 len 32 * _6013]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6013) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1232 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6017 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1232]
                                            mem[(32 * idx) + _1232 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6017 > mem[_7745]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1232]
                                            mem[(32 * idx) + _1232 + 32] = mem[_7745] - _6017
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6016 = mem[_1232]
                                    mem[mem[64] + 32] = mem[_1232]
                                    mem[mem[64] + 64 len 32 * _6016] = mem[_1232 + 32 len 32 * _6016]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6016) + 32], address(arg1)
                                else:
                                    mem[_1232 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6020 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1232]
                                            mem[(32 * idx) + _1232 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7748 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6020 > mem[_7748]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1232]
                                            mem[(32 * idx) + _1232 + 32] = mem[_7748] - _6020
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6019 = mem[_1232]
                                    mem[mem[64] + 32] = mem[_1232]
                                    mem[mem[64] + 64 len 32 * _6019] = mem[_1232 + 32 len 32 * _6019]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6019) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _643 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_643 len 64] = call.data[calldata.size len 64]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 64] = call.data[calldata.size len 64]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[2] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1185 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6023 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1185]
                                            mem[(32 * idx) + _1185 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7751 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6023 > mem[_7751]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1185]
                                            mem[(32 * idx) + _1185 + 32] = mem[_7751] - _6023
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6022 = mem[_1185]
                                    mem[mem[64] + 32] = mem[_1185]
                                    mem[mem[64] + 64 len 32 * _6022] = mem[_1185 + 32 len 32 * _6022]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6022) + 32], address(arg1)
                                else:
                                    mem[_1185 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6026 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1185]
                                            mem[(32 * idx) + _1185 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7754 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6026 > mem[_7754]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1185]
                                            mem[(32 * idx) + _1185 + 32] = mem[_7754] - _6026
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6025 = mem[_1185]
                                    mem[mem[64] + 32] = mem[_1185]
                                    mem[mem[64] + 64 len 32 * _6025] = mem[_1185 + 32 len 32 * _6025]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6025) + 32], address(arg1)
                            else:
                                mem[mem[64] + 100] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].0x269b5581 with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 64], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1233 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6029 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1233]
                                            mem[(32 * idx) + _1233 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7757 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6029 > mem[_7757]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1233]
                                            mem[(32 * idx) + _1233 + 32] = mem[_7757] - _6029
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6028 = mem[_1233]
                                    mem[mem[64] + 32] = mem[_1233]
                                    mem[mem[64] + 64 len 32 * _6028] = mem[_1233 + 32 len 32 * _6028]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6028) + 32], address(arg1)
                                else:
                                    mem[_1233 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6032 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1233]
                                            mem[(32 * idx) + _1233 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7760 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6032 > mem[_7760]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1233]
                                            mem[(32 * idx) + _1233 + 32] = mem[_7760] - _6032
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6031 = mem[_1233]
                                    mem[mem[64] + 32] = mem[_1233]
                                    mem[mem[64] + 64 len 32 * _6031] = mem[_1233 + 32 len 32 * _6031]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6031) + 32], address(arg1)
                    else:
                        if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                            revert with 0, 'Missing implementation'
                        mem[0] = address(arg1)
                        if not sub_e676ea95[address(arg1)]:
                            _690 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_690 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1182 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5987 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1182]
                                            mem[(32 * idx) + _1182 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7715 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5987 > mem[_7715]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1182]
                                            mem[(32 * idx) + _1182 + 32] = mem[_7715] - _5987
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5986 = mem[_1182]
                                    mem[mem[64] + 32] = mem[_1182]
                                    mem[mem[64] + 64 len 32 * _5986] = mem[_1182 + 32 len 32 * _5986]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5986) + 32], address(arg1)
                                else:
                                    mem[_1182 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5990 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1182]
                                            mem[(32 * idx) + _1182 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7718 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5990 > mem[_7718]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1182]
                                            mem[(32 * idx) + _1182 + 32] = mem[_7718] - _5990
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5989 = mem[_1182]
                                    mem[mem[64] + 32] = mem[_1182]
                                    mem[mem[64] + 64 len 32 * _5989] = mem[_1182 + 32 len 32 * _5989]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5989) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(address(arg1))
                                call address(arg1).remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1230 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5993 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1230]
                                            mem[(32 * idx) + _1230 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7721 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5993 > mem[_7721]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1230]
                                            mem[(32 * idx) + _1230 + 32] = mem[_7721] - _5993
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5992 = mem[_1230]
                                    mem[mem[64] + 32] = mem[_1230]
                                    mem[mem[64] + 64 len 32 * _5992] = mem[_1230 + 32 len 32 * _5992]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5992) + 32], address(arg1)
                                else:
                                    mem[_1230 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5996 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1230]
                                            mem[(32 * idx) + _1230 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7724 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5996 > mem[_7724]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1230]
                                            mem[(32 * idx) + _1230 + 32] = mem[_7724] - _5996
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5995 = mem[_1230]
                                    mem[mem[64] + 32] = mem[_1230]
                                    mem[mem[64] + 64 len 32 * _5995] = mem[_1230 + 32 len 32 * _5995]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5995) + 32], address(arg1)
                        else:
                            mem[0] = address(arg1)
                            _691 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_691 len 96] = call.data[calldata.size len 96]
                            mem[0] = address(arg1)
                            mem[32] = 6
                            mem[mem[64] + 4] = arg2
                            mem[mem[64] + 36 len 96] = call.data[calldata.size len 96]
                            if not stor6[address(arg1)]:
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1183 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _5999 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1183]
                                            mem[(32 * idx) + _1183 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7727 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _5999 > mem[_7727]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1183]
                                            mem[(32 * idx) + _1183 + 32] = mem[_7727] - _5999
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _5998 = mem[_1183]
                                    mem[mem[64] + 32] = mem[_1183]
                                    mem[mem[64] + 64 len 32 * _5998] = mem[_1183 + 32 len 32 * _5998]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _5998) + 32], address(arg1)
                                else:
                                    mem[_1183 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6002 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1183]
                                            mem[(32 * idx) + _1183 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7730 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6002 > mem[_7730]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1183]
                                            mem[(32 * idx) + _1183 + 32] = mem[_7730] - _6002
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6001 = mem[_1183]
                                    mem[mem[64] + 32] = mem[_1183]
                                    mem[mem[64] + 64 len 32 * _6001] = mem[_1183 + 32 len 32 * _6001]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6001) + 32], address(arg1)
                            else:
                                mem[mem[64] + 132] = 1
                                require ext_code.size(sub_e676ea95[address(arg1)])
                                call sub_e676ea95[address(arg1)].remove_liquidity(uint256 arg1, uint256[3] arg2, bool arg3) with:
                                     gas gas_remaining wei
                                    args arg2, call.data[calldata.size len 96], 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
                                _1231 = mem[64]
                                mem[mem[64]] = uint256(sub_c42fa7f4[address(arg1)])
                                mem[64] = mem[64] + (32 * uint256(sub_c42fa7f4[address(arg1)])) + 32
                                if not uint256(sub_c42fa7f4[address(arg1)]):
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6005 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1231]
                                            mem[(32 * idx) + _1231 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7733 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6005 > mem[_7733]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1231]
                                            mem[(32 * idx) + _1231 + 32] = mem[_7733] - _6005
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6004 = mem[_1231]
                                    mem[mem[64] + 32] = mem[_1231]
                                    mem[mem[64] + 64 len 32 * _6004] = mem[_1231 + 32 len 32 * _6004]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6004) + 32], address(arg1)
                                else:
                                    mem[_1231 + 32 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                                    idx = 0
                                    while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                        require idx < mem[96]
                                        _6008 = mem[(32 * idx) + 128]
                                        mem[32] = 4
                                        require idx < uint256(sub_c42fa7f4[address(arg1)])
                                        mem[0] = sha3(address(arg1), 4)
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(sub_c42fa7f4[address(arg1)][idx]):
                                            if mem[(32 * idx) + 128] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1231]
                                            mem[(32 * idx) + _1231 + 32] = eth.balance(this.address) - mem[(32 * idx) + 128]
                                        else:
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(address(sub_c42fa7f4[address(arg1)][idx]))
                                            staticcall address(sub_c42fa7f4[address(arg1)][idx]).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7736 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _6008 > mem[_7736]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require idx < mem[_1231]
                                            mem[(32 * idx) + _1231 + 32] = mem[_7736] - _6008
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 32
                                    _6007 = mem[_1231]
                                    mem[mem[64] + 32] = mem[_1231]
                                    mem[mem[64] + 64 len 32 * _6007] = mem[_1231 + 32 len 32 * _6007]
                                    emit 0xd2602de0: 32, mem[mem[64] + 32 len (32 * _6007) + 32], address(arg1)
    return 0
}

function addLiquidity(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if owner == msg.sender:
        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
        mem[96] = uint256(sub_c42fa7f4[address(arg1)])
        mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
            if not uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9076 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9076]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9076] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9078 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9078]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9078] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9080 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9080]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9080] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9082 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9082]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9082] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9068 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9068]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9068] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9070 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9070]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9070] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9072 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9072]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9072] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9074 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9074]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9074] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9060 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9060]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9060] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9062 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9062]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9062] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9064 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9064]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9064] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9066 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9066]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9066] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9052 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9052]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9052] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9054 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9054]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9054] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9056 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9056]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9056] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9058 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9058]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9058] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9108 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9108]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9108] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9110 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9110]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9110] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9112 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9112]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9112] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9114 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9114]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9114] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9100 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9100]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9100] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9102 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9102]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9102] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9104 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9104]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9104] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9106 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9106]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9106] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9092 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9092]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9092] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9094 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9094]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9094] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9096 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9096]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9096] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9098 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9098]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9098] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9084 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9084]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9084] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9086 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9086]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9086] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9088 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9088]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9088] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9090 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9090]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9090] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
            else:
                mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9140 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9140]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9140] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9142 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9142]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9142] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9144 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9144]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9144] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9146 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9146]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9146] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9132 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9132]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9132] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9134 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9134]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9134] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9136 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9136]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9136] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9138 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9138]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9138] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9124 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9124]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9124] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9126 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9126]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9126] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9128 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9128]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9128] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9130 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9130]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9130] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9116 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9116]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9116] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9118 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9118]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9118] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9120 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9120]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9120] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9122 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9122]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9122] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9172 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9172]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9172] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9174 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9174]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9174] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9176 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9176]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9176] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9178 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9178]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9178] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9164 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9164]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9164] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9166 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9166]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9166] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9168 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9168]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9168] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9170 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9170]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9170] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9156 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9156]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9156] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9158 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9158]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9158] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9160 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9160]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9160] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9162 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9162]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9162] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9148 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9148]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9148] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9150 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9150]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9150] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9152 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9152]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9152] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9154 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9154]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9154] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
        else:
            if not uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9204 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9204]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9204] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9206 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9206]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9206] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9208 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9208]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9208] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9210 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9210]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9210] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9196 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9196]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9196] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9198 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9198]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9198] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9200 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9200]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9200] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9202 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9202]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9202] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9188 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9188]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9188] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9190 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9190]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9190] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9192 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9192]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9192] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9194 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9194]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9194] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9180 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9180]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9180] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9182 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9182]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9182] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9184 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9184]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9184] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9186 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9186]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9186] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9236 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9236]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9236] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9238 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9238]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9238] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9240 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9240]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9240] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9242 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9242]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9242] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9228 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9228]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9228] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9230 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9230]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9230] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9232 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9232]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9232] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9234 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9234]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9234] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9220 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9220]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9220] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9222 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9222]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9222] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9224 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9224]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9224] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9226 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9226]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9226] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9212 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9212]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9212] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9214 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9214]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9214] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9216 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9216]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9216] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9218 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9218]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9218] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
            else:
                mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9268 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9268]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9268] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9270 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9270]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9270] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9272 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9272]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9272] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9274 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9274]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9274] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9260 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9260]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9260] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9262 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9262]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9262] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9264 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9264]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9264] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9266 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9266]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9266] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9252 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9252]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9252] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9254 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9254]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9254] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9256 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9256]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9256] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9258 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9258]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9258] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9244 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9244]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9244] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9246 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9246]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9246] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9248 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9248]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9248] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9250 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9250]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9250] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9300 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9300]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9300] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9302 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9302]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9302] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9304 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9304]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9304] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9306 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9306]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9306] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9292 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9292]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9292] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9294 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9294]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9294] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9296 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9296]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9296] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9298 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9298]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9298] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9284 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9284]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9284] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9286 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9286]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9286] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9288 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9288]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9288] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9290 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9290]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9290] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9276 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9276]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9276] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9278 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9278]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9278] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9280 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9280]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9280] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9282 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9282]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9282] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
    else:
        if not stor1[msg.sender]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Executable: caller is not the executor'
        require uint256(sub_c42fa7f4[address(arg1)]) <= test266151307()
        mem[96] = uint256(sub_c42fa7f4[address(arg1)])
        mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == arg2:
            if not uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9332 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9332]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9332] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9334 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9334]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9334] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9336 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9336]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9336] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9338 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9338]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9338] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9324 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9324]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9324] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9326 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9326]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9326] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9328 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9328]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9328] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9330 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9330]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9330] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9316 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9316]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9316] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9318 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9318]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9318] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9320 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9320]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9320] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9322 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9322]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9322] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9308 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9308]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9308] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9310 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9310]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9310] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9312 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9312]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9312] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9314 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9314]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9314] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9364 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9364]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9364] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9366 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9366]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9366] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9368 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9368]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9368] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9370 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9370]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9370] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9356 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9356]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9356] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9358 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9358]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9358] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9360 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9360]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9360] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9362 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9362]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9362] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9348 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9348]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9348] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9350 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9350]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9350] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9352 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9352]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9352] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9354 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9354]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9354] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9340 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9340]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9340] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9342 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9342]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9342] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9344 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9344]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9344] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9346 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9346]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9346] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
            else:
                mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9396 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9396]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9396] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9398 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9398]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9398] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9400 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9400]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9400] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9402 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9402]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9402] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9388 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9388]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9388] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9390 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9390]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9390] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9392 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9392]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9392] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9394 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9394]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9394] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9380 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9380]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9380] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9382 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9382]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9382] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9384 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9384]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9384] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9386 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9386]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9386] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9372 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9372]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9372] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9374 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9374]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9374] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9376 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9376]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9376] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9378 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9378]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9378] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9428 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9428]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9428] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9430 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9430]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9430] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9432 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9432]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9432] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9434 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9434]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9434] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9420 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9420]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9420] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9422 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9422]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9422] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9424 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9424]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9424] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9426 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9426]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9426] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9412 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9412]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9412] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9414 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9414]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9414] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9416 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9416]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9416] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9418 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9418]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9418] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9404 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9404]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9404] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9406 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9406]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9406] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9408 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9408]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9408] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                           value arg3 wei
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9410 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9410]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9410] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
        else:
            if not uint256(sub_c42fa7f4[address(arg1)]):
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9460 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9460]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9460] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9462 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9462]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9462] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9464 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9464]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9464] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9466 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9466]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9466] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9452 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9452]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9452] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9454 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9454]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9454] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9456 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9456]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9456] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9458 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9458]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9458] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9444 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9444]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9444] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9446 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9446]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9446] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9448 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9448]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9448] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9450 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9450]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9450] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9436 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9436]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9436] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9438 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9438]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9438] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9440 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9440]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9440] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9442 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9442]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9442] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9492 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9492]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9492] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9494 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9494]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9494] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9496 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9496]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9496] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9498 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9498]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9498] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9484 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9484]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9484] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9486 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9486]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9486] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9488 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9488]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9488] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9490 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9490]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9490] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9476 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9476]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9476] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9478 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9478]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9478] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9480 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9480]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9480] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9482 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9482]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9482] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9468 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9468]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9468] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9470 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9470]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9470] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9472 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9472]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9472] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9474 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9474]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9474] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
            else:
                mem[128 len 32 * uint256(sub_c42fa7f4[address(arg1)])] = call.data[calldata.size len 32 * uint256(sub_c42fa7f4[address(arg1)])]
                mem[0] = arg1
                mem[32] = 4
                idx = 0
                while idx < uint256(sub_c42fa7f4[address(arg1)]):
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    if address(sub_c42fa7f4[address(arg1)][idx]) != arg2:
                        mem[0] = arg1
                        mem[32] = 4
                        idx = idx + 1
                        continue 
                    require idx < uint256(sub_c42fa7f4[address(arg1)])
                    mem[(32 * idx) + 128] = arg3
                    if sub_e676ea95[address(arg1)]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9524 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9524]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9524] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9526 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9526]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9526] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9528 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9528]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9528] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9530 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9530]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9530] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9516 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9516]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9516] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9518 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9518]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9518] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9520 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9520]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9520] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9522 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9522]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9522] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9508 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9508]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9508] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9510 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9510]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9510] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9512 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9512]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9512] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9514 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9514]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9514] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9500 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9500]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9500] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9502 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9502]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9502] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9504 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9504]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9504] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9506 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9506]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9506] - ext_call.return_data[0]
                    else:
                        require ext_code.size(0x22d53366457f9d5e68ec105046fc4383)
                        staticcall 0x22d53366457f9d5e68ec105046fc4383.get_registry() with:
                                gas gas_remaining wei
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 132] = arg1
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).get_A(address arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9556 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9556]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9556] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9558 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9558]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9558] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9560 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9560]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9560] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9562 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9562]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9562] - eth.balance(this.address)
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9548 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9548]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9548] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9550 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9550]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9550] - eth.balance(this.address)
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9552 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9552]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9552] - eth.balance(this.address)
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                return 0
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9554 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if eth.balance(this.address) > mem[_9554]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9554] - eth.balance(this.address)
                        else:
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 132] = this.address
                            require ext_code.size(sub_af88dc47[address(arg1)])
                            staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(sub_c42fa7f4[address(arg1)]) == 2:
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 64] = call.data[calldata.size len 64]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9540 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9540]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9540] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9542 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9542]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9542] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 'L~M'
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9544 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9544]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9544] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 0xee22be2300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196
                                        while idx < 2:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 260] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 292] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 196 len 64], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 256], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9546 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9546]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9546] - ext_call.return_data[0]
                            else:
                                if uint256(sub_c42fa7f4[address(arg1)]) != 3:
                                    revert with 0, 'Missing implementation'
                                mem[64] = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128 len 96] = call.data[calldata.size len 96]
                                require 0 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128] = mem[128]
                                require 1 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 160] = mem[160]
                                require 2 < uint256(sub_c42fa7f4[address(arg1)])
                                mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 192] = mem[192]
                                if not sub_e676ea95[address(arg1)]:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9532 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9532]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9532] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(arg1)
                                        call arg1.mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9534 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9534]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9534] - ext_call.return_data[0]
                                else:
                                    if not stor6[address(arg1)]:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x4515cef300000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9536 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9536]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9536] - ext_call.return_data[0]
                                    else:
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 0x2b6e993a00000000000000000000000000000000000000000000000000000000
                                        idx = 0
                                        s = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 128
                                        t = (32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228
                                        while idx < 3:
                                            mem[t] = mem[s]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 356] = 1
                                        require ext_code.size(sub_e676ea95[address(arg1)])
                                        call sub_e676ea95[address(arg1)].mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224 len 4] with:
                                             gas gas_remaining wei
                                            args mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 228 len 96], 0, 1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 224] = 32
                                        mem[(32 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + 256] = uint256(sub_c42fa7f4[address(arg1)])
                                        idx = 0
                                        s = mem[64] + 64
                                        t = 128
                                        while idx < uint256(sub_c42fa7f4[address(arg1)]):
                                            mem[s] = mem[t]
                                            mem[0] = arg1
                                            mem[32] = 4
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        emit 0x8a07cc96: mem[mem[64] len (64 * uint256(sub_c42fa7f4[address(arg1)])) + (4 * ceil32(return_data.size)) + -mem[64] + 288], arg1
                                        mem[0] = arg1
                                        mem[32] = 3
                                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == sub_af88dc47[address(arg1)]:
                                            if ext_call.return_data[0] > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            return (eth.balance(this.address) - ext_call.return_data[0])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(sub_af88dc47[address(arg1)])
                                        staticcall sub_af88dc47[address(arg1)].0x70a08231 with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9538 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > mem[_9538]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[mem[64]] = mem[_9538] - ext_call.return_data[0]
                    return memory
                      from mem[64]
                       len 32
    revert with 0, 'Missing coin'
}



}

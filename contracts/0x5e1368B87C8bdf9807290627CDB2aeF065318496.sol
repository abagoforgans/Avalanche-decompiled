contract main {




// =====================  Runtime code  =====================


#
#  - sub_943eaa8b(?)
#
address owner;
address routerAddress;
address routerAddress;
address baseTokenAddress;
address ETHAddress;
address sub_c0b6201cAddress;
uint256 sub_43ff02f6;
uint256 sub_cb523a14;
mapping of uint8 stor8;
mapping of uint8 stor9;
array of address wallets;
uint256 sub_1ef782ba;
uint256 sub_ab731cfa;
uint256 buyValue;
uint256 endingBalance;
uint256 mode;
uint8 sub_b3f6490f;
uint256 sub_adcdc67c;
uint256 sub_fce62d8f;
uint256 minLp;
uint8 stor20;

function sub_1ef782ba(?) {
    return sub_1ef782ba
}

function mode() {
    return mode
}

function routerAddress() {
    return routerAddress
}

function sub_43ff02f6(?) {
    return sub_43ff02f6
}

function sub_49e54865(?) {
    require calldata.size - 4 >= 32
    return bool(stor8[arg1])
}

function wallets(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < wallets.length
    return wallets[arg1]
}

function ETH() {
    return ETHAddress
}

function owner() {
    return owner
}

function buyValue() {
    return buyValue
}

function sub_ab731cfa(?) {
    return sub_ab731cfa
}

function sub_adcdc67c(?) {
    return sub_adcdc67c
}

function sub_b3f6490f(?) {
    return bool(sub_b3f6490f)
}

function endingBalance() {
    return endingBalance
}

function sub_c0b6201c(?) {
    return sub_c0b6201cAddress
}

function minLp() {
    return minLp
}

function baseToken() {
    return baseTokenAddress
}

function sub_cb523a14(?) {
    return sub_cb523a14
}

function sub_ebcf822c(?) {
    require calldata.size - 4 >= 32
    return bool(stor9[arg1])
}

function router() {
    return routerAddress
}

function sub_fce62d8f(?) {
    return sub_fce62d8f
}

function _fallback() payable {
    revert
}

function sub_7e49098a(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor20 = 0
}

function sub_e093d17c(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor20 = 1
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_80cba278(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor9[address(arg1)] = 1
}

function deposit() payable {
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[220 len 8]
}

function removeSecondaryOwner(address arg1) {
    require calldata.size - 4 >= 32
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[220 len 8]
    stor9[address(arg1)] = 0
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_c3b91dc2(?) {
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[220 len 8]
    call msg.sender with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_1b97acde(?) {
    require calldata.size - 4 >= 32
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    mem[(32 * arg1.length) + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 8
        stor8[mem[(32 * idx) + 140 len 20]] = 0
        idx = idx + 1
        continue 
}

function sub_2d4077d3(?) {
    require calldata.size - 4 >= 32
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    mem[(32 * arg1.length) + 128] = 0
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[(32 * arg1.length) + 252 len 8]
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 8
        stor8[mem[(32 * idx) + 140 len 20]] = 1
        idx = idx + 1
        continue 
}

function sub_81caead4(?) {
    require calldata.size - 4 >= 64
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[220 len 8]
    require ext_code.size(arg2)
    if arg1 > 0:
        call arg2.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, arg1
    else:
        staticcall arg2.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(arg2)
        call arg2.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function sub_2fdffc1c(?) {
    require calldata.size - 4 >= 288
    require arg6 <= 4294967296
    require arg6 + 36 <= calldata.size
    require arg6.length <= 4294967296 and arg6 + (32 * arg6.length) + 36 <= calldata.size
    mem[128 len 32 * arg6.length] = call.data[arg6 + 36 len 32 * arg6.length]
    mem[(32 * arg6.length) + 128] = 0
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[(32 * arg6.length) + 252 len 8]
    if arg4 < 0:
        revert with 0, 'errou algo ai ein'
    if arg4 > 3:
        revert with 0, 'errou algo ai ein'
    if arg3 <= 0:
        revert with 0, 'errou algo ai ein'
    sub_ab731cfa = 0
    baseTokenAddress = arg1
    sub_c0b6201cAddress = arg2
    sub_43ff02f6 = arg3
    mode = arg4
    routerAddress = arg5
    routerAddress = arg5
    wallets.length = arg6.length
    if not arg6.length:
        idx = 0
        while wallets.length > idx:
            wallets[idx] = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * arg6.length) + 128 > idx:
            wallets[s] = mem[idx + 12 len 20]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * arg6.length) + 31) >> 5
        while wallets.length > idx:
            wallets[idx] = 0
            idx = idx + 1
            continue 
    sub_cb523a14 = arg7
    ETHAddress = arg8
    minLp = arg9
}

function sub_285352e1(?) payable {
    require calldata.size - 4 >= 192
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    mem[0] = msg.sender
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[(32 * arg2.length) + 252 len 8]
    if arg3 == arg1:
        mem[(32 * arg2.length) + 128] = 2
        mem[64] = (32 * arg2.length) + 224
        mem[(32 * arg2.length) + 160] = arg3
        mem[(32 * arg2.length) + 192] = arg4
        require arg5 * arg2.length
        sub_1ef782ba = eth.balance(this.address) / arg5 * arg2.length
        idx = 0
        while idx < arg2.length:
            s = 0
            t = 0
            while s < arg5:
                require idx < mem[96]
                if s != arg5 - 1:
                    _116 = mem[(32 * idx) + 128]
                    _117 = mem[64]
                    mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    mem[mem[64] + 68] = address(_116)
                    mem[mem[64] + 100] = block.timestamp
                    mem[mem[64] + 36] = 128
                    mem[mem[64] + 132] = mem[(32 * arg2.length) + 128]
                    _119 = mem[(32 * arg2.length) + 128]
                    idx = 0
                    while idx < 32 * _119:
                        mem[mem[64] + idx + 164] = mem[(32 * arg2.length) + idx + 160]
                        idx = idx + 32
                        continue 
                    require ext_code.size(arg6)
                    call arg6.mem[mem[64] len 4] with:
                       value sub_1ef782ba wei
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (32 * _119) + _117 + -mem[64] + 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    s = s + 1
                    t = sub_1ef782ba
                    continue 
                if idx != mem[96] - 1:
                    _130 = mem[(32 * idx) + 128]
                    _131 = mem[64]
                    mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    mem[mem[64] + 68] = address(_130)
                    mem[mem[64] + 100] = block.timestamp
                    mem[mem[64] + 36] = 128
                    mem[mem[64] + 132] = mem[(32 * arg2.length) + 128]
                    _133 = mem[(32 * arg2.length) + 128]
                    idx = 0
                    while idx < 32 * _133:
                        mem[mem[64] + idx + 164] = mem[(32 * arg2.length) + idx + 160]
                        idx = idx + 32
                        continue 
                    require ext_code.size(arg6)
                    call arg6.mem[mem[64] len 4] with:
                       value sub_1ef782ba wei
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (32 * _133) + _131 + -mem[64] + 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    s = s + 1
                    t = sub_1ef782ba
                    continue 
                _134 = mem[(32 * idx) + 128]
                _135 = mem[64]
                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 0
                mem[mem[64] + 68] = address(_134)
                mem[mem[64] + 100] = block.timestamp
                mem[mem[64] + 36] = 128
                mem[mem[64] + 132] = mem[(32 * arg2.length) + 128]
                _137 = mem[(32 * arg2.length) + 128]
                idx = 0
                while idx < 32 * _137:
                    mem[mem[64] + idx + 164] = mem[(32 * arg2.length) + idx + 160]
                    idx = idx + 32
                    continue 
                require ext_code.size(arg6)
                call arg6.mem[mem[64] len 4] with:
                   value eth.balance(this.address) wei
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (32 * _137) + _135 + -mem[64] + 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                s = s + 1
                t = eth.balance(this.address)
                continue 
            idx = idx + 1
            continue 
    else:
        mem[(32 * arg2.length) + 128] = 3
        mem[64] = (32 * arg2.length) + 256
        mem[(32 * arg2.length) + 160] = arg1
        mem[(32 * arg2.length) + 192] = arg3
        mem[(32 * arg2.length) + 224] = arg4
        require arg5 * arg2.length
        sub_1ef782ba = eth.balance(this.address) / arg5 * arg2.length
        idx = 0
        while idx < arg2.length:
            s = 0
            t = 0
            while s < arg5:
                require idx < mem[96]
                if s != arg5 - 1:
                    _110 = mem[(32 * idx) + 128]
                    _111 = mem[64]
                    mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    mem[mem[64] + 68] = address(_110)
                    mem[mem[64] + 100] = block.timestamp
                    mem[mem[64] + 36] = 128
                    mem[mem[64] + 132] = mem[(32 * arg2.length) + 128]
                    _113 = mem[(32 * arg2.length) + 128]
                    idx = 0
                    while idx < 32 * _113:
                        mem[mem[64] + idx + 164] = mem[(32 * arg2.length) + idx + 160]
                        idx = idx + 32
                        continue 
                    require ext_code.size(arg6)
                    call arg6.mem[mem[64] len 4] with:
                       value sub_1ef782ba wei
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (32 * _113) + _111 + -mem[64] + 160]
                else:
                    if idx == mem[96] - 1:
                        _126 = mem[(32 * idx) + 128]
                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        mem[mem[64] + 68] = address(_126)
                        mem[mem[64] + 100] = block.timestamp
                        mem[mem[64] + 36] = 128
                        mem[mem[64] + 132] = mem[(32 * arg2.length) + 128]
                        _129 = mem[(32 * arg2.length) + 128]
                        idx = 0
                        while idx < 32 * _129:
                            mem[mem[64] + idx + 164] = mem[(32 * arg2.length) + idx + 160]
                            idx = idx + 32
                            continue 
                        require ext_code.size(arg6)
                        call arg6.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args 0, 128, address(_126), block.timestamp, mem[mem[64] + 132 len (32 * _129) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    _122 = mem[(32 * idx) + 128]
                    _123 = mem[64]
                    mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    mem[mem[64] + 68] = address(_122)
                    mem[mem[64] + 100] = block.timestamp
                    mem[mem[64] + 36] = 128
                    mem[mem[64] + 132] = mem[(32 * arg2.length) + 128]
                    _125 = mem[(32 * arg2.length) + 128]
                    idx = 0
                    while idx < 32 * _125:
                        mem[mem[64] + idx + 164] = mem[(32 * arg2.length) + idx + 160]
                        idx = idx + 32
                        continue 
                    require ext_code.size(arg6)
                    call arg6.mem[mem[64] len 4] with:
                       value sub_1ef782ba wei
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (32 * _125) + _123 + -mem[64] + 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                s = s + 1
                t = sub_1ef782ba
                continue 
            idx = idx + 1
            continue 
}

function sub_17386780(?) payable {
    require calldata.size - 4 >= 192
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[220 len 8]
    if arg2 != arg1:
        mem[388 len 0] = None
        require ext_code.size(arg5)
        call arg5.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
           value eth.balance(this.address) / 1000 wei
             gas gas_remaining wei
            args 0, 128, address(this.address), block.timestamp + 30, 3, mem[388 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(arg3)
        staticcall arg3.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(arg3)
        call arg3.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg5), -1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(arg2)
        call arg2.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg5), -1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg2 != arg1:
            mem[548 len 0] = None
            require ext_code.size(arg5)
            call arg5.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[548 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            endingBalance = ext_call.return_data[0]
            if arg6 == 2:
                require eth.balance(this.address) / 1000 / 10000
                if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg4:
                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(arg1)
            call arg1.0x23b872dd with:
                 gas gas_remaining wei
                args this.address, 0, msg.sender, ext_call.return_data[0]
        else:
            mem[516 len 0] = None
            require ext_code.size(arg5)
            call arg5.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[516 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            endingBalance = ext_call.return_data[0]
            if arg6 == 2:
                require eth.balance(this.address) / 1000 / 10000
                if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg4:
                    revert with 0, '', 'taxa ta alta pra caralhoooo'
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(arg1)
            call arg1.0x23b872dd with:
                 gas gas_remaining wei
                args address(this.address), msg.sender, 0, ext_call.return_data[0]
    else:
        mem[356 len 0] = None
        require ext_code.size(arg5)
        call arg5.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
           value eth.balance(this.address) / 1000 wei
             gas gas_remaining wei
            args 0, 128, address(this.address), block.timestamp + 30, 2, mem[356 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(arg3)
        staticcall arg3.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(arg3)
        call arg3.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg5), -1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(arg2)
        call arg2.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg5), -1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg2 != arg1:
            mem[516 len 0] = None
            require ext_code.size(arg5)
            call arg5.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[516 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            endingBalance = ext_call.return_data[0]
            if arg6 == 2:
                require eth.balance(this.address) / 1000 / 10000
                if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg4:
                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(arg1)
            call arg1.0x23b872dd with:
                 gas gas_remaining wei
                args this.address, 0, msg.sender, ext_call.return_data[0]
        else:
            mem[484 len 0] = None
            require ext_code.size(arg5)
            call arg5.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[484 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            endingBalance = ext_call.return_data[0]
            if arg6 == 2:
                require eth.balance(this.address) / 1000 / 10000
                if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg4:
                    revert with 0, '', 'taxa ta alta pra caralhoooo'
            require ext_code.size(arg1)
            staticcall arg1.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(arg1)
            call arg1.0x23b872dd with:
                 gas gas_remaining wei
                args address(this.address), msg.sender, 0, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function sub_6ad42679(?) payable {
    require calldata.size - 4 >= 288
    require arg5 <= 4294967296
    require arg5 + 36 <= calldata.size
    require arg5.length <= 4294967296 and arg5 + (32 * arg5.length) + 36 <= calldata.size
    mem[96] = arg5.length
    mem[128 len 32 * arg5.length] = call.data[arg5 + 36 len 32 * arg5.length]
    mem[0] = msg.sender
    mem[32] = 9
    if bool(stor9[address(msg.sender)]) != 1:
        revert with 0, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[(32 * arg5.length) + 252 len 8]
    if bool(stor20) != 1:
        revert with 0, 'oh nao, o contrato morreu :('
    require ext_code.size(arg1)
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'nem criaram o par ainda carai'
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] == arg2:
        if Mask(112, 0, ext_call.return_data[0]) <= arg7:
            revert with 0, 
                        32,
                        48,
                        0x6f6f2062616e672074656d206d656e6f73206c6971756964657a20717565206f20736575206d696e696d6f20616d6967,
                        mem[(32 * arg5.length) + 244 len 16]
        if arg9 == 3:
            if arg2 == arg8:
                mem[(32 * arg5.length) + 128] = 2
                mem[64] = (32 * arg5.length) + 224
                mem[(32 * arg5.length) + 160] = arg2
                mem[(32 * arg5.length) + 192] = arg3
                require arg4 * arg5.length
                idx = 0
                while idx < arg5.length:
                    require idx < mem[96]
                    _1573 = mem[(32 * idx) + 128]
                    _1574 = mem[64]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 100] = address(_1573)
                    mem[mem[64] + 132] = block.timestamp
                    mem[mem[64] + 68] = 128
                    mem[mem[64] + 164] = mem[(32 * arg5.length) + 128]
                    _1576 = mem[(32 * arg5.length) + 128]
                    s = 0
                    while s < 32 * _1576:
                        mem[mem[64] + s + 196] = mem[(32 * arg5.length) + s + 160]
                        s = s + 32
                        continue 
                    _3004 = mem[64]
                    mem[mem[64]] = (32 * _1576) + _1574 + -mem[64] + 164
                    mem[64] = (32 * _1576) + _1574 + 196
                    mem[_3004 + 32] = mem[_3004 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                    s = 0
                    t = 0
                    while s < arg4:
                        if s != arg4 - 1:
                            _4379 = mem[64]
                            _4380 = mem[_3004]
                            t = _3004 + 32
                            u = mem[64]
                            idx = mem[_3004]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3004])] = mem[_3004 + floor32(mem[_3004]) + -(mem[_3004] % 32) + 64 len mem[_3004] % 32] or Mask(8 * -(mem[_3004] % 32) + 32, -(8 * -(mem[_3004] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3004])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4380 + _4379 + -mem[64] - 4]
                            if return_data.size:
                                _5216 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5216] = return_data.size
                                mem[_5216 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        if idx != mem[96] - 1:
                            _4405 = mem[64]
                            _4406 = mem[_3004]
                            t = _3004 + 32
                            u = mem[64]
                            idx = mem[_3004]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3004])] = mem[_3004 + floor32(mem[_3004]) + -(mem[_3004] % 32) + 64 len mem[_3004] % 32] or Mask(8 * -(mem[_3004] % 32) + 32, -(8 * -(mem[_3004] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3004])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4406 + _4405 + -mem[64] - 4]
                            if return_data.size:
                                _5217 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5217] = return_data.size
                                mem[_5217 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        _4407 = mem[64]
                        _4408 = mem[_3004]
                        t = _3004 + 32
                        u = mem[64]
                        idx = mem[_3004]
                        while idx >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_3004])] = mem[_3004 + floor32(mem[_3004]) + -(mem[_3004] % 32) + 64 len mem[_3004] % 32] or Mask(8 * -(mem[_3004] % 32) + 32, -(8 * -(mem[_3004] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3004])])
                        call arg1.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _4408 + _4407 + -mem[64] - 4]
                        if return_data.size:
                            _5218 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_5218] = return_data.size
                            mem[_5218 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
            else:
                mem[(32 * arg5.length) + 128] = 3
                mem[64] = (32 * arg5.length) + 256
                mem[(32 * arg5.length) + 160] = arg8
                mem[(32 * arg5.length) + 192] = arg2
                mem[(32 * arg5.length) + 224] = arg3
                require arg4 * arg5.length
                idx = 0
                while idx < arg5.length:
                    require idx < mem[96]
                    _1569 = mem[(32 * idx) + 128]
                    _1570 = mem[64]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 100] = address(_1569)
                    mem[mem[64] + 132] = block.timestamp
                    mem[mem[64] + 68] = 128
                    mem[mem[64] + 164] = mem[(32 * arg5.length) + 128]
                    _1572 = mem[(32 * arg5.length) + 128]
                    s = 0
                    while s < 32 * _1572:
                        mem[mem[64] + s + 196] = mem[(32 * arg5.length) + s + 160]
                        s = s + 32
                        continue 
                    _3001 = mem[64]
                    mem[mem[64]] = (32 * _1572) + _1570 + -mem[64] + 164
                    mem[64] = (32 * _1572) + _1570 + 196
                    mem[_3001 + 32] = mem[_3001 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                    s = 0
                    t = 0
                    while s < arg4:
                        if s != arg4 - 1:
                            _4378 = mem[_3001]
                            t = _3001 + 32
                            u = mem[64]
                            idx = mem[_3001]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3001])] = mem[_3001 + floor32(mem[_3001]) + -(mem[_3001] % 32) + 64 len mem[_3001] % 32] or Mask(8 * -(mem[_3001] % 32) + 32, -(8 * -(mem[_3001] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3001])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4378 - 4]
                            if return_data.size:
                                _5213 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5213] = return_data.size
                                mem[_5213 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        if idx != mem[96] - 1:
                            _4402 = mem[_3001]
                            t = _3001 + 32
                            u = mem[64]
                            idx = mem[_3001]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3001])] = mem[_3001 + floor32(mem[_3001]) + -(mem[_3001] % 32) + 64 len mem[_3001] % 32] or Mask(8 * -(mem[_3001] % 32) + 32, -(8 * -(mem[_3001] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3001])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4402 - 4]
                            if return_data.size:
                                _5214 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5214] = return_data.size
                                mem[_5214 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        _4404 = mem[_3001]
                        t = _3001 + 32
                        u = mem[64]
                        idx = mem[_3001]
                        while idx >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_3001])] = mem[_3001 + floor32(mem[_3001]) + -(mem[_3001] % 32) + 64 len mem[_3001] % 32] or Mask(8 * -(mem[_3001] % 32) + 32, -(8 * -(mem[_3001] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3001])])
                        call arg1.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _4404 - 4]
                        if return_data.size:
                            _5215 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_5215] = return_data.size
                            mem[_5215 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
        else:
            if not arg9:
                mem[0] = msg.sender
                if bool(stor9[address(msg.sender)]) != 1:
                    revert with 0, 
                                32,
                                56,
                                0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                mem[(32 * arg5.length) + 252 len 8]
                if arg2 == arg8:
                    mem[(32 * arg5.length) + 128] = 2
                    mem[64] = (32 * arg5.length) + 224
                    mem[(32 * arg5.length) + 160] = arg2
                    mem[(32 * arg5.length) + 192] = arg3
                    require arg4 * arg5.length
                    sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                    idx = 0
                    while idx < arg5.length:
                        s = 0
                        t = 0
                        while s < arg4:
                            require idx < mem[96]
                            if s != arg4 - 1:
                                _3055 = mem[(32 * idx) + 128]
                                _3056 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3055)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3058 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3058:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3058) + _3056 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            if idx != mem[96] - 1:
                                _3089 = mem[(32 * idx) + 128]
                                _3090 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3089)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3092 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3092:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3092) + _3090 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            _3093 = mem[(32 * idx) + 128]
                            _3094 = mem[64]
                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = address(_3093)
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                            _3096 = mem[(32 * arg5.length) + 128]
                            idx = 0
                            while idx < 32 * _3096:
                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                idx = idx + 32
                                continue 
                            require ext_code.size(arg1)
                            call arg1.mem[mem[64] len 4] with:
                               value eth.balance(this.address) wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * _3096) + _3094 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = eth.balance(this.address)
                            continue 
                        idx = idx + 1
                        continue 
                else:
                    mem[(32 * arg5.length) + 128] = 3
                    mem[64] = (32 * arg5.length) + 256
                    mem[(32 * arg5.length) + 160] = arg8
                    mem[(32 * arg5.length) + 192] = arg2
                    mem[(32 * arg5.length) + 224] = arg3
                    require arg4 * arg5.length
                    sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                    idx = 0
                    while idx < arg5.length:
                        s = 0
                        t = 0
                        while s < arg4:
                            require idx < mem[96]
                            if s != arg4 - 1:
                                _3049 = mem[(32 * idx) + 128]
                                _3050 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3049)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3052 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3052:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3052) + _3050 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            if idx != mem[96] - 1:
                                _3081 = mem[(32 * idx) + 128]
                                _3082 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3081)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3084 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3084:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3084) + _3082 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            _3085 = mem[(32 * idx) + 128]
                            _3086 = mem[64]
                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = address(_3085)
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                            _3088 = mem[(32 * arg5.length) + 128]
                            idx = 0
                            while idx < 32 * _3088:
                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                idx = idx + 32
                                continue 
                            require ext_code.size(arg1)
                            call arg1.mem[mem[64] len 4] with:
                               value eth.balance(this.address) wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * _3088) + _3086 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = eth.balance(this.address)
                            continue 
                        idx = idx + 1
                        continue 
            else:
                if bool(stor9[address(msg.sender)]) != 1:
                    revert with 0, 
                                32,
                                56,
                                0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                mem[(32 * arg5.length) + 252 len 8]
                if arg2 == arg8:
                    mem[(32 * arg5.length) + 128] = 2
                    mem[(32 * arg5.length) + 160] = arg2
                    mem[(32 * arg5.length) + 192] = arg3
                    mem[(32 * arg5.length) + 388 len 0] = None
                    require ext_code.size(arg1)
                    call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 2, mem[(32 * arg5.length) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    staticcall arg3.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg3)
                    call arg3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg2)
                    call arg2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 == arg8:
                        mem[(32 * arg5.length) + 224] = 2
                        mem[(32 * arg5.length) + 256] = arg3
                        mem[(32 * arg5.length) + 288] = arg2
                        mem[(32 * arg5.length) + 420] = this.address
                        mem[(32 * arg5.length) + 452] = block.timestamp + 30
                        mem[(32 * arg5.length) + 484] = 2
                        mem[(32 * arg5.length) + 516 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[(32 * arg5.length) + 516 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 388] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 320] = 2
                                mem[64] = (32 * arg5.length) + 416
                                mem[(32 * arg5.length) + 352] = arg2
                                mem[(32 * arg5.length) + 384] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5351 = mem[(32 * idx) + 128]
                                            _5352 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5351)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5354 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5354:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5354) + _5352 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5569 = mem[(32 * idx) + 128]
                                            _5570 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5569)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5572 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5572:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5572) + _5570 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5573 = mem[(32 * idx) + 128]
                                        _5574 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5573)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5576 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5576:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5576) + _5574 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 320] = 3
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 352] = arg8
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5345 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5345)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5348 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5348:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5345), block.timestamp, mem[mem[64] + 132 len (32 * _5348) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5561 = mem[(32 * idx) + 128]
                                            _5562 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5561)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5564 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5564:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5564) + _5562 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5565 = mem[(32 * idx) + 128]
                                        _5566 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5565)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5568 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5568:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5568) + _5566 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 388] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 320] = 2
                                mem[64] = (32 * arg5.length) + 416
                                mem[(32 * arg5.length) + 352] = arg2
                                mem[(32 * arg5.length) + 384] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5363 = mem[(32 * idx) + 128]
                                            _5364 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5363)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5366 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5366:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5366) + _5364 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5585 = mem[(32 * idx) + 128]
                                            _5586 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5585)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5588 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5588:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5588) + _5586 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5589 = mem[(32 * idx) + 128]
                                        _5590 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5589)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5592 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5592:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5592) + _5590 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 320] = 3
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 352] = arg8
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5357 = mem[(32 * idx) + 128]
                                            _5358 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5357)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5360 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5360:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5360) + _5358 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5577 = mem[(32 * idx) + 128]
                                            _5578 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5577)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5580 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5580:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5580) + _5578 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5581 = mem[(32 * idx) + 128]
                                        _5582 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5581)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5584 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5584:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5584) + _5582 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                    else:
                        mem[(32 * arg5.length) + 224] = 3
                        mem[(32 * arg5.length) + 256] = arg3
                        mem[(32 * arg5.length) + 288] = arg2
                        mem[(32 * arg5.length) + 320] = arg8
                        mem[(32 * arg5.length) + 452] = this.address
                        mem[(32 * arg5.length) + 484] = block.timestamp + 30
                        mem[(32 * arg5.length) + 516] = 3
                        mem[(32 * arg5.length) + 548 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[(32 * arg5.length) + 548 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5327 = mem[(32 * idx) + 128]
                                            _5328 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5327)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5330 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5330:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5330) + _5328 + -mem[64] + 160]
                                        else:
                                            if idx == mem[96] - 1:
                                                _5541 = mem[(32 * idx) + 128]
                                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = address(_5541)
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                                _5544 = mem[(32 * arg5.length) + 352]
                                                idx = 0
                                                while idx < 32 * _5544:
                                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(arg1)
                                                call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, address(_5541), block.timestamp, mem[mem[64] + 132 len (32 * _5544) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            _5537 = mem[(32 * idx) + 128]
                                            _5538 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5537)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5540 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5540:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5540) + _5538 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5321 = mem[(32 * idx) + 128]
                                            _5322 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5321)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5324 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5324:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5324) + _5322 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5529 = mem[(32 * idx) + 128]
                                            _5530 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5529)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5532 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5532:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5532) + _5530 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5533 = mem[(32 * idx) + 128]
                                        _5534 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5533)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5536 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5536:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5536) + _5534 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5339 = mem[(32 * idx) + 128]
                                            _5340 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5339)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5342 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5342:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5342) + _5340 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5553 = mem[(32 * idx) + 128]
                                            _5554 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5553)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5556 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5556:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5556) + _5554 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5557 = mem[(32 * idx) + 128]
                                        _5558 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5557)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5560 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5560:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5560) + _5558 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5333 = mem[(32 * idx) + 128]
                                            _5334 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5333)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5336 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5336:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5336) + _5334 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5545 = mem[(32 * idx) + 128]
                                            _5546 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5545)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5548 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5548:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5548) + _5546 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5549 = mem[(32 * idx) + 128]
                                        _5550 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5549)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5552 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5552:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5552) + _5550 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                else:
                    mem[(32 * arg5.length) + 128] = 3
                    mem[(32 * arg5.length) + 160] = arg8
                    mem[(32 * arg5.length) + 192] = arg2
                    mem[(32 * arg5.length) + 224] = arg3
                    mem[(32 * arg5.length) + 420 len 0] = None
                    require ext_code.size(arg1)
                    call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 3, mem[(32 * arg5.length) + 420 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    staticcall arg3.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg3)
                    call arg3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg2)
                    call arg2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 == arg8:
                        mem[(32 * arg5.length) + 256] = 2
                        mem[(32 * arg5.length) + 288] = arg3
                        mem[(32 * arg5.length) + 320] = arg2
                        mem[(32 * arg5.length) + 452] = this.address
                        mem[(32 * arg5.length) + 484] = block.timestamp + 30
                        mem[(32 * arg5.length) + 516] = 2
                        mem[(32 * arg5.length) + 548 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[(32 * arg5.length) + 548 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5303 = mem[(32 * idx) + 128]
                                            _5304 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5303)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5306 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5306:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5306) + _5304 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5505 = mem[(32 * idx) + 128]
                                            _5506 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5505)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5508 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5508:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5508) + _5506 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5509 = mem[(32 * idx) + 128]
                                        _5510 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5509)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5512 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5512:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5512) + _5510 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5297 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5297)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5300 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5300:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5297), block.timestamp, mem[mem[64] + 132 len (32 * _5300) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5497 = mem[(32 * idx) + 128]
                                            _5498 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5497)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5500 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5500:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5500) + _5498 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5501 = mem[(32 * idx) + 128]
                                        _5502 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5501)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5504 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5504:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5504) + _5502 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5315 = mem[(32 * idx) + 128]
                                            _5316 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5315)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5318 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5318:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5318) + _5316 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5521 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5521)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5524 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5524:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5521), block.timestamp, mem[mem[64] + 132 len (32 * _5524) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5525 = mem[(32 * idx) + 128]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5525)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5528 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5528:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args 0, 128, address(_5525), block.timestamp, mem[mem[64] + 132 len (32 * _5528) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5309 = mem[(32 * idx) + 128]
                                            _5310 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5309)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5312 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5312:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5312) + _5310 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5513 = mem[(32 * idx) + 128]
                                            _5514 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5513)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5516 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5516:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5516) + _5514 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5517 = mem[(32 * idx) + 128]
                                        _5518 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5517)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5520 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5520:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5520) + _5518 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                    else:
                        mem[(32 * arg5.length) + 256] = 3
                        mem[(32 * arg5.length) + 288] = arg3
                        mem[(32 * arg5.length) + 320] = arg2
                        mem[(32 * arg5.length) + 352] = arg8
                        mem[(32 * arg5.length) + 484] = this.address
                        mem[(32 * arg5.length) + 516] = block.timestamp + 30
                        mem[(32 * arg5.length) + 548] = 3
                        mem[(32 * arg5.length) + 580 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[(32 * arg5.length) + 580 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 452] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 384] = 2
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5279 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5279)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5282 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5282:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5279), block.timestamp, mem[mem[64] + 132 len (32 * _5282) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5473 = mem[(32 * idx) + 128]
                                            _5474 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5473)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5476 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5476:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5476) + _5474 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5477 = mem[(32 * idx) + 128]
                                        _5478 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5477)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5480 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5480:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5480) + _5478 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 384] = 3
                                mem[64] = (32 * arg5.length) + 512
                                mem[(32 * arg5.length) + 416] = arg8
                                mem[(32 * arg5.length) + 448] = arg2
                                mem[(32 * arg5.length) + 480] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5273 = mem[(32 * idx) + 128]
                                            _5274 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5273)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5276 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5276:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5276) + _5274 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5465 = mem[(32 * idx) + 128]
                                            _5466 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5465)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5468 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5468:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5468) + _5466 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5469 = mem[(32 * idx) + 128]
                                        _5470 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5469)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5472 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5472:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5472) + _5470 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 452] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 384] = 2
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5291 = mem[(32 * idx) + 128]
                                            _5292 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5291)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5294 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5294:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5294) + _5292 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5489 = mem[(32 * idx) + 128]
                                            _5490 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5489)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5492 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5492:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5492) + _5490 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5493 = mem[(32 * idx) + 128]
                                        _5494 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5493)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5496 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5496:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5496) + _5494 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 384] = 3
                                mem[64] = (32 * arg5.length) + 512
                                mem[(32 * arg5.length) + 416] = arg8
                                mem[(32 * arg5.length) + 448] = arg2
                                mem[(32 * arg5.length) + 480] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5285 = mem[(32 * idx) + 128]
                                            _5286 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5285)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5288 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5288:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5288) + _5286 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5481 = mem[(32 * idx) + 128]
                                            _5482 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5481)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5484 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5484:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5484) + _5482 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5485 = mem[(32 * idx) + 128]
                                        _5486 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5485)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5488 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5488:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5488) + _5486 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
    else:
        if Mask(112, 0, ext_call.return_data[32]) <= arg7:
            revert with 0, 
                        32,
                        48,
                        0x6f6f2062616e672074656d206d656e6f73206c6971756964657a20717565206f20736575206d696e696d6f20616d6967,
                        mem[(32 * arg5.length) + 244 len 16]
        if arg9 == 3:
            if arg2 == arg8:
                mem[(32 * arg5.length) + 128] = 2
                mem[64] = (32 * arg5.length) + 224
                mem[(32 * arg5.length) + 160] = arg2
                mem[(32 * arg5.length) + 192] = arg3
                require arg4 * arg5.length
                idx = 0
                while idx < arg5.length:
                    require idx < mem[96]
                    _1581 = mem[(32 * idx) + 128]
                    _1582 = mem[64]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 100] = address(_1581)
                    mem[mem[64] + 132] = block.timestamp
                    mem[mem[64] + 68] = 128
                    mem[mem[64] + 164] = mem[(32 * arg5.length) + 128]
                    _1584 = mem[(32 * arg5.length) + 128]
                    s = 0
                    while s < 32 * _1584:
                        mem[mem[64] + s + 196] = mem[(32 * arg5.length) + s + 160]
                        s = s + 32
                        continue 
                    _3018 = mem[64]
                    mem[mem[64]] = (32 * _1584) + _1582 + -mem[64] + 164
                    mem[64] = (32 * _1584) + _1582 + 196
                    mem[_3018 + 32] = mem[_3018 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                    s = 0
                    t = 0
                    while s < arg4:
                        if s != arg4 - 1:
                            _4400 = mem[_3018]
                            t = _3018 + 32
                            u = mem[64]
                            idx = mem[_3018]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3018])] = mem[_3018 + floor32(mem[_3018]) + -(mem[_3018] % 32) + 64 len mem[_3018] % 32] or Mask(8 * -(mem[_3018] % 32) + 32, -(8 * -(mem[_3018] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3018])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4400 - 4]
                            if return_data.size:
                                _5238 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5238] = return_data.size
                                mem[_5238 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        if idx != mem[96] - 1:
                            _4414 = mem[_3018]
                            t = _3018 + 32
                            u = mem[64]
                            idx = mem[_3018]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3018])] = mem[_3018 + floor32(mem[_3018]) + -(mem[_3018] % 32) + 64 len mem[_3018] % 32] or Mask(8 * -(mem[_3018] % 32) + 32, -(8 * -(mem[_3018] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3018])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4414 - 4]
                            if return_data.size:
                                _5239 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5239] = return_data.size
                                mem[_5239 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        _4416 = mem[_3018]
                        t = _3018 + 32
                        u = mem[64]
                        idx = mem[_3018]
                        while idx >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_3018])] = mem[_3018 + floor32(mem[_3018]) + -(mem[_3018] % 32) + 64 len mem[_3018] % 32] or Mask(8 * -(mem[_3018] % 32) + 32, -(8 * -(mem[_3018] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3018])])
                        call arg1.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _4416 - 4]
                        if return_data.size:
                            _5240 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_5240] = return_data.size
                            mem[_5240 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
            else:
                mem[(32 * arg5.length) + 128] = 3
                mem[64] = (32 * arg5.length) + 256
                mem[(32 * arg5.length) + 160] = arg8
                mem[(32 * arg5.length) + 192] = arg2
                mem[(32 * arg5.length) + 224] = arg3
                require arg4 * arg5.length
                idx = 0
                while idx < arg5.length:
                    require idx < mem[96]
                    _1577 = mem[(32 * idx) + 128]
                    _1578 = mem[64]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 100] = address(_1577)
                    mem[mem[64] + 132] = block.timestamp
                    mem[mem[64] + 68] = 128
                    mem[mem[64] + 164] = mem[(32 * arg5.length) + 128]
                    _1580 = mem[(32 * arg5.length) + 128]
                    s = 0
                    while s < 32 * _1580:
                        mem[mem[64] + s + 196] = mem[(32 * arg5.length) + s + 160]
                        s = s + 32
                        continue 
                    _3015 = mem[64]
                    mem[mem[64]] = (32 * _1580) + _1578 + -mem[64] + 164
                    mem[64] = (32 * _1580) + _1578 + 196
                    mem[_3015 + 32] = mem[_3015 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                    s = 0
                    t = 0
                    while s < arg4:
                        if s != arg4 - 1:
                            _4397 = mem[64]
                            _4398 = mem[_3015]
                            t = _3015 + 32
                            u = mem[64]
                            idx = mem[_3015]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3015])] = mem[_3015 + floor32(mem[_3015]) + -(mem[_3015] % 32) + 64 len mem[_3015] % 32] or Mask(8 * -(mem[_3015] % 32) + 32, -(8 * -(mem[_3015] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3015])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4398 + _4397 + -mem[64] - 4]
                            if return_data.size:
                                _5235 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5235] = return_data.size
                                mem[_5235 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        if idx != mem[96] - 1:
                            _4409 = mem[64]
                            _4410 = mem[_3015]
                            t = _3015 + 32
                            u = mem[64]
                            idx = mem[_3015]
                            while idx >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_3015])] = mem[_3015 + floor32(mem[_3015]) + -(mem[_3015] % 32) + 64 len mem[_3015] % 32] or Mask(8 * -(mem[_3015] % 32) + 32, -(8 * -(mem[_3015] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3015])])
                            call arg1.mem[mem[64] len 4] with:
                               value msg.value / arg4 * arg5.length wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4410 + _4409 + -mem[64] - 4]
                            if return_data.size:
                                _5236 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_5236] = return_data.size
                                mem[_5236 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = msg.value / arg4 * arg5.length
                            continue 
                        _4411 = mem[64]
                        _4412 = mem[_3015]
                        t = _3015 + 32
                        u = mem[64]
                        idx = mem[_3015]
                        while idx >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_3015])] = mem[_3015 + floor32(mem[_3015]) + -(mem[_3015] % 32) + 64 len mem[_3015] % 32] or Mask(8 * -(mem[_3015] % 32) + 32, -(8 * -(mem[_3015] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_3015])])
                        call arg1.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _4412 + _4411 + -mem[64] - 4]
                        if return_data.size:
                            _5237 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_5237] = return_data.size
                            mem[_5237 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
        else:
            if not arg9:
                mem[0] = msg.sender
                if bool(stor9[address(msg.sender)]) != 1:
                    revert with 0, 
                                32,
                                56,
                                0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                mem[(32 * arg5.length) + 252 len 8]
                if arg2 == arg8:
                    mem[(32 * arg5.length) + 128] = 2
                    mem[64] = (32 * arg5.length) + 224
                    mem[(32 * arg5.length) + 160] = arg2
                    mem[(32 * arg5.length) + 192] = arg3
                    require arg4 * arg5.length
                    sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                    idx = 0
                    while idx < arg5.length:
                        s = 0
                        t = 0
                        while s < arg4:
                            require idx < mem[96]
                            if s != arg4 - 1:
                                _3071 = mem[(32 * idx) + 128]
                                _3072 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3071)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3074 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3074:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3074) + _3072 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            if idx != mem[96] - 1:
                                _3113 = mem[(32 * idx) + 128]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3113)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3116 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3116:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args 0, 128, address(_3113), block.timestamp, mem[mem[64] + 132 len (32 * _3116) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            _3117 = mem[(32 * idx) + 128]
                            _3118 = mem[64]
                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = address(_3117)
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                            _3120 = mem[(32 * arg5.length) + 128]
                            idx = 0
                            while idx < 32 * _3120:
                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                idx = idx + 32
                                continue 
                            require ext_code.size(arg1)
                            call arg1.mem[mem[64] len 4] with:
                               value eth.balance(this.address) wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * _3120) + _3118 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = eth.balance(this.address)
                            continue 
                        idx = idx + 1
                        continue 
                else:
                    mem[(32 * arg5.length) + 128] = 3
                    mem[64] = (32 * arg5.length) + 256
                    mem[(32 * arg5.length) + 160] = arg8
                    mem[(32 * arg5.length) + 192] = arg2
                    mem[(32 * arg5.length) + 224] = arg3
                    require arg4 * arg5.length
                    sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                    idx = 0
                    while idx < arg5.length:
                        s = 0
                        t = 0
                        while s < arg4:
                            require idx < mem[96]
                            if s != arg4 - 1:
                                _3065 = mem[(32 * idx) + 128]
                                _3066 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3065)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3068 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3068:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3068) + _3066 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            if idx != mem[96] - 1:
                                _3105 = mem[(32 * idx) + 128]
                                _3106 = mem[64]
                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 0
                                mem[mem[64] + 68] = address(_3105)
                                mem[mem[64] + 100] = block.timestamp
                                mem[mem[64] + 36] = 128
                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                                _3108 = mem[(32 * arg5.length) + 128]
                                idx = 0
                                while idx < 32 * _3108:
                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                    idx = idx + 32
                                    continue 
                                require ext_code.size(arg1)
                                call arg1.mem[mem[64] len 4] with:
                                   value sub_1ef782ba wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (32 * _3108) + _3106 + -mem[64] + 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                s = s + 1
                                t = sub_1ef782ba
                                continue 
                            _3109 = mem[(32 * idx) + 128]
                            _3110 = mem[64]
                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = address(_3109)
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 128]
                            _3112 = mem[(32 * arg5.length) + 128]
                            idx = 0
                            while idx < 32 * _3112:
                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 160]
                                idx = idx + 32
                                continue 
                            require ext_code.size(arg1)
                            call arg1.mem[mem[64] len 4] with:
                               value eth.balance(this.address) wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * _3112) + _3110 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            s = s + 1
                            t = eth.balance(this.address)
                            continue 
                        idx = idx + 1
                        continue 
            else:
                if bool(stor9[address(msg.sender)]) != 1:
                    revert with 0, 
                                32,
                                56,
                                0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                mem[(32 * arg5.length) + 252 len 8]
                if arg2 == arg8:
                    mem[(32 * arg5.length) + 128] = 2
                    mem[(32 * arg5.length) + 160] = arg2
                    mem[(32 * arg5.length) + 192] = arg3
                    mem[(32 * arg5.length) + 388 len 0] = None
                    require ext_code.size(arg1)
                    call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 2, mem[(32 * arg5.length) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    staticcall arg3.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg3)
                    call arg3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg2)
                    call arg2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 == arg8:
                        mem[(32 * arg5.length) + 224] = 2
                        mem[(32 * arg5.length) + 256] = arg3
                        mem[(32 * arg5.length) + 288] = arg2
                        mem[(32 * arg5.length) + 420] = this.address
                        mem[(32 * arg5.length) + 452] = block.timestamp + 30
                        mem[(32 * arg5.length) + 484] = 2
                        mem[(32 * arg5.length) + 516 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[(32 * arg5.length) + 516 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 388] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 320] = 2
                                mem[64] = (32 * arg5.length) + 416
                                mem[(32 * arg5.length) + 352] = arg2
                                mem[(32 * arg5.length) + 384] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5447 = mem[(32 * idx) + 128]
                                            _5448 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5447)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5450 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5450:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5450) + _5448 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5697 = mem[(32 * idx) + 128]
                                            _5698 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5697)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5700 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5700:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5700) + _5698 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5701 = mem[(32 * idx) + 128]
                                        _5702 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5701)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5704 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5704:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5704) + _5702 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 320] = 3
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 352] = arg8
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5441 = mem[(32 * idx) + 128]
                                            _5442 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5441)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5444 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5444:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5444) + _5442 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5689 = mem[(32 * idx) + 128]
                                            _5690 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5689)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5692 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5692:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5692) + _5690 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5693 = mem[(32 * idx) + 128]
                                        _5694 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5693)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5696 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5696:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5696) + _5694 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 388] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 320] = 2
                                mem[64] = (32 * arg5.length) + 416
                                mem[(32 * arg5.length) + 352] = arg2
                                mem[(32 * arg5.length) + 384] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5459 = mem[(32 * idx) + 128]
                                            _5460 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5459)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5462 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5462:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5462) + _5460 + -mem[64] + 160]
                                        else:
                                            if idx == mem[96] - 1:
                                                _5717 = mem[(32 * idx) + 128]
                                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = address(_5717)
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                                _5720 = mem[(32 * arg5.length) + 320]
                                                idx = 0
                                                while idx < 32 * _5720:
                                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(arg1)
                                                call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, address(_5717), block.timestamp, mem[mem[64] + 132 len (32 * _5720) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            _5713 = mem[(32 * idx) + 128]
                                            _5714 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5713)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5716 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5716:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5716) + _5714 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 320] = 3
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 352] = arg8
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5453 = mem[(32 * idx) + 128]
                                            _5454 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5453)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5456 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5456:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5456) + _5454 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5705 = mem[(32 * idx) + 128]
                                            _5706 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5705)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                            _5708 = mem[(32 * arg5.length) + 320]
                                            idx = 0
                                            while idx < 32 * _5708:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5708) + _5706 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5709 = mem[(32 * idx) + 128]
                                        _5710 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5709)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 320]
                                        _5712 = mem[(32 * arg5.length) + 320]
                                        idx = 0
                                        while idx < 32 * _5712:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5712) + _5710 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                    else:
                        mem[(32 * arg5.length) + 224] = 3
                        mem[(32 * arg5.length) + 256] = arg3
                        mem[(32 * arg5.length) + 288] = arg2
                        mem[(32 * arg5.length) + 320] = arg8
                        mem[(32 * arg5.length) + 452] = this.address
                        mem[(32 * arg5.length) + 484] = block.timestamp + 30
                        mem[(32 * arg5.length) + 516] = 3
                        mem[(32 * arg5.length) + 548 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[(32 * arg5.length) + 548 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5423 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5423)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5426 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5426:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5423), block.timestamp, mem[mem[64] + 132 len (32 * _5426) + 32]
                                        else:
                                            if idx == mem[96] - 1:
                                                _5669 = mem[(32 * idx) + 128]
                                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = address(_5669)
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                                _5672 = mem[(32 * arg5.length) + 352]
                                                idx = 0
                                                while idx < 32 * _5672:
                                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(arg1)
                                                call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, address(_5669), block.timestamp, mem[mem[64] + 132 len (32 * _5672) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            _5665 = mem[(32 * idx) + 128]
                                            _5666 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5665)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5668 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5668:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5668) + _5666 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5417 = mem[(32 * idx) + 128]
                                            _5418 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5417)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5420 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5420:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5420) + _5418 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5657 = mem[(32 * idx) + 128]
                                            _5658 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5657)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5660 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5660:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5660) + _5658 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5661 = mem[(32 * idx) + 128]
                                        _5662 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5661)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5664 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5664:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5664) + _5662 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5435 = mem[(32 * idx) + 128]
                                            _5436 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5435)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5438 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5438:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5438) + _5436 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5681 = mem[(32 * idx) + 128]
                                            _5682 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5681)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5684 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5684:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5684) + _5682 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5685 = mem[(32 * idx) + 128]
                                        _5686 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5685)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5688 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5688:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5688) + _5686 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5429 = mem[(32 * idx) + 128]
                                            _5430 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5429)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5432 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5432:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5432) + _5430 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5673 = mem[(32 * idx) + 128]
                                            _5674 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5673)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5676 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5676:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5676) + _5674 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5677 = mem[(32 * idx) + 128]
                                        _5678 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5677)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5680 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5680:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5680) + _5678 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                else:
                    mem[(32 * arg5.length) + 128] = 3
                    mem[(32 * arg5.length) + 160] = arg8
                    mem[(32 * arg5.length) + 192] = arg2
                    mem[(32 * arg5.length) + 224] = arg3
                    mem[(32 * arg5.length) + 420 len 0] = None
                    require ext_code.size(arg1)
                    call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 3, mem[(32 * arg5.length) + 420 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    staticcall arg3.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg3)
                    call arg3.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(arg2)
                    call arg2.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 == arg8:
                        mem[(32 * arg5.length) + 256] = 2
                        mem[(32 * arg5.length) + 288] = arg3
                        mem[(32 * arg5.length) + 320] = arg2
                        mem[(32 * arg5.length) + 452] = this.address
                        mem[(32 * arg5.length) + 484] = block.timestamp + 30
                        mem[(32 * arg5.length) + 516] = 2
                        mem[(32 * arg5.length) + 548 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[(32 * arg5.length) + 548 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5399 = mem[(32 * idx) + 128]
                                            _5400 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5399)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5402 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5402:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5402) + _5400 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5633 = mem[(32 * idx) + 128]
                                            _5634 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5633)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5636 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5636:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5636) + _5634 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5637 = mem[(32 * idx) + 128]
                                        _5638 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5637)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5640 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5640:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5640) + _5638 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5393 = mem[(32 * idx) + 128]
                                            _5394 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5393)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5396 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5396:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5396) + _5394 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5625 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5625)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5628 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5628:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5625), block.timestamp, mem[mem[64] + 132 len (32 * _5628) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5629 = mem[(32 * idx) + 128]
                                        _5630 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5629)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5632 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5632:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5632) + _5630 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 420] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), msg.sender, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 'e100 bnbs and i whitelist you, contact psilva - PsilvaBo', 0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 352] = 2
                                mem[64] = (32 * arg5.length) + 448
                                mem[(32 * arg5.length) + 384] = arg2
                                mem[(32 * arg5.length) + 416] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5411 = mem[(32 * idx) + 128]
                                            _5412 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5411)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5414 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5414:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5414) + _5412 + -mem[64] + 160]
                                        else:
                                            if idx == mem[96] - 1:
                                                _5653 = mem[(32 * idx) + 128]
                                                mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = address(_5653)
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                                _5656 = mem[(32 * arg5.length) + 352]
                                                idx = 0
                                                while idx < 32 * _5656:
                                                    mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(arg1)
                                                call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, address(_5653), block.timestamp, mem[mem[64] + 132 len (32 * _5656) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            _5649 = mem[(32 * idx) + 128]
                                            _5650 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5649)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5652 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5652:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5652) + _5650 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 352] = 3
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 384] = arg8
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5405 = mem[(32 * idx) + 128]
                                            _5406 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5405)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5408 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5408:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5408) + _5406 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5641 = mem[(32 * idx) + 128]
                                            _5642 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5641)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                            _5644 = mem[(32 * arg5.length) + 352]
                                            idx = 0
                                            while idx < 32 * _5644:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5644) + _5642 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5645 = mem[(32 * idx) + 128]
                                        _5646 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5645)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 352]
                                        _5648 = mem[(32 * arg5.length) + 352]
                                        idx = 0
                                        while idx < 32 * _5648:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5648) + _5646 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                    else:
                        mem[(32 * arg5.length) + 256] = 3
                        mem[(32 * arg5.length) + 288] = arg3
                        mem[(32 * arg5.length) + 320] = arg2
                        mem[(32 * arg5.length) + 352] = arg8
                        mem[(32 * arg5.length) + 484] = this.address
                        mem[(32 * arg5.length) + 516] = block.timestamp + 30
                        mem[(32 * arg5.length) + 548] = 3
                        mem[(32 * arg5.length) + 580 len 0] = None
                        require ext_code.size(arg1)
                        call arg1.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[(32 * arg5.length) + 580 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(arg8)
                        staticcall arg8.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if arg9 != 2:
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 452] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 384] = 2
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5375 = mem[(32 * idx) + 128]
                                            _5376 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5375)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5378 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5378:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5378) + _5376 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5601 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5601)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5604 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5604:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5601), block.timestamp, mem[mem[64] + 132 len (32 * _5604) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5605 = mem[(32 * idx) + 128]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5605)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5608 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5608:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args 0, 128, address(_5605), block.timestamp, mem[mem[64] + 132 len (32 * _5608) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 384] = 3
                                mem[64] = (32 * arg5.length) + 512
                                mem[(32 * arg5.length) + 416] = arg8
                                mem[(32 * arg5.length) + 448] = arg2
                                mem[(32 * arg5.length) + 480] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5369 = mem[(32 * idx) + 128]
                                            _5370 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5369)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5372 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5372:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5372) + _5370 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5593 = mem[(32 * idx) + 128]
                                            _5594 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5593)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5596 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5596:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5596) + _5594 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5597 = mem[(32 * idx) + 128]
                                        _5598 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5597)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5600 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5600:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5600) + _5598 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            require eth.balance(this.address) / 1000 / 10000
                            if -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000 > arg6:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require ext_code.size(arg8)
                            staticcall arg8.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[(32 * arg5.length) + 452] = ext_call.return_data[0]
                            require ext_code.size(arg8)
                            call arg8.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = msg.sender
                            if bool(stor9[address(msg.sender)]) != 1:
                                revert with 0, 
                                            '',
                                            56,
                                            0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                            0
                            if arg2 == arg8:
                                mem[(32 * arg5.length) + 384] = 2
                                mem[64] = (32 * arg5.length) + 480
                                mem[(32 * arg5.length) + 416] = arg2
                                mem[(32 * arg5.length) + 448] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5387 = mem[(32 * idx) + 128]
                                            _5388 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5387)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5390 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5390:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5390) + _5388 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5617 = mem[(32 * idx) + 128]
                                            _5618 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5617)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5620 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5620:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5620) + _5618 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5621 = mem[(32 * idx) + 128]
                                        _5622 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5621)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5624 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5624:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5624) + _5622 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[(32 * arg5.length) + 384] = 3
                                mem[64] = (32 * arg5.length) + 512
                                mem[(32 * arg5.length) + 416] = arg8
                                mem[(32 * arg5.length) + 448] = arg2
                                mem[(32 * arg5.length) + 480] = arg3
                                require arg4 * arg5.length
                                sub_1ef782ba = eth.balance(this.address) / arg4 * arg5.length
                                idx = 0
                                while idx < arg5.length:
                                    s = 0
                                    t = 0
                                    while s < arg4:
                                        require idx < mem[96]
                                        if s != arg4 - 1:
                                            _5381 = mem[(32 * idx) + 128]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5381)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5384 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5384:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, address(_5381), block.timestamp, mem[mem[64] + 132 len (32 * _5384) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != mem[96] - 1:
                                            _5609 = mem[(32 * idx) + 128]
                                            _5610 = mem[64]
                                            mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = address(_5609)
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                            _5612 = mem[(32 * arg5.length) + 384]
                                            idx = 0
                                            while idx < 32 * _5612:
                                                mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(arg1)
                                            call arg1.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _5612) + _5610 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _5613 = mem[(32 * idx) + 128]
                                        _5614 = mem[64]
                                        mem[mem[64]] = 0xc57559dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = address(_5613)
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[(32 * arg5.length) + 384]
                                        _5616 = mem[(32 * arg5.length) + 384]
                                        idx = 0
                                        while idx < 32 * _5616:
                                            mem[mem[64] + idx + 164] = mem[(32 * arg5.length) + idx + 416]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(arg1)
                                        call arg1.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _5616) + _5614 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
}

function sub_c78db3f0(?) {
    mem[0] = msg.sender
    mem[32] = 8
    if bool(stor8[address(msg.sender)]) != 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    56,
                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                    mem[220 len 8]
    if bool(stor20) != 1:
        revert with 0, 'oh nao, o contrato morreu :('
    if eth.balance(this.address) <= 0:
        revert with 0, 'ja foi psojado'
    if wallets.length <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    66,
                    0x73616d69676f2c20636f6d7072617220656d20766172696173206361727465697261732073656d20636f6e6669677572617220616e74657320656820666f6461206e,
                    mem[230 len 30]
    require ext_code.size(routerAddress)
    staticcall routerAddress.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args baseTokenAddress, sub_c0b6201cAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'nem criaram o par ainda carai'
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    sub_fce62d8f = ext_call.return_data[50 len 14]
    sub_adcdc67c = ext_call.return_data[18 len 14]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] == baseTokenAddress:
        if sub_adcdc67c <= minLp:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        49,
                        0x746f20746f6b656e2074656d206d656e6f73206c6971756964657a20717565206f20736575206d696e696d6f20616d6967,
                        mem[213 len 15]
        if not mode:
            require ext_code.size(baseTokenAddress)
            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, -1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if baseTokenAddress == ETHAddress:
                mem[96] = 2
                mem[64] = 192
                mem[128] = baseTokenAddress
                mem[160] = sub_c0b6201cAddress
                require sub_43ff02f6 * wallets.length
                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                idx = 0
                while idx < wallets.length:
                    s = 0
                    t = 0
                    while s < sub_43ff02f6:
                        require idx < wallets.length
                        mem[0] = 10
                        if s != sub_43ff02f6 - 1:
                            _11347 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11347 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16629 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _16888 = mem[_16629]
                            require mem[_16629] <= 4294967296
                            require mem[_16629] + 32 <= return_data.size
                            require mem[mem[_16629] + _16629] <= 4294967296 and mem[_16629] + (32 * mem[mem[_16629] + _16629]) + 32 <= return_data.size
                            mem[_16629 + ceil32(return_data.size)] = mem[mem[_16629] + _16629]
                            _17359 = mem[_16888 + _16629]
                            idx = 0
                            while idx < 32 * _17359:
                                mem[_16629 + ceil32(return_data.size) + idx + 32] = mem[_16888 + _16629 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17359) + _16629 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        if idx != wallets.length - 1:
                            _11387 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11387 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16630 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _16890 = mem[_16630]
                            require mem[_16630] <= 4294967296
                            require mem[_16630] + 32 <= return_data.size
                            require mem[mem[_16630] + _16630] <= 4294967296 and mem[_16630] + (32 * mem[mem[_16630] + _16630]) + 32 <= return_data.size
                            mem[_16630 + ceil32(return_data.size)] = mem[mem[_16630] + _16630]
                            _17360 = mem[_16890 + _16630]
                            idx = 0
                            while idx < 32 * _17360:
                                mem[_16630 + ceil32(return_data.size) + idx + 32] = mem[_16890 + _16630 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17360) + _16630 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        _11391 = mem[64]
                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        mem[mem[64] + 68] = wallets[idx]
                        mem[mem[64] + 100] = block.timestamp
                        mem[mem[64] + 36] = 128
                        mem[mem[64] + 132] = mem[96]
                        idx = 0
                        while idx < 32 * mem[96]:
                            mem[mem[64] + idx + 164] = mem[idx + 128]
                            idx = idx + 32
                            continue 
                        require ext_code.size(routerAddress)
                        call routerAddress.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (32 * mem[96]) + _11391 + -mem[64] + 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16631 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _16892 = mem[_16631]
                        require mem[_16631] <= 4294967296
                        require mem[_16631] + 32 <= return_data.size
                        require mem[mem[_16631] + _16631] <= 4294967296 and mem[_16631] + (32 * mem[mem[_16631] + _16631]) + 32 <= return_data.size
                        mem[_16631 + ceil32(return_data.size)] = mem[mem[_16631] + _16631]
                        _17361 = mem[_16892 + _16631]
                        idx = 0
                        while idx < 32 * _17361:
                            mem[_16631 + ceil32(return_data.size) + idx + 32] = mem[_16892 + _16631 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[64] = (32 * _17361) + _16631 + ceil32(return_data.size) + 32
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
            else:
                mem[96] = 3
                mem[64] = 224
                mem[128] = ETHAddress
                mem[160] = baseTokenAddress
                mem[192] = sub_c0b6201cAddress
                require sub_43ff02f6 * wallets.length
                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                idx = 0
                while idx < wallets.length:
                    s = 0
                    t = 0
                    while s < sub_43ff02f6:
                        require idx < wallets.length
                        mem[0] = 10
                        if s != sub_43ff02f6 - 1:
                            _11343 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11343 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16626 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _16882 = mem[_16626]
                            require mem[_16626] <= 4294967296
                            require mem[_16626] + 32 <= return_data.size
                            require mem[mem[_16626] + _16626] <= 4294967296 and mem[_16626] + (32 * mem[mem[_16626] + _16626]) + 32 <= return_data.size
                            mem[_16626 + ceil32(return_data.size)] = mem[mem[_16626] + _16626]
                            _17356 = mem[_16882 + _16626]
                            idx = 0
                            while idx < 32 * _17356:
                                mem[_16626 + ceil32(return_data.size) + idx + 32] = mem[_16882 + _16626 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17356) + _16626 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        if idx != wallets.length - 1:
                            _11379 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11379 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16627 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _16884 = mem[_16627]
                            require mem[_16627] <= 4294967296
                            require mem[_16627] + 32 <= return_data.size
                            require mem[mem[_16627] + _16627] <= 4294967296 and mem[_16627] + (32 * mem[mem[_16627] + _16627]) + 32 <= return_data.size
                            mem[_16627 + ceil32(return_data.size)] = mem[mem[_16627] + _16627]
                            _17357 = mem[_16884 + _16627]
                            idx = 0
                            while idx < 32 * _17357:
                                mem[_16627 + ceil32(return_data.size) + idx + 32] = mem[_16884 + _16627 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17357) + _16627 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        _11383 = mem[64]
                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        mem[mem[64] + 68] = wallets[idx]
                        mem[mem[64] + 100] = block.timestamp
                        mem[mem[64] + 36] = 128
                        mem[mem[64] + 132] = mem[96]
                        idx = 0
                        while idx < 32 * mem[96]:
                            mem[mem[64] + idx + 164] = mem[idx + 128]
                            idx = idx + 32
                            continue 
                        require ext_code.size(routerAddress)
                        call routerAddress.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (32 * mem[96]) + _11383 + -mem[64] + 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16628 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _16886 = mem[_16628]
                        require mem[_16628] <= 4294967296
                        require mem[_16628] + 32 <= return_data.size
                        require mem[mem[_16628] + _16628] <= 4294967296 and mem[_16628] + (32 * mem[mem[_16628] + _16628]) + 32 <= return_data.size
                        mem[_16628 + ceil32(return_data.size)] = mem[mem[_16628] + _16628]
                        _17358 = mem[_16886 + _16628]
                        idx = 0
                        while idx < 32 * _17358:
                            mem[_16628 + ceil32(return_data.size) + idx + 32] = mem[_16886 + _16628 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[64] = (32 * _17358) + _16628 + ceil32(return_data.size) + 32
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
            if eth.balance(this.address) > 0:
                if bool(stor9[address(msg.sender)]) != 1:
                    revert with 0, 
                                32,
                                56,
                                0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                mem[mem[64] + 124 len 8]
                call msg.sender with:
                   value eth.balance(this.address) wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
        else:
            if mode == 1:
                require ext_code.size(ETHAddress)
                call ETHAddress.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args routerAddress, -1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(baseTokenAddress)
                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args routerAddress, -1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if baseTokenAddress == ETHAddress:
                    mem[96] = 2
                    mem[128] = baseTokenAddress
                    mem[160] = sub_c0b6201cAddress
                    mem[356 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 2, mem[356 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sub_c0b6201cAddress)
                    staticcall sub_c0b6201cAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(sub_c0b6201cAddress)
                    call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(baseTokenAddress)
                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if baseTokenAddress == ETHAddress:
                        mem[192] = 2
                        mem[224] = sub_c0b6201cAddress
                        mem[256] = baseTokenAddress
                        mem[388] = this.address
                        mem[420] = block.timestamp + 30
                        mem[452] = 2
                        mem[484 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[484 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[356] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), wallets, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[288] = 2
                                mem[64] = 384
                                mem[320] = baseTokenAddress
                                mem[352] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20915 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _20917 = mem[288]
                                            idx = 0
                                            while idx < 32 * _20917:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20917) + _20915 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24903 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25320 = mem[_24903]
                                            require mem[_24903] <= 4294967296
                                            require mem[_24903] + 32 <= return_data.size
                                            require mem[mem[_24903] + _24903] <= 4294967296 and mem[_24903] + (32 * mem[mem[_24903] + _24903]) + 32 <= return_data.size
                                            mem[_24903 + ceil32(return_data.size)] = mem[mem[_24903] + _24903]
                                            _26055 = mem[_25320 + _24903]
                                            idx = 0
                                            while idx < 32 * _26055:
                                                mem[_24903 + ceil32(return_data.size) + idx + 32] = mem[_25320 + _24903 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26055) + _24903 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21473 = mem[288]
                                            t = 0
                                            while t < 32 * _21473:
                                                mem[mem[64] + t + 164] = mem[t + 320]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21473) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24904 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25322 = mem[_24904]
                                            require mem[_24904] <= 4294967296
                                            require mem[_24904] + 32 <= return_data.size
                                            require mem[mem[_24904] + _24904] <= 4294967296 and mem[_24904] + (32 * mem[mem[_24904] + _24904]) + 32 <= return_data.size
                                            mem[_24904 + ceil32(return_data.size)] = mem[mem[_24904] + _24904]
                                            _26056 = mem[_25322 + _24904]
                                            idx = 0
                                            while idx < 32 * _26056:
                                                mem[_24904 + ceil32(return_data.size) + idx + 32] = mem[_25322 + _24904 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26056) + _24904 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21475 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[288]
                                        _21477 = mem[288]
                                        idx = 0
                                        while idx < 32 * _21477:
                                            mem[mem[64] + idx + 164] = mem[idx + 320]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21477) + _21475 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24905 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25324 = mem[_24905]
                                        require mem[_24905] <= 4294967296
                                        require mem[_24905] + 32 <= return_data.size
                                        require mem[mem[_24905] + _24905] <= 4294967296 and mem[_24905] + (32 * mem[mem[_24905] + _24905]) + 32 <= return_data.size
                                        mem[_24905 + ceil32(return_data.size)] = mem[mem[_24905] + _24905]
                                        _26057 = mem[_25324 + _24905]
                                        idx = 0
                                        while idx < 32 * _26057:
                                            mem[_24905 + ceil32(return_data.size) + idx + 32] = mem[_25324 + _24905 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26057) + _24905 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[288] = 3
                                mem[64] = 416
                                mem[320] = ETHAddress
                                mem[352] = baseTokenAddress
                                mem[384] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20911 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _20913 = mem[288]
                                            idx = 0
                                            while idx < 32 * _20913:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20913) + _20911 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24900 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25314 = mem[_24900]
                                            require mem[_24900] <= 4294967296
                                            require mem[_24900] + 32 <= return_data.size
                                            require mem[mem[_24900] + _24900] <= 4294967296 and mem[_24900] + (32 * mem[mem[_24900] + _24900]) + 32 <= return_data.size
                                            mem[_24900 + ceil32(return_data.size)] = mem[mem[_24900] + _24900]
                                            _26052 = mem[_25314 + _24900]
                                            idx = 0
                                            while idx < 32 * _26052:
                                                mem[_24900 + ceil32(return_data.size) + idx + 32] = mem[_25314 + _24900 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26052) + _24900 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21463 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21465 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21465:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21465) + _21463 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24901 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25316 = mem[_24901]
                                            require mem[_24901] <= 4294967296
                                            require mem[_24901] + 32 <= return_data.size
                                            require mem[mem[_24901] + _24901] <= 4294967296 and mem[_24901] + (32 * mem[mem[_24901] + _24901]) + 32 <= return_data.size
                                            mem[_24901 + ceil32(return_data.size)] = mem[mem[_24901] + _24901]
                                            _26053 = mem[_25316 + _24901]
                                            idx = 0
                                            while idx < 32 * _26053:
                                                mem[_24901 + ceil32(return_data.size) + idx + 32] = mem[_25316 + _24901 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26053) + _24901 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21467 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[288]
                                        _21469 = mem[288]
                                        idx = 0
                                        while idx < 32 * _21469:
                                            mem[mem[64] + idx + 164] = mem[idx + 320]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21469) + _21467 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24902 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25318 = mem[_24902]
                                        require mem[_24902] <= 4294967296
                                        require mem[_24902] + 32 <= return_data.size
                                        require mem[mem[_24902] + _24902] <= 4294967296 and mem[_24902] + (32 * mem[mem[_24902] + _24902]) + 32 <= return_data.size
                                        mem[_24902 + ceil32(return_data.size)] = mem[mem[_24902] + _24902]
                                        _26054 = mem[_25318 + _24902]
                                        idx = 0
                                        while idx < 32 * _26054:
                                            mem[_24902 + ceil32(return_data.size) + idx + 32] = mem[_25318 + _24902 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26054) + _24902 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[356] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[288] = 2
                                    mem[64] = 384
                                    mem[320] = baseTokenAddress
                                    mem[352] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20923 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _20925 = mem[288]
                                                idx = 0
                                                while idx < 32 * _20925:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20925) + _20923 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24909 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25332 = mem[_24909]
                                                require mem[_24909] <= 4294967296
                                                require mem[_24909] + 32 <= return_data.size
                                                require mem[mem[_24909] + _24909] <= 4294967296 and mem[_24909] + (32 * mem[mem[_24909] + _24909]) + 32 <= return_data.size
                                                mem[_24909 + ceil32(return_data.size)] = mem[mem[_24909] + _24909]
                                                _26061 = mem[_25332 + _24909]
                                                idx = 0
                                                while idx < 32 * _26061:
                                                    mem[_24909 + ceil32(return_data.size) + idx + 32] = mem[_25332 + _24909 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26061) + _24909 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21487 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21489 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21489:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21489) + _21487 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24910 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25334 = mem[_24910]
                                                require mem[_24910] <= 4294967296
                                                require mem[_24910] + 32 <= return_data.size
                                                require mem[mem[_24910] + _24910] <= 4294967296 and mem[_24910] + (32 * mem[mem[_24910] + _24910]) + 32 <= return_data.size
                                                mem[_24910 + ceil32(return_data.size)] = mem[mem[_24910] + _24910]
                                                _26062 = mem[_25334 + _24910]
                                                idx = 0
                                                while idx < 32 * _26062:
                                                    mem[_24910 + ceil32(return_data.size) + idx + 32] = mem[_25334 + _24910 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26062) + _24910 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21491 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21493 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21493:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21493) + _21491 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24911 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25336 = mem[_24911]
                                            require mem[_24911] <= 4294967296
                                            require mem[_24911] + 32 <= return_data.size
                                            require mem[mem[_24911] + _24911] <= 4294967296 and mem[_24911] + (32 * mem[mem[_24911] + _24911]) + 32 <= return_data.size
                                            mem[_24911 + ceil32(return_data.size)] = mem[mem[_24911] + _24911]
                                            _26063 = mem[_25336 + _24911]
                                            idx = 0
                                            while idx < 32 * _26063:
                                                mem[_24911 + ceil32(return_data.size) + idx + 32] = mem[_25336 + _24911 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26063) + _24911 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[288] = 3
                                    mem[64] = 416
                                    mem[320] = ETHAddress
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _20921 = mem[288]
                                                t = 0
                                                while t < 32 * _20921:
                                                    mem[mem[64] + t + 164] = mem[t + 320]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20921) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24906 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25326 = mem[_24906]
                                                require mem[_24906] <= 4294967296
                                                require mem[_24906] + 32 <= return_data.size
                                                require mem[mem[_24906] + _24906] <= 4294967296 and mem[_24906] + (32 * mem[mem[_24906] + _24906]) + 32 <= return_data.size
                                                mem[_24906 + ceil32(return_data.size)] = mem[mem[_24906] + _24906]
                                                _26058 = mem[_25326 + _24906]
                                                idx = 0
                                                while idx < 32 * _26058:
                                                    mem[_24906 + ceil32(return_data.size) + idx + 32] = mem[_25326 + _24906 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26058) + _24906 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21479 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21481 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21481:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21481) + _21479 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24907 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25328 = mem[_24907]
                                                require mem[_24907] <= 4294967296
                                                require mem[_24907] + 32 <= return_data.size
                                                require mem[mem[_24907] + _24907] <= 4294967296 and mem[_24907] + (32 * mem[mem[_24907] + _24907]) + 32 <= return_data.size
                                                mem[_24907 + ceil32(return_data.size)] = mem[mem[_24907] + _24907]
                                                _26059 = mem[_25328 + _24907]
                                                idx = 0
                                                while idx < 32 * _26059:
                                                    mem[_24907 + ceil32(return_data.size) + idx + 32] = mem[_25328 + _24907 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26059) + _24907 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21483 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21485 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21485:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21485) + _21483 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24908 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25330 = mem[_24908]
                                            require mem[_24908] <= 4294967296
                                            require mem[_24908] + 32 <= return_data.size
                                            require mem[mem[_24908] + _24908] <= 4294967296 and mem[_24908] + (32 * mem[mem[_24908] + _24908]) + 32 <= return_data.size
                                            mem[_24908 + ceil32(return_data.size)] = mem[mem[_24908] + _24908]
                                            _26060 = mem[_25330 + _24908]
                                            idx = 0
                                            while idx < 32 * _26060:
                                                mem[_24908 + ceil32(return_data.size) + idx + 32] = mem[_25330 + _24908 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26060) + _24908 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[356] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[288] = 2
                                    mem[64] = 384
                                    mem[320] = baseTokenAddress
                                    mem[352] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20931 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _20933 = mem[288]
                                                idx = 0
                                                while idx < 32 * _20933:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20933) + _20931 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24915 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25344 = mem[_24915]
                                                require mem[_24915] <= 4294967296
                                                require mem[_24915] + 32 <= return_data.size
                                                require mem[mem[_24915] + _24915] <= 4294967296 and mem[_24915] + (32 * mem[mem[_24915] + _24915]) + 32 <= return_data.size
                                                mem[_24915 + ceil32(return_data.size)] = mem[mem[_24915] + _24915]
                                                _26067 = mem[_25344 + _24915]
                                                idx = 0
                                                while idx < 32 * _26067:
                                                    mem[_24915 + ceil32(return_data.size) + idx + 32] = mem[_25344 + _24915 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26067) + _24915 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21505 = mem[288]
                                                t = 0
                                                while t < 32 * _21505:
                                                    mem[mem[64] + t + 164] = mem[t + 320]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21505) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24916 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25346 = mem[_24916]
                                                require mem[_24916] <= 4294967296
                                                require mem[_24916] + 32 <= return_data.size
                                                require mem[mem[_24916] + _24916] <= 4294967296 and mem[_24916] + (32 * mem[mem[_24916] + _24916]) + 32 <= return_data.size
                                                mem[_24916 + ceil32(return_data.size)] = mem[mem[_24916] + _24916]
                                                _26068 = mem[_25346 + _24916]
                                                idx = 0
                                                while idx < 32 * _26068:
                                                    mem[_24916 + ceil32(return_data.size) + idx + 32] = mem[_25346 + _24916 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26068) + _24916 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21507 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21509 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21509:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21509) + _21507 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24917 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25348 = mem[_24917]
                                            require mem[_24917] <= 4294967296
                                            require mem[_24917] + 32 <= return_data.size
                                            require mem[mem[_24917] + _24917] <= 4294967296 and mem[_24917] + (32 * mem[mem[_24917] + _24917]) + 32 <= return_data.size
                                            mem[_24917 + ceil32(return_data.size)] = mem[mem[_24917] + _24917]
                                            _26069 = mem[_25348 + _24917]
                                            idx = 0
                                            while idx < 32 * _26069:
                                                mem[_24917 + ceil32(return_data.size) + idx + 32] = mem[_25348 + _24917 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26069) + _24917 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[288] = 3
                                    mem[64] = 416
                                    mem[320] = ETHAddress
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20927 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _20929 = mem[288]
                                                idx = 0
                                                while idx < 32 * _20929:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20929) + _20927 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24912 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25338 = mem[_24912]
                                                require mem[_24912] <= 4294967296
                                                require mem[_24912] + 32 <= return_data.size
                                                require mem[mem[_24912] + _24912] <= 4294967296 and mem[_24912] + (32 * mem[mem[_24912] + _24912]) + 32 <= return_data.size
                                                mem[_24912 + ceil32(return_data.size)] = mem[mem[_24912] + _24912]
                                                _26064 = mem[_25338 + _24912]
                                                idx = 0
                                                while idx < 32 * _26064:
                                                    mem[_24912 + ceil32(return_data.size) + idx + 32] = mem[_25338 + _24912 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26064) + _24912 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21495 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21497 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21497:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21497) + _21495 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24913 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25340 = mem[_24913]
                                                require mem[_24913] <= 4294967296
                                                require mem[_24913] + 32 <= return_data.size
                                                require mem[mem[_24913] + _24913] <= 4294967296 and mem[_24913] + (32 * mem[mem[_24913] + _24913]) + 32 <= return_data.size
                                                mem[_24913 + ceil32(return_data.size)] = mem[mem[_24913] + _24913]
                                                _26065 = mem[_25340 + _24913]
                                                idx = 0
                                                while idx < 32 * _26065:
                                                    mem[_24913 + ceil32(return_data.size) + idx + 32] = mem[_25340 + _24913 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26065) + _24913 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21499 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21501 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21501:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21501) + _21499 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24914 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25342 = mem[_24914]
                                            require mem[_24914] <= 4294967296
                                            require mem[_24914] + 32 <= return_data.size
                                            require mem[mem[_24914] + _24914] <= 4294967296 and mem[_24914] + (32 * mem[mem[_24914] + _24914]) + 32 <= return_data.size
                                            mem[_24914 + ceil32(return_data.size)] = mem[mem[_24914] + _24914]
                                            _26066 = mem[_25342 + _24914]
                                            idx = 0
                                            while idx < 32 * _26066:
                                                mem[_24914 + ceil32(return_data.size) + idx + 32] = mem[_25342 + _24914 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26066) + _24914 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                    else:
                        mem[192] = 3
                        mem[224] = sub_c0b6201cAddress
                        mem[256] = baseTokenAddress
                        mem[288] = ETHAddress
                        mem[420] = this.address
                        mem[452] = block.timestamp + 30
                        mem[484] = 3
                        mem[516 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[516 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[388] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, wallets, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, 0, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[320] = 2
                                mem[64] = 416
                                mem[352] = baseTokenAddress
                                mem[384] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20891 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _20893 = mem[320]
                                            idx = 0
                                            while idx < 32 * _20893:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20893) + _20891 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24885 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25284 = mem[_24885]
                                            require mem[_24885] <= 4294967296
                                            require mem[_24885] + 32 <= return_data.size
                                            require mem[mem[_24885] + _24885] <= 4294967296 and mem[_24885] + (32 * mem[mem[_24885] + _24885]) + 32 <= return_data.size
                                            mem[_24885 + ceil32(return_data.size)] = mem[mem[_24885] + _24885]
                                            _26037 = mem[_25284 + _24885]
                                            idx = 0
                                            while idx < 32 * _26037:
                                                mem[_24885 + ceil32(return_data.size) + idx + 32] = mem[_25284 + _24885 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26037) + _24885 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21423 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21425 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21425:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21425) + _21423 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24886 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25286 = mem[_24886]
                                            require mem[_24886] <= 4294967296
                                            require mem[_24886] + 32 <= return_data.size
                                            require mem[mem[_24886] + _24886] <= 4294967296 and mem[_24886] + (32 * mem[mem[_24886] + _24886]) + 32 <= return_data.size
                                            mem[_24886 + ceil32(return_data.size)] = mem[mem[_24886] + _24886]
                                            _26038 = mem[_25286 + _24886]
                                            idx = 0
                                            while idx < 32 * _26038:
                                                mem[_24886 + ceil32(return_data.size) + idx + 32] = mem[_25286 + _24886 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26038) + _24886 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21427 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21429 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21429:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21429) + _21427 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24887 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25288 = mem[_24887]
                                        require mem[_24887] <= 4294967296
                                        require mem[_24887] + 32 <= return_data.size
                                        require mem[mem[_24887] + _24887] <= 4294967296 and mem[_24887] + (32 * mem[mem[_24887] + _24887]) + 32 <= return_data.size
                                        mem[_24887 + ceil32(return_data.size)] = mem[mem[_24887] + _24887]
                                        _26039 = mem[_25288 + _24887]
                                        idx = 0
                                        while idx < 32 * _26039:
                                            mem[_24887 + ceil32(return_data.size) + idx + 32] = mem[_25288 + _24887 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26039) + _24887 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[320] = 3
                                mem[64] = 448
                                mem[352] = ETHAddress
                                mem[384] = baseTokenAddress
                                mem[416] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20887 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _20889 = mem[320]
                                            idx = 0
                                            while idx < 32 * _20889:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20889) + _20887 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24882 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25278 = mem[_24882]
                                            require mem[_24882] <= 4294967296
                                            require mem[_24882] + 32 <= return_data.size
                                            require mem[mem[_24882] + _24882] <= 4294967296 and mem[_24882] + (32 * mem[mem[_24882] + _24882]) + 32 <= return_data.size
                                            mem[_24882 + ceil32(return_data.size)] = mem[mem[_24882] + _24882]
                                            _26034 = mem[_25278 + _24882]
                                            idx = 0
                                            while idx < 32 * _26034:
                                                mem[_24882 + ceil32(return_data.size) + idx + 32] = mem[_25278 + _24882 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26034) + _24882 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21415 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21417 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21417:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21417) + _21415 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24883 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25280 = mem[_24883]
                                            require mem[_24883] <= 4294967296
                                            require mem[_24883] + 32 <= return_data.size
                                            require mem[mem[_24883] + _24883] <= 4294967296 and mem[_24883] + (32 * mem[mem[_24883] + _24883]) + 32 <= return_data.size
                                            mem[_24883 + ceil32(return_data.size)] = mem[mem[_24883] + _24883]
                                            _26035 = mem[_25280 + _24883]
                                            idx = 0
                                            while idx < 32 * _26035:
                                                mem[_24883 + ceil32(return_data.size) + idx + 32] = mem[_25280 + _24883 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26035) + _24883 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21419 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21421 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21421:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21421) + _21419 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24884 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25282 = mem[_24884]
                                        require mem[_24884] <= 4294967296
                                        require mem[_24884] + 32 <= return_data.size
                                        require mem[mem[_24884] + _24884] <= 4294967296 and mem[_24884] + (32 * mem[mem[_24884] + _24884]) + 32 <= return_data.size
                                        mem[_24884 + ceil32(return_data.size)] = mem[mem[_24884] + _24884]
                                        _26036 = mem[_25282 + _24884]
                                        idx = 0
                                        while idx < 32 * _26036:
                                            mem[_24884 + ceil32(return_data.size) + idx + 32] = mem[_25282 + _24884 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26036) + _24884 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20899 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20901 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20901:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20901) + _20899 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24891 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25296 = mem[_24891]
                                                require mem[_24891] <= 4294967296
                                                require mem[_24891] + 32 <= return_data.size
                                                require mem[mem[_24891] + _24891] <= 4294967296 and mem[_24891] + (32 * mem[mem[_24891] + _24891]) + 32 <= return_data.size
                                                mem[_24891 + ceil32(return_data.size)] = mem[mem[_24891] + _24891]
                                                _26043 = mem[_25296 + _24891]
                                                idx = 0
                                                while idx < 32 * _26043:
                                                    mem[_24891 + ceil32(return_data.size) + idx + 32] = mem[_25296 + _24891 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26043) + _24891 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21439 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21441 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21441:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21441) + _21439 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24892 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25298 = mem[_24892]
                                                require mem[_24892] <= 4294967296
                                                require mem[_24892] + 32 <= return_data.size
                                                require mem[mem[_24892] + _24892] <= 4294967296 and mem[_24892] + (32 * mem[mem[_24892] + _24892]) + 32 <= return_data.size
                                                mem[_24892 + ceil32(return_data.size)] = mem[mem[_24892] + _24892]
                                                _26044 = mem[_25298 + _24892]
                                                idx = 0
                                                while idx < 32 * _26044:
                                                    mem[_24892 + ceil32(return_data.size) + idx + 32] = mem[_25298 + _24892 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26044) + _24892 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21443 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21445 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21445:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21445) + _21443 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24893 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25300 = mem[_24893]
                                            require mem[_24893] <= 4294967296
                                            require mem[_24893] + 32 <= return_data.size
                                            require mem[mem[_24893] + _24893] <= 4294967296 and mem[_24893] + (32 * mem[mem[_24893] + _24893]) + 32 <= return_data.size
                                            mem[_24893 + ceil32(return_data.size)] = mem[mem[_24893] + _24893]
                                            _26045 = mem[_25300 + _24893]
                                            idx = 0
                                            while idx < 32 * _26045:
                                                mem[_24893 + ceil32(return_data.size) + idx + 32] = mem[_25300 + _24893 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26045) + _24893 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20895 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20897 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20897:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20897) + _20895 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24888 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25290 = mem[_24888]
                                                require mem[_24888] <= 4294967296
                                                require mem[_24888] + 32 <= return_data.size
                                                require mem[mem[_24888] + _24888] <= 4294967296 and mem[_24888] + (32 * mem[mem[_24888] + _24888]) + 32 <= return_data.size
                                                mem[_24888 + ceil32(return_data.size)] = mem[mem[_24888] + _24888]
                                                _26040 = mem[_25290 + _24888]
                                                idx = 0
                                                while idx < 32 * _26040:
                                                    mem[_24888 + ceil32(return_data.size) + idx + 32] = mem[_25290 + _24888 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26040) + _24888 + ceil32(return_data.size) + 32
                                            else:
                                                if idx == wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21437 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21437:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value eth.balance(this.address) wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21437) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24890 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25294 = mem[_24890]
                                                    require mem[_24890] <= 4294967296
                                                    require mem[_24890] + 32 <= return_data.size
                                                    require mem[mem[_24890] + _24890] <= 4294967296 and mem[_24890] + (32 * mem[mem[_24890] + _24890]) + 32 <= return_data.size
                                                    mem[_24890 + ceil32(return_data.size)] = mem[mem[_24890] + _24890]
                                                    _26042 = mem[_25294 + _24890]
                                                    idx = 0
                                                    while idx < 32 * _26042:
                                                        mem[_24890 + ceil32(return_data.size) + idx + 32] = mem[_25294 + _24890 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26042) + _24890 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = eth.balance(this.address)
                                                    continue 
                                                _21431 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21433 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21433:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21433) + _21431 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24889 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25292 = mem[_24889]
                                                require mem[_24889] <= 4294967296
                                                require mem[_24889] + 32 <= return_data.size
                                                require mem[mem[_24889] + _24889] <= 4294967296 and mem[_24889] + (32 * mem[mem[_24889] + _24889]) + 32 <= return_data.size
                                                mem[_24889 + ceil32(return_data.size)] = mem[mem[_24889] + _24889]
                                                _26041 = mem[_25292 + _24889]
                                                idx = 0
                                                while idx < 32 * _26041:
                                                    mem[_24889 + ceil32(return_data.size) + idx + 32] = mem[_25292 + _24889 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26041) + _24889 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20907 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20909 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20909:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20909) + _20907 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24897 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25308 = mem[_24897]
                                                require mem[_24897] <= 4294967296
                                                require mem[_24897] + 32 <= return_data.size
                                                require mem[mem[_24897] + _24897] <= 4294967296 and mem[_24897] + (32 * mem[mem[_24897] + _24897]) + 32 <= return_data.size
                                                mem[_24897 + ceil32(return_data.size)] = mem[mem[_24897] + _24897]
                                                _26049 = mem[_25308 + _24897]
                                                idx = 0
                                                while idx < 32 * _26049:
                                                    mem[_24897 + ceil32(return_data.size) + idx + 32] = mem[_25308 + _24897 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26049) + _24897 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21455 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21457 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21457:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21457) + _21455 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24898 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25310 = mem[_24898]
                                                require mem[_24898] <= 4294967296
                                                require mem[_24898] + 32 <= return_data.size
                                                require mem[mem[_24898] + _24898] <= 4294967296 and mem[_24898] + (32 * mem[mem[_24898] + _24898]) + 32 <= return_data.size
                                                mem[_24898 + ceil32(return_data.size)] = mem[mem[_24898] + _24898]
                                                _26050 = mem[_25310 + _24898]
                                                idx = 0
                                                while idx < 32 * _26050:
                                                    mem[_24898 + ceil32(return_data.size) + idx + 32] = mem[_25310 + _24898 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26050) + _24898 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21459 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21461 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21461:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21461) + _21459 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24899 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25312 = mem[_24899]
                                            require mem[_24899] <= 4294967296
                                            require mem[_24899] + 32 <= return_data.size
                                            require mem[mem[_24899] + _24899] <= 4294967296 and mem[_24899] + (32 * mem[mem[_24899] + _24899]) + 32 <= return_data.size
                                            mem[_24899 + ceil32(return_data.size)] = mem[mem[_24899] + _24899]
                                            _26051 = mem[_25312 + _24899]
                                            idx = 0
                                            while idx < 32 * _26051:
                                                mem[_24899 + ceil32(return_data.size) + idx + 32] = mem[_25312 + _24899 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26051) + _24899 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20903 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20905 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20905:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20905) + _20903 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24894 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25302 = mem[_24894]
                                                require mem[_24894] <= 4294967296
                                                require mem[_24894] + 32 <= return_data.size
                                                require mem[mem[_24894] + _24894] <= 4294967296 and mem[_24894] + (32 * mem[mem[_24894] + _24894]) + 32 <= return_data.size
                                                mem[_24894 + ceil32(return_data.size)] = mem[mem[_24894] + _24894]
                                                _26046 = mem[_25302 + _24894]
                                                idx = 0
                                                while idx < 32 * _26046:
                                                    mem[_24894 + ceil32(return_data.size) + idx + 32] = mem[_25302 + _24894 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26046) + _24894 + ceil32(return_data.size) + 32
                                            else:
                                                if idx == wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21453 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21453:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value eth.balance(this.address) wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21453) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24896 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25306 = mem[_24896]
                                                    require mem[_24896] <= 4294967296
                                                    require mem[_24896] + 32 <= return_data.size
                                                    require mem[mem[_24896] + _24896] <= 4294967296 and mem[_24896] + (32 * mem[mem[_24896] + _24896]) + 32 <= return_data.size
                                                    mem[_24896 + ceil32(return_data.size)] = mem[mem[_24896] + _24896]
                                                    _26048 = mem[_25306 + _24896]
                                                    idx = 0
                                                    while idx < 32 * _26048:
                                                        mem[_24896 + ceil32(return_data.size) + idx + 32] = mem[_25306 + _24896 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26048) + _24896 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = eth.balance(this.address)
                                                    continue 
                                                _21447 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21449 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21449:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21449) + _21447 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24895 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25304 = mem[_24895]
                                                require mem[_24895] <= 4294967296
                                                require mem[_24895] + 32 <= return_data.size
                                                require mem[mem[_24895] + _24895] <= 4294967296 and mem[_24895] + (32 * mem[mem[_24895] + _24895]) + 32 <= return_data.size
                                                mem[_24895 + ceil32(return_data.size)] = mem[mem[_24895] + _24895]
                                                _26047 = mem[_25304 + _24895]
                                                idx = 0
                                                while idx < 32 * _26047:
                                                    mem[_24895 + ceil32(return_data.size) + idx + 32] = mem[_25304 + _24895 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26047) + _24895 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        idx = idx + 1
                                        continue 
                else:
                    mem[96] = 3
                    mem[128] = ETHAddress
                    mem[160] = baseTokenAddress
                    mem[192] = sub_c0b6201cAddress
                    mem[388 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 3, mem[388 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sub_c0b6201cAddress)
                    staticcall sub_c0b6201cAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(sub_c0b6201cAddress)
                    call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(baseTokenAddress)
                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if baseTokenAddress == ETHAddress:
                        mem[224] = 2
                        mem[256] = sub_c0b6201cAddress
                        mem[288] = baseTokenAddress
                        mem[420] = this.address
                        mem[452] = block.timestamp + 30
                        mem[484] = 2
                        mem[516 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[516 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[388] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), wallets, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[320] = 2
                                mem[64] = 416
                                mem[352] = baseTokenAddress
                                mem[384] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20867 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _20869 = mem[320]
                                            idx = 0
                                            while idx < 32 * _20869:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20869) + _20867 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24867 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25248 = mem[_24867]
                                            require mem[_24867] <= 4294967296
                                            require mem[_24867] + 32 <= return_data.size
                                            require mem[mem[_24867] + _24867] <= 4294967296 and mem[_24867] + (32 * mem[mem[_24867] + _24867]) + 32 <= return_data.size
                                            mem[_24867 + ceil32(return_data.size)] = mem[mem[_24867] + _24867]
                                            _26019 = mem[_25248 + _24867]
                                            idx = 0
                                            while idx < 32 * _26019:
                                                mem[_24867 + ceil32(return_data.size) + idx + 32] = mem[_25248 + _24867 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26019) + _24867 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21375 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21377 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21377:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21377) + _21375 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24868 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25250 = mem[_24868]
                                            require mem[_24868] <= 4294967296
                                            require mem[_24868] + 32 <= return_data.size
                                            require mem[mem[_24868] + _24868] <= 4294967296 and mem[_24868] + (32 * mem[mem[_24868] + _24868]) + 32 <= return_data.size
                                            mem[_24868 + ceil32(return_data.size)] = mem[mem[_24868] + _24868]
                                            _26020 = mem[_25250 + _24868]
                                            idx = 0
                                            while idx < 32 * _26020:
                                                mem[_24868 + ceil32(return_data.size) + idx + 32] = mem[_25250 + _24868 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26020) + _24868 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21379 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21381 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21381:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21381) + _21379 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24869 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25252 = mem[_24869]
                                        require mem[_24869] <= 4294967296
                                        require mem[_24869] + 32 <= return_data.size
                                        require mem[mem[_24869] + _24869] <= 4294967296 and mem[_24869] + (32 * mem[mem[_24869] + _24869]) + 32 <= return_data.size
                                        mem[_24869 + ceil32(return_data.size)] = mem[mem[_24869] + _24869]
                                        _26021 = mem[_25252 + _24869]
                                        idx = 0
                                        while idx < 32 * _26021:
                                            mem[_24869 + ceil32(return_data.size) + idx + 32] = mem[_25252 + _24869 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26021) + _24869 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[320] = 3
                                mem[64] = 448
                                mem[352] = ETHAddress
                                mem[384] = baseTokenAddress
                                mem[416] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _20865 = mem[320]
                                            t = 0
                                            while t < 32 * _20865:
                                                mem[mem[64] + t + 164] = mem[t + 352]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20865) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24864 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25242 = mem[_24864]
                                            require mem[_24864] <= 4294967296
                                            require mem[_24864] + 32 <= return_data.size
                                            require mem[mem[_24864] + _24864] <= 4294967296 and mem[_24864] + (32 * mem[mem[_24864] + _24864]) + 32 <= return_data.size
                                            mem[_24864 + ceil32(return_data.size)] = mem[mem[_24864] + _24864]
                                            _26016 = mem[_25242 + _24864]
                                            idx = 0
                                            while idx < 32 * _26016:
                                                mem[_24864 + ceil32(return_data.size) + idx + 32] = mem[_25242 + _24864 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26016) + _24864 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21367 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21369 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21369:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21369) + _21367 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24865 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25244 = mem[_24865]
                                            require mem[_24865] <= 4294967296
                                            require mem[_24865] + 32 <= return_data.size
                                            require mem[mem[_24865] + _24865] <= 4294967296 and mem[_24865] + (32 * mem[mem[_24865] + _24865]) + 32 <= return_data.size
                                            mem[_24865 + ceil32(return_data.size)] = mem[mem[_24865] + _24865]
                                            _26017 = mem[_25244 + _24865]
                                            idx = 0
                                            while idx < 32 * _26017:
                                                mem[_24865 + ceil32(return_data.size) + idx + 32] = mem[_25244 + _24865 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26017) + _24865 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21371 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21373 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21373:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21373) + _21371 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24866 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25246 = mem[_24866]
                                        require mem[_24866] <= 4294967296
                                        require mem[_24866] + 32 <= return_data.size
                                        require mem[mem[_24866] + _24866] <= 4294967296 and mem[_24866] + (32 * mem[mem[_24866] + _24866]) + 32 <= return_data.size
                                        mem[_24866 + ceil32(return_data.size)] = mem[mem[_24866] + _24866]
                                        _26018 = mem[_25246 + _24866]
                                        idx = 0
                                        while idx < 32 * _26018:
                                            mem[_24866 + ceil32(return_data.size) + idx + 32] = mem[_25246 + _24866 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26018) + _24866 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20875 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20877 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20877:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20877) + _20875 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24873 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25260 = mem[_24873]
                                                require mem[_24873] <= 4294967296
                                                require mem[_24873] + 32 <= return_data.size
                                                require mem[mem[_24873] + _24873] <= 4294967296 and mem[_24873] + (32 * mem[mem[_24873] + _24873]) + 32 <= return_data.size
                                                mem[_24873 + ceil32(return_data.size)] = mem[mem[_24873] + _24873]
                                                _26025 = mem[_25260 + _24873]
                                                idx = 0
                                                while idx < 32 * _26025:
                                                    mem[_24873 + ceil32(return_data.size) + idx + 32] = mem[_25260 + _24873 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26025) + _24873 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21393 = mem[320]
                                                t = 0
                                                while t < 32 * _21393:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21393) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24874 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25262 = mem[_24874]
                                                require mem[_24874] <= 4294967296
                                                require mem[_24874] + 32 <= return_data.size
                                                require mem[mem[_24874] + _24874] <= 4294967296 and mem[_24874] + (32 * mem[mem[_24874] + _24874]) + 32 <= return_data.size
                                                mem[_24874 + ceil32(return_data.size)] = mem[mem[_24874] + _24874]
                                                _26026 = mem[_25262 + _24874]
                                                idx = 0
                                                while idx < 32 * _26026:
                                                    mem[_24874 + ceil32(return_data.size) + idx + 32] = mem[_25262 + _24874 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26026) + _24874 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21395 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21397 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21397:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21397) + _21395 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24875 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25264 = mem[_24875]
                                            require mem[_24875] <= 4294967296
                                            require mem[_24875] + 32 <= return_data.size
                                            require mem[mem[_24875] + _24875] <= 4294967296 and mem[_24875] + (32 * mem[mem[_24875] + _24875]) + 32 <= return_data.size
                                            mem[_24875 + ceil32(return_data.size)] = mem[mem[_24875] + _24875]
                                            _26027 = mem[_25264 + _24875]
                                            idx = 0
                                            while idx < 32 * _26027:
                                                mem[_24875 + ceil32(return_data.size) + idx + 32] = mem[_25264 + _24875 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26027) + _24875 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20873 = mem[320]
                                                t = 0
                                                while t < 32 * _20873:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20873) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24870 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25254 = mem[_24870]
                                                require mem[_24870] <= 4294967296
                                                require mem[_24870] + 32 <= return_data.size
                                                require mem[mem[_24870] + _24870] <= 4294967296 and mem[_24870] + (32 * mem[mem[_24870] + _24870]) + 32 <= return_data.size
                                                mem[_24870 + ceil32(return_data.size)] = mem[mem[_24870] + _24870]
                                                _26022 = mem[_25254 + _24870]
                                                idx = 0
                                                while idx < 32 * _26022:
                                                    mem[_24870 + ceil32(return_data.size) + idx + 32] = mem[_25254 + _24870 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26022) + _24870 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21383 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21385 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21385:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21385) + _21383 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24871 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25256 = mem[_24871]
                                                require mem[_24871] <= 4294967296
                                                require mem[_24871] + 32 <= return_data.size
                                                require mem[mem[_24871] + _24871] <= 4294967296 and mem[_24871] + (32 * mem[mem[_24871] + _24871]) + 32 <= return_data.size
                                                mem[_24871 + ceil32(return_data.size)] = mem[mem[_24871] + _24871]
                                                _26023 = mem[_25256 + _24871]
                                                idx = 0
                                                while idx < 32 * _26023:
                                                    mem[_24871 + ceil32(return_data.size) + idx + 32] = mem[_25256 + _24871 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26023) + _24871 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21387 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21389 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21389:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21389) + _21387 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24872 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25258 = mem[_24872]
                                            require mem[_24872] <= 4294967296
                                            require mem[_24872] + 32 <= return_data.size
                                            require mem[mem[_24872] + _24872] <= 4294967296 and mem[_24872] + (32 * mem[mem[_24872] + _24872]) + 32 <= return_data.size
                                            mem[_24872 + ceil32(return_data.size)] = mem[mem[_24872] + _24872]
                                            _26024 = mem[_25258 + _24872]
                                            idx = 0
                                            while idx < 32 * _26024:
                                                mem[_24872 + ceil32(return_data.size) + idx + 32] = mem[_25258 + _24872 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26024) + _24872 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20883 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20885 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20885:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20885) + _20883 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24879 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25272 = mem[_24879]
                                                require mem[_24879] <= 4294967296
                                                require mem[_24879] + 32 <= return_data.size
                                                require mem[mem[_24879] + _24879] <= 4294967296 and mem[_24879] + (32 * mem[mem[_24879] + _24879]) + 32 <= return_data.size
                                                mem[_24879 + ceil32(return_data.size)] = mem[mem[_24879] + _24879]
                                                _26031 = mem[_25272 + _24879]
                                                idx = 0
                                                while idx < 32 * _26031:
                                                    mem[_24879 + ceil32(return_data.size) + idx + 32] = mem[_25272 + _24879 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26031) + _24879 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21407 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21409 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21409:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21409) + _21407 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24880 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25274 = mem[_24880]
                                                require mem[_24880] <= 4294967296
                                                require mem[_24880] + 32 <= return_data.size
                                                require mem[mem[_24880] + _24880] <= 4294967296 and mem[_24880] + (32 * mem[mem[_24880] + _24880]) + 32 <= return_data.size
                                                mem[_24880 + ceil32(return_data.size)] = mem[mem[_24880] + _24880]
                                                _26032 = mem[_25274 + _24880]
                                                idx = 0
                                                while idx < 32 * _26032:
                                                    mem[_24880 + ceil32(return_data.size) + idx + 32] = mem[_25274 + _24880 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26032) + _24880 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21411 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21413 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21413:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21413) + _21411 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24881 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25276 = mem[_24881]
                                            require mem[_24881] <= 4294967296
                                            require mem[_24881] + 32 <= return_data.size
                                            require mem[mem[_24881] + _24881] <= 4294967296 and mem[_24881] + (32 * mem[mem[_24881] + _24881]) + 32 <= return_data.size
                                            mem[_24881 + ceil32(return_data.size)] = mem[mem[_24881] + _24881]
                                            _26033 = mem[_25276 + _24881]
                                            idx = 0
                                            while idx < 32 * _26033:
                                                mem[_24881 + ceil32(return_data.size) + idx + 32] = mem[_25276 + _24881 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26033) + _24881 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20879 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20881 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20881:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20881) + _20879 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24876 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25266 = mem[_24876]
                                                require mem[_24876] <= 4294967296
                                                require mem[_24876] + 32 <= return_data.size
                                                require mem[mem[_24876] + _24876] <= 4294967296 and mem[_24876] + (32 * mem[mem[_24876] + _24876]) + 32 <= return_data.size
                                                mem[_24876 + ceil32(return_data.size)] = mem[mem[_24876] + _24876]
                                                _26028 = mem[_25266 + _24876]
                                                idx = 0
                                                while idx < 32 * _26028:
                                                    mem[_24876 + ceil32(return_data.size) + idx + 32] = mem[_25266 + _24876 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26028) + _24876 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21399 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21401 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21401:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21401) + _21399 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24877 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25268 = mem[_24877]
                                                require mem[_24877] <= 4294967296
                                                require mem[_24877] + 32 <= return_data.size
                                                require mem[mem[_24877] + _24877] <= 4294967296 and mem[_24877] + (32 * mem[mem[_24877] + _24877]) + 32 <= return_data.size
                                                mem[_24877 + ceil32(return_data.size)] = mem[mem[_24877] + _24877]
                                                _26029 = mem[_25268 + _24877]
                                                idx = 0
                                                while idx < 32 * _26029:
                                                    mem[_24877 + ceil32(return_data.size) + idx + 32] = mem[_25268 + _24877 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26029) + _24877 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21403 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21405 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21405:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21405) + _21403 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24878 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25270 = mem[_24878]
                                            require mem[_24878] <= 4294967296
                                            require mem[_24878] + 32 <= return_data.size
                                            require mem[mem[_24878] + _24878] <= 4294967296 and mem[_24878] + (32 * mem[mem[_24878] + _24878]) + 32 <= return_data.size
                                            mem[_24878 + ceil32(return_data.size)] = mem[mem[_24878] + _24878]
                                            _26030 = mem[_25270 + _24878]
                                            idx = 0
                                            while idx < 32 * _26030:
                                                mem[_24878 + ceil32(return_data.size) + idx + 32] = mem[_25270 + _24878 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26030) + _24878 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                    else:
                        mem[224] = 3
                        mem[256] = sub_c0b6201cAddress
                        mem[288] = baseTokenAddress
                        mem[320] = ETHAddress
                        mem[452] = this.address
                        mem[484] = block.timestamp + 30
                        mem[516] = 3
                        mem[548 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[548 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[420] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, wallets, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, 0, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[352] = 2
                                mem[64] = 448
                                mem[384] = baseTokenAddress
                                mem[416] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20843 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _20845 = mem[352]
                                            idx = 0
                                            while idx < 32 * _20845:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20845) + _20843 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24849 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25212 = mem[_24849]
                                            require mem[_24849] <= 4294967296
                                            require mem[_24849] + 32 <= return_data.size
                                            require mem[mem[_24849] + _24849] <= 4294967296 and mem[_24849] + (32 * mem[mem[_24849] + _24849]) + 32 <= return_data.size
                                            mem[_24849 + ceil32(return_data.size)] = mem[mem[_24849] + _24849]
                                            _26001 = mem[_25212 + _24849]
                                            idx = 0
                                            while idx < 32 * _26001:
                                                mem[_24849 + ceil32(return_data.size) + idx + 32] = mem[_25212 + _24849 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26001) + _24849 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21329 = mem[352]
                                            t = 0
                                            while t < 32 * _21329:
                                                mem[mem[64] + t + 164] = mem[t + 384]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21329) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24850 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25214 = mem[_24850]
                                            require mem[_24850] <= 4294967296
                                            require mem[_24850] + 32 <= return_data.size
                                            require mem[mem[_24850] + _24850] <= 4294967296 and mem[_24850] + (32 * mem[mem[_24850] + _24850]) + 32 <= return_data.size
                                            mem[_24850 + ceil32(return_data.size)] = mem[mem[_24850] + _24850]
                                            _26002 = mem[_25214 + _24850]
                                            idx = 0
                                            while idx < 32 * _26002:
                                                mem[_24850 + ceil32(return_data.size) + idx + 32] = mem[_25214 + _24850 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26002) + _24850 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21331 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[352]
                                        _21333 = mem[352]
                                        idx = 0
                                        while idx < 32 * _21333:
                                            mem[mem[64] + idx + 164] = mem[idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21333) + _21331 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24851 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25216 = mem[_24851]
                                        require mem[_24851] <= 4294967296
                                        require mem[_24851] + 32 <= return_data.size
                                        require mem[mem[_24851] + _24851] <= 4294967296 and mem[_24851] + (32 * mem[mem[_24851] + _24851]) + 32 <= return_data.size
                                        mem[_24851 + ceil32(return_data.size)] = mem[mem[_24851] + _24851]
                                        _26003 = mem[_25216 + _24851]
                                        idx = 0
                                        while idx < 32 * _26003:
                                            mem[_24851 + ceil32(return_data.size) + idx + 32] = mem[_25216 + _24851 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26003) + _24851 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[352] = 3
                                mem[64] = 480
                                mem[384] = ETHAddress
                                mem[416] = baseTokenAddress
                                mem[448] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _20839 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _20841 = mem[352]
                                            idx = 0
                                            while idx < 32 * _20841:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _20841) + _20839 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24846 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25206 = mem[_24846]
                                            require mem[_24846] <= 4294967296
                                            require mem[_24846] + 32 <= return_data.size
                                            require mem[mem[_24846] + _24846] <= 4294967296 and mem[_24846] + (32 * mem[mem[_24846] + _24846]) + 32 <= return_data.size
                                            mem[_24846 + ceil32(return_data.size)] = mem[mem[_24846] + _24846]
                                            _25998 = mem[_25206 + _24846]
                                            idx = 0
                                            while idx < 32 * _25998:
                                                mem[_24846 + ceil32(return_data.size) + idx + 32] = mem[_25206 + _24846 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25998) + _24846 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21319 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21321 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21321:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21321) + _21319 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24847 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25208 = mem[_24847]
                                            require mem[_24847] <= 4294967296
                                            require mem[_24847] + 32 <= return_data.size
                                            require mem[mem[_24847] + _24847] <= 4294967296 and mem[_24847] + (32 * mem[mem[_24847] + _24847]) + 32 <= return_data.size
                                            mem[_24847 + ceil32(return_data.size)] = mem[mem[_24847] + _24847]
                                            _25999 = mem[_25208 + _24847]
                                            idx = 0
                                            while idx < 32 * _25999:
                                                mem[_24847 + ceil32(return_data.size) + idx + 32] = mem[_25208 + _24847 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25999) + _24847 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21323 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[352]
                                        _21325 = mem[352]
                                        idx = 0
                                        while idx < 32 * _21325:
                                            mem[mem[64] + idx + 164] = mem[idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21325) + _21323 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24848 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25210 = mem[_24848]
                                        require mem[_24848] <= 4294967296
                                        require mem[_24848] + 32 <= return_data.size
                                        require mem[mem[_24848] + _24848] <= 4294967296 and mem[_24848] + (32 * mem[mem[_24848] + _24848]) + 32 <= return_data.size
                                        mem[_24848 + ceil32(return_data.size)] = mem[mem[_24848] + _24848]
                                        _26000 = mem[_25210 + _24848]
                                        idx = 0
                                        while idx < 32 * _26000:
                                            mem[_24848 + ceil32(return_data.size) + idx + 32] = mem[_25210 + _24848 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26000) + _24848 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[420] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[352] = 2
                                    mem[64] = 448
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20851 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20853 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20853:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20853) + _20851 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24855 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25224 = mem[_24855]
                                                require mem[_24855] <= 4294967296
                                                require mem[_24855] + 32 <= return_data.size
                                                require mem[mem[_24855] + _24855] <= 4294967296 and mem[_24855] + (32 * mem[mem[_24855] + _24855]) + 32 <= return_data.size
                                                mem[_24855 + ceil32(return_data.size)] = mem[mem[_24855] + _24855]
                                                _26007 = mem[_25224 + _24855]
                                                idx = 0
                                                while idx < 32 * _26007:
                                                    mem[_24855 + ceil32(return_data.size) + idx + 32] = mem[_25224 + _24855 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26007) + _24855 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            if idx != wallets.length - 1:
                                                _21345 = mem[352]
                                                t = 0
                                                while t < 32 * _21345:
                                                    mem[mem[64] + t + 164] = mem[t + 384]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21345) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24856 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25226 = mem[_24856]
                                                require mem[_24856] <= 4294967296
                                                require mem[_24856] + 32 <= return_data.size
                                                require mem[mem[_24856] + _24856] <= 4294967296 and mem[_24856] + (32 * mem[mem[_24856] + _24856]) + 32 <= return_data.size
                                                mem[_24856 + ceil32(return_data.size)] = mem[mem[_24856] + _24856]
                                                _26008 = mem[_25226 + _24856]
                                                idx = 0
                                                while idx < 32 * _26008:
                                                    mem[_24856 + ceil32(return_data.size) + idx + 32] = mem[_25226 + _24856 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26008) + _24856 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21349 = mem[352]
                                            t = 0
                                            while t < 32 * _21349:
                                                mem[mem[64] + t + 164] = mem[t + 384]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21349) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24857 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25228 = mem[_24857]
                                            require mem[_24857] <= 4294967296
                                            require mem[_24857] + 32 <= return_data.size
                                            require mem[mem[_24857] + _24857] <= 4294967296 and mem[_24857] + (32 * mem[mem[_24857] + _24857]) + 32 <= return_data.size
                                            mem[_24857 + ceil32(return_data.size)] = mem[mem[_24857] + _24857]
                                            _26009 = mem[_25228 + _24857]
                                            idx = 0
                                            while idx < 32 * _26009:
                                                mem[_24857 + ceil32(return_data.size) + idx + 32] = mem[_25228 + _24857 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26009) + _24857 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[352] = 3
                                    mem[64] = 480
                                    mem[384] = ETHAddress
                                    mem[416] = baseTokenAddress
                                    mem[448] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20847 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20849 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20849:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20849) + _20847 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24852 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25218 = mem[_24852]
                                                require mem[_24852] <= 4294967296
                                                require mem[_24852] + 32 <= return_data.size
                                                require mem[mem[_24852] + _24852] <= 4294967296 and mem[_24852] + (32 * mem[mem[_24852] + _24852]) + 32 <= return_data.size
                                                mem[_24852 + ceil32(return_data.size)] = mem[mem[_24852] + _24852]
                                                _26004 = mem[_25218 + _24852]
                                                idx = 0
                                                while idx < 32 * _26004:
                                                    mem[_24852 + ceil32(return_data.size) + idx + 32] = mem[_25218 + _24852 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26004) + _24852 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21335 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21337 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21337:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21337) + _21335 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24853 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25220 = mem[_24853]
                                                require mem[_24853] <= 4294967296
                                                require mem[_24853] + 32 <= return_data.size
                                                require mem[mem[_24853] + _24853] <= 4294967296 and mem[_24853] + (32 * mem[mem[_24853] + _24853]) + 32 <= return_data.size
                                                mem[_24853 + ceil32(return_data.size)] = mem[mem[_24853] + _24853]
                                                _26005 = mem[_25220 + _24853]
                                                idx = 0
                                                while idx < 32 * _26005:
                                                    mem[_24853 + ceil32(return_data.size) + idx + 32] = mem[_25220 + _24853 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26005) + _24853 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21339 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21341 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21341:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21341) + _21339 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24854 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25222 = mem[_24854]
                                            require mem[_24854] <= 4294967296
                                            require mem[_24854] + 32 <= return_data.size
                                            require mem[mem[_24854] + _24854] <= 4294967296 and mem[_24854] + (32 * mem[mem[_24854] + _24854]) + 32 <= return_data.size
                                            mem[_24854 + ceil32(return_data.size)] = mem[mem[_24854] + _24854]
                                            _26006 = mem[_25222 + _24854]
                                            idx = 0
                                            while idx < 32 * _26006:
                                                mem[_24854 + ceil32(return_data.size) + idx + 32] = mem[_25222 + _24854 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26006) + _24854 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[420] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[352] = 2
                                    mem[64] = 448
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20859 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20861 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20861:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20861) + _20859 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24861 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25236 = mem[_24861]
                                                require mem[_24861] <= 4294967296
                                                require mem[_24861] + 32 <= return_data.size
                                                require mem[mem[_24861] + _24861] <= 4294967296 and mem[_24861] + (32 * mem[mem[_24861] + _24861]) + 32 <= return_data.size
                                                mem[_24861 + ceil32(return_data.size)] = mem[mem[_24861] + _24861]
                                                _26013 = mem[_25236 + _24861]
                                                idx = 0
                                                while idx < 32 * _26013:
                                                    mem[_24861 + ceil32(return_data.size) + idx + 32] = mem[_25236 + _24861 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26013) + _24861 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21359 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21361 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21361:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21361) + _21359 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24862 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25238 = mem[_24862]
                                                require mem[_24862] <= 4294967296
                                                require mem[_24862] + 32 <= return_data.size
                                                require mem[mem[_24862] + _24862] <= 4294967296 and mem[_24862] + (32 * mem[mem[_24862] + _24862]) + 32 <= return_data.size
                                                mem[_24862 + ceil32(return_data.size)] = mem[mem[_24862] + _24862]
                                                _26014 = mem[_25238 + _24862]
                                                idx = 0
                                                while idx < 32 * _26014:
                                                    mem[_24862 + ceil32(return_data.size) + idx + 32] = mem[_25238 + _24862 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26014) + _24862 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21363 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21365 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21365:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21365) + _21363 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24863 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25240 = mem[_24863]
                                            require mem[_24863] <= 4294967296
                                            require mem[_24863] + 32 <= return_data.size
                                            require mem[mem[_24863] + _24863] <= 4294967296 and mem[_24863] + (32 * mem[mem[_24863] + _24863]) + 32 <= return_data.size
                                            mem[_24863 + ceil32(return_data.size)] = mem[mem[_24863] + _24863]
                                            _26015 = mem[_25240 + _24863]
                                            idx = 0
                                            while idx < 32 * _26015:
                                                mem[_24863 + ceil32(return_data.size) + idx + 32] = mem[_25240 + _24863 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26015) + _24863 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[352] = 3
                                    mem[64] = 480
                                    mem[384] = ETHAddress
                                    mem[416] = baseTokenAddress
                                    mem[448] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20855 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20857 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20857:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20857) + _20855 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24858 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25230 = mem[_24858]
                                                require mem[_24858] <= 4294967296
                                                require mem[_24858] + 32 <= return_data.size
                                                require mem[mem[_24858] + _24858] <= 4294967296 and mem[_24858] + (32 * mem[mem[_24858] + _24858]) + 32 <= return_data.size
                                                mem[_24858 + ceil32(return_data.size)] = mem[mem[_24858] + _24858]
                                                _26010 = mem[_25230 + _24858]
                                                idx = 0
                                                while idx < 32 * _26010:
                                                    mem[_24858 + ceil32(return_data.size) + idx + 32] = mem[_25230 + _24858 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26010) + _24858 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21353 = mem[352]
                                                t = 0
                                                while t < 32 * _21353:
                                                    mem[mem[64] + t + 164] = mem[t + 384]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21353) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24859 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25232 = mem[_24859]
                                                require mem[_24859] <= 4294967296
                                                require mem[_24859] + 32 <= return_data.size
                                                require mem[mem[_24859] + _24859] <= 4294967296 and mem[_24859] + (32 * mem[mem[_24859] + _24859]) + 32 <= return_data.size
                                                mem[_24859 + ceil32(return_data.size)] = mem[mem[_24859] + _24859]
                                                _26011 = mem[_25232 + _24859]
                                                idx = 0
                                                while idx < 32 * _26011:
                                                    mem[_24859 + ceil32(return_data.size) + idx + 32] = mem[_25232 + _24859 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26011) + _24859 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21355 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21357 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21357:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21357) + _21355 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24860 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25234 = mem[_24860]
                                            require mem[_24860] <= 4294967296
                                            require mem[_24860] + 32 <= return_data.size
                                            require mem[mem[_24860] + _24860] <= 4294967296 and mem[_24860] + (32 * mem[mem[_24860] + _24860]) + 32 <= return_data.size
                                            mem[_24860 + ceil32(return_data.size)] = mem[mem[_24860] + _24860]
                                            _26012 = mem[_25234 + _24860]
                                            idx = 0
                                            while idx < 32 * _26012:
                                                mem[_24860 + ceil32(return_data.size) + idx + 32] = mem[_25234 + _24860 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26012) + _24860 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                if eth.balance(this.address) > 0:
                    if bool(stor9[address(msg.sender)]) != 1:
                        revert with 0, 
                                    32,
                                    56,
                                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                    mem[mem[64] + 124 len 8]
                    call msg.sender with:
                       value eth.balance(this.address) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            else:
                if mode != 2:
                    if mode == 3:
                        require ext_code.size(baseTokenAddress)
                        call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if baseTokenAddress == ETHAddress:
                            mem[96] = 2
                            mem[64] = 192
                            mem[128] = baseTokenAddress
                            mem[160] = sub_c0b6201cAddress
                            require sub_43ff02f6 * wallets.length
                            sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                            idx = 0
                            while idx < wallets.length:
                                mem[0] = 10
                                _5731 = mem[64]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 100] = wallets[idx]
                                mem[mem[64] + 132] = block.timestamp
                                mem[mem[64] + 68] = 128
                                mem[mem[64] + 164] = mem[96]
                                _5733 = mem[96]
                                s = 0
                                while s < 32 * mem[96]:
                                    mem[mem[64] + s + 196] = mem[s + 128]
                                    s = s + 32
                                    continue 
                                _11261 = mem[64]
                                mem[mem[64]] = (32 * mem[96]) + _5731 + -mem[64] + 164
                                mem[64] = (32 * _5733) + _5731 + 196
                                mem[_11261 + 32] = mem[_11261 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                s = 0
                                t = 0
                                while s < sub_43ff02f6:
                                    if s != sub_43ff02f6 - 1:
                                        _16688 = mem[64]
                                        _16689 = mem[_11261]
                                        t = _11261 + 32
                                        u = mem[64]
                                        idx = mem[_11261]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11261])] = mem[_11261 + floor32(mem[_11261]) + -(mem[_11261] % 32) + 64 len mem[_11261] % 32] or Mask(8 * -(mem[_11261] % 32) + 32, -(8 * -(mem[_11261] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11261])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _16689 + _16688 + -mem[64] - 4]
                                        if return_data.size:
                                            _20733 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20733] = return_data.size
                                            mem[_20733 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    if idx != wallets.length - 1:
                                        _17106 = mem[64]
                                        _17107 = mem[_11261]
                                        t = _11261 + 32
                                        u = mem[64]
                                        idx = mem[_11261]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11261])] = mem[_11261 + floor32(mem[_11261]) + -(mem[_11261] % 32) + 64 len mem[_11261] % 32] or Mask(8 * -(mem[_11261] % 32) + 32, -(8 * -(mem[_11261] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11261])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _17107 + _17106 + -mem[64] - 4]
                                        if return_data.size:
                                            _20734 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20734] = return_data.size
                                            mem[_20734 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    _17108 = mem[64]
                                    _17109 = mem[_11261]
                                    t = _11261 + 32
                                    u = mem[64]
                                    idx = mem[_11261]
                                    while idx >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        idx = idx - 32
                                        continue 
                                    mem[mem[64] + floor32(mem[_11261])] = mem[_11261 + floor32(mem[_11261]) + -(mem[_11261] % 32) + 64 len mem[_11261] % 32] or Mask(8 * -(mem[_11261] % 32) + 32, -(8 * -(mem[_11261] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11261])])
                                    call routerAddress.mem[mem[64] len 4] with:
                                       value eth.balance(this.address) wei
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _17109 + _17108 + -mem[64] - 4]
                                    if return_data.size:
                                        _20735 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                        mem[_20735] = return_data.size
                                        mem[_20735 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    s = s + 1
                                    t = eth.balance(this.address)
                                    continue 
                                idx = idx + 1
                                continue 
                        else:
                            mem[96] = 3
                            mem[64] = 224
                            mem[128] = ETHAddress
                            mem[160] = baseTokenAddress
                            mem[192] = sub_c0b6201cAddress
                            require sub_43ff02f6 * wallets.length
                            sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                            idx = 0
                            while idx < wallets.length:
                                mem[0] = 10
                                _5727 = mem[64]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 100] = wallets[idx]
                                mem[mem[64] + 132] = block.timestamp
                                mem[mem[64] + 68] = 128
                                mem[mem[64] + 164] = mem[96]
                                _5729 = mem[96]
                                s = 0
                                while s < 32 * mem[96]:
                                    mem[mem[64] + s + 196] = mem[s + 128]
                                    s = s + 32
                                    continue 
                                _11258 = mem[64]
                                mem[mem[64]] = (32 * mem[96]) + _5727 + -mem[64] + 164
                                mem[64] = (32 * _5729) + _5727 + 196
                                mem[_11258 + 32] = mem[_11258 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                s = 0
                                t = 0
                                while s < sub_43ff02f6:
                                    if s != sub_43ff02f6 - 1:
                                        _16686 = mem[64]
                                        _16687 = mem[_11258]
                                        t = _11258 + 32
                                        u = mem[64]
                                        idx = mem[_11258]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11258])] = mem[_11258 + floor32(mem[_11258]) + -(mem[_11258] % 32) + 64 len mem[_11258] % 32] or Mask(8 * -(mem[_11258] % 32) + 32, -(8 * -(mem[_11258] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11258])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _16687 + _16686 + -mem[64] - 4]
                                        if return_data.size:
                                            _20730 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20730] = return_data.size
                                            mem[_20730 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    if idx != wallets.length - 1:
                                        _17102 = mem[64]
                                        _17103 = mem[_11258]
                                        t = _11258 + 32
                                        u = mem[64]
                                        idx = mem[_11258]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11258])] = mem[_11258 + floor32(mem[_11258]) + -(mem[_11258] % 32) + 64 len mem[_11258] % 32] or Mask(8 * -(mem[_11258] % 32) + 32, -(8 * -(mem[_11258] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11258])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _17103 + _17102 + -mem[64] - 4]
                                        if return_data.size:
                                            _20731 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20731] = return_data.size
                                            mem[_20731 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    _17104 = mem[64]
                                    _17105 = mem[_11258]
                                    t = _11258 + 32
                                    u = mem[64]
                                    idx = mem[_11258]
                                    while idx >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        idx = idx - 32
                                        continue 
                                    mem[mem[64] + floor32(mem[_11258])] = mem[_11258 + floor32(mem[_11258]) + -(mem[_11258] % 32) + 64 len mem[_11258] % 32] or Mask(8 * -(mem[_11258] % 32) + 32, -(8 * -(mem[_11258] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11258])])
                                    call routerAddress.mem[mem[64] len 4] with:
                                       value eth.balance(this.address) wei
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _17105 + _17104 + -mem[64] - 4]
                                    if return_data.size:
                                        _20732 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                        mem[_20732] = return_data.size
                                        mem[_20732 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    s = s + 1
                                    t = eth.balance(this.address)
                                    continue 
                                idx = idx + 1
                                continue 
                else:
                    require ext_code.size(ETHAddress)
                    call ETHAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(baseTokenAddress)
                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if baseTokenAddress == ETHAddress:
                        mem[96] = 2
                        mem[128] = baseTokenAddress
                        mem[160] = sub_c0b6201cAddress
                        mem[356 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                           value eth.balance(this.address) / 1000 wei
                             gas gas_remaining wei
                            args 0, 128, address(this.address), block.timestamp + 30, 2, mem[356 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c0b6201cAddress)
                        staticcall sub_c0b6201cAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sub_c0b6201cAddress)
                        call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(baseTokenAddress)
                        call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if baseTokenAddress == ETHAddress:
                            mem[192] = 2
                            mem[224] = sub_c0b6201cAddress
                            mem[256] = baseTokenAddress
                            mem[388] = this.address
                            mem[420] = block.timestamp + 30
                            mem[452] = 2
                            mem[484 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[484 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[356] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[288] = 2
                                    mem[64] = 384
                                    mem[320] = baseTokenAddress
                                    mem[352] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20819 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _20821 = mem[288]
                                                idx = 0
                                                while idx < 32 * _20821:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20821) + _20819 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24831 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25176 = mem[_24831]
                                                require mem[_24831] <= 4294967296
                                                require mem[_24831] + 32 <= return_data.size
                                                require mem[mem[_24831] + _24831] <= 4294967296 and mem[_24831] + (32 * mem[mem[_24831] + _24831]) + 32 <= return_data.size
                                                mem[_24831 + ceil32(return_data.size)] = mem[mem[_24831] + _24831]
                                                _25983 = mem[_25176 + _24831]
                                                idx = 0
                                                while idx < 32 * _25983:
                                                    mem[_24831 + ceil32(return_data.size) + idx + 32] = mem[_25176 + _24831 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25983) + _24831 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21281 = mem[288]
                                                t = 0
                                                while t < 32 * _21281:
                                                    mem[mem[64] + t + 164] = mem[t + 320]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21281) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24832 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25178 = mem[_24832]
                                                require mem[_24832] <= 4294967296
                                                require mem[_24832] + 32 <= return_data.size
                                                require mem[mem[_24832] + _24832] <= 4294967296 and mem[_24832] + (32 * mem[mem[_24832] + _24832]) + 32 <= return_data.size
                                                mem[_24832 + ceil32(return_data.size)] = mem[mem[_24832] + _24832]
                                                _25984 = mem[_25178 + _24832]
                                                idx = 0
                                                while idx < 32 * _25984:
                                                    mem[_24832 + ceil32(return_data.size) + idx + 32] = mem[_25178 + _24832 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25984) + _24832 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21283 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21285 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21285:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21285) + _21283 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24833 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25180 = mem[_24833]
                                            require mem[_24833] <= 4294967296
                                            require mem[_24833] + 32 <= return_data.size
                                            require mem[mem[_24833] + _24833] <= 4294967296 and mem[_24833] + (32 * mem[mem[_24833] + _24833]) + 32 <= return_data.size
                                            mem[_24833 + ceil32(return_data.size)] = mem[mem[_24833] + _24833]
                                            _25985 = mem[_25180 + _24833]
                                            idx = 0
                                            while idx < 32 * _25985:
                                                mem[_24833 + ceil32(return_data.size) + idx + 32] = mem[_25180 + _24833 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25985) + _24833 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[288] = 3
                                    mem[64] = 416
                                    mem[320] = ETHAddress
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20815 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _20817 = mem[288]
                                                idx = 0
                                                while idx < 32 * _20817:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20817) + _20815 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24828 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25170 = mem[_24828]
                                                require mem[_24828] <= 4294967296
                                                require mem[_24828] + 32 <= return_data.size
                                                require mem[mem[_24828] + _24828] <= 4294967296 and mem[_24828] + (32 * mem[mem[_24828] + _24828]) + 32 <= return_data.size
                                                mem[_24828 + ceil32(return_data.size)] = mem[mem[_24828] + _24828]
                                                _25980 = mem[_25170 + _24828]
                                                idx = 0
                                                while idx < 32 * _25980:
                                                    mem[_24828 + ceil32(return_data.size) + idx + 32] = mem[_25170 + _24828 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25980) + _24828 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            if idx != wallets.length - 1:
                                                _21273 = mem[288]
                                                t = 0
                                                while t < 32 * _21273:
                                                    mem[mem[64] + t + 164] = mem[t + 320]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21273) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24829 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25172 = mem[_24829]
                                                require mem[_24829] <= 4294967296
                                                require mem[_24829] + 32 <= return_data.size
                                                require mem[mem[_24829] + _24829] <= 4294967296 and mem[_24829] + (32 * mem[mem[_24829] + _24829]) + 32 <= return_data.size
                                                mem[_24829 + ceil32(return_data.size)] = mem[mem[_24829] + _24829]
                                                _25981 = mem[_25172 + _24829]
                                                idx = 0
                                                while idx < 32 * _25981:
                                                    mem[_24829 + ceil32(return_data.size) + idx + 32] = mem[_25172 + _24829 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25981) + _24829 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21277 = mem[288]
                                            t = 0
                                            while t < 32 * _21277:
                                                mem[mem[64] + t + 164] = mem[t + 320]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21277) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24830 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25174 = mem[_24830]
                                            require mem[_24830] <= 4294967296
                                            require mem[_24830] + 32 <= return_data.size
                                            require mem[mem[_24830] + _24830] <= 4294967296 and mem[_24830] + (32 * mem[mem[_24830] + _24830]) + 32 <= return_data.size
                                            mem[_24830 + ceil32(return_data.size)] = mem[mem[_24830] + _24830]
                                            _25982 = mem[_25174 + _24830]
                                            idx = 0
                                            while idx < 32 * _25982:
                                                mem[_24830 + ceil32(return_data.size) + idx + 32] = mem[_25174 + _24830 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25982) + _24830 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[356] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[288] = 2
                                        mem[64] = 384
                                        mem[320] = baseTokenAddress
                                        mem[352] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20827 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _20829 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _20829:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20829) + _20827 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24837 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25188 = mem[_24837]
                                                    require mem[_24837] <= 4294967296
                                                    require mem[_24837] + 32 <= return_data.size
                                                    require mem[mem[_24837] + _24837] <= 4294967296 and mem[_24837] + (32 * mem[mem[_24837] + _24837]) + 32 <= return_data.size
                                                    mem[_24837 + ceil32(return_data.size)] = mem[mem[_24837] + _24837]
                                                    _25989 = mem[_25188 + _24837]
                                                    idx = 0
                                                    while idx < 32 * _25989:
                                                        mem[_24837 + ceil32(return_data.size) + idx + 32] = mem[_25188 + _24837 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25989) + _24837 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21295 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21297 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21297:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21297) + _21295 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24838 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25190 = mem[_24838]
                                                    require mem[_24838] <= 4294967296
                                                    require mem[_24838] + 32 <= return_data.size
                                                    require mem[mem[_24838] + _24838] <= 4294967296 and mem[_24838] + (32 * mem[mem[_24838] + _24838]) + 32 <= return_data.size
                                                    mem[_24838 + ceil32(return_data.size)] = mem[mem[_24838] + _24838]
                                                    _25990 = mem[_25190 + _24838]
                                                    idx = 0
                                                    while idx < 32 * _25990:
                                                        mem[_24838 + ceil32(return_data.size) + idx + 32] = mem[_25190 + _24838 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25990) + _24838 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21299 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21301 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21301:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21301) + _21299 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24839 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25192 = mem[_24839]
                                                require mem[_24839] <= 4294967296
                                                require mem[_24839] + 32 <= return_data.size
                                                require mem[mem[_24839] + _24839] <= 4294967296 and mem[_24839] + (32 * mem[mem[_24839] + _24839]) + 32 <= return_data.size
                                                mem[_24839 + ceil32(return_data.size)] = mem[mem[_24839] + _24839]
                                                _25991 = mem[_25192 + _24839]
                                                idx = 0
                                                while idx < 32 * _25991:
                                                    mem[_24839 + ceil32(return_data.size) + idx + 32] = mem[_25192 + _24839 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25991) + _24839 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[288] = 3
                                        mem[64] = 416
                                        mem[320] = ETHAddress
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20823 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _20825 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _20825:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20825) + _20823 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24834 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25182 = mem[_24834]
                                                    require mem[_24834] <= 4294967296
                                                    require mem[_24834] + 32 <= return_data.size
                                                    require mem[mem[_24834] + _24834] <= 4294967296 and mem[_24834] + (32 * mem[mem[_24834] + _24834]) + 32 <= return_data.size
                                                    mem[_24834 + ceil32(return_data.size)] = mem[mem[_24834] + _24834]
                                                    _25986 = mem[_25182 + _24834]
                                                    idx = 0
                                                    while idx < 32 * _25986:
                                                        mem[_24834 + ceil32(return_data.size) + idx + 32] = mem[_25182 + _24834 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25986) + _24834 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21287 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21289 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21289:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21289) + _21287 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24835 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25184 = mem[_24835]
                                                    require mem[_24835] <= 4294967296
                                                    require mem[_24835] + 32 <= return_data.size
                                                    require mem[mem[_24835] + _24835] <= 4294967296 and mem[_24835] + (32 * mem[mem[_24835] + _24835]) + 32 <= return_data.size
                                                    mem[_24835 + ceil32(return_data.size)] = mem[mem[_24835] + _24835]
                                                    _25987 = mem[_25184 + _24835]
                                                    idx = 0
                                                    while idx < 32 * _25987:
                                                        mem[_24835 + ceil32(return_data.size) + idx + 32] = mem[_25184 + _24835 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25987) + _24835 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21291 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21293 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21293:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21293) + _21291 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24836 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25186 = mem[_24836]
                                                require mem[_24836] <= 4294967296
                                                require mem[_24836] + 32 <= return_data.size
                                                require mem[mem[_24836] + _24836] <= 4294967296 and mem[_24836] + (32 * mem[mem[_24836] + _24836]) + 32 <= return_data.size
                                                mem[_24836 + ceil32(return_data.size)] = mem[mem[_24836] + _24836]
                                                _25988 = mem[_25186 + _24836]
                                                idx = 0
                                                while idx < 32 * _25988:
                                                    mem[_24836 + ceil32(return_data.size) + idx + 32] = mem[_25186 + _24836 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25988) + _24836 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[356] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[288] = 2
                                        mem[64] = 384
                                        mem[320] = baseTokenAddress
                                        mem[352] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20835 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _20837 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _20837:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20837) + _20835 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24843 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25200 = mem[_24843]
                                                    require mem[_24843] <= 4294967296
                                                    require mem[_24843] + 32 <= return_data.size
                                                    require mem[mem[_24843] + _24843] <= 4294967296 and mem[_24843] + (32 * mem[mem[_24843] + _24843]) + 32 <= return_data.size
                                                    mem[_24843 + ceil32(return_data.size)] = mem[mem[_24843] + _24843]
                                                    _25995 = mem[_25200 + _24843]
                                                    idx = 0
                                                    while idx < 32 * _25995:
                                                        mem[_24843 + ceil32(return_data.size) + idx + 32] = mem[_25200 + _24843 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25995) + _24843 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21311 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21313 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21313:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21313) + _21311 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24844 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25202 = mem[_24844]
                                                    require mem[_24844] <= 4294967296
                                                    require mem[_24844] + 32 <= return_data.size
                                                    require mem[mem[_24844] + _24844] <= 4294967296 and mem[_24844] + (32 * mem[mem[_24844] + _24844]) + 32 <= return_data.size
                                                    mem[_24844 + ceil32(return_data.size)] = mem[mem[_24844] + _24844]
                                                    _25996 = mem[_25202 + _24844]
                                                    idx = 0
                                                    while idx < 32 * _25996:
                                                        mem[_24844 + ceil32(return_data.size) + idx + 32] = mem[_25202 + _24844 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25996) + _24844 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21315 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21317 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21317:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21317) + _21315 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24845 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25204 = mem[_24845]
                                                require mem[_24845] <= 4294967296
                                                require mem[_24845] + 32 <= return_data.size
                                                require mem[mem[_24845] + _24845] <= 4294967296 and mem[_24845] + (32 * mem[mem[_24845] + _24845]) + 32 <= return_data.size
                                                mem[_24845 + ceil32(return_data.size)] = mem[mem[_24845] + _24845]
                                                _25997 = mem[_25204 + _24845]
                                                idx = 0
                                                while idx < 32 * _25997:
                                                    mem[_24845 + ceil32(return_data.size) + idx + 32] = mem[_25204 + _24845 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25997) + _24845 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[288] = 3
                                        mem[64] = 416
                                        mem[320] = ETHAddress
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20831 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _20833 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _20833:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20833) + _20831 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24840 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25194 = mem[_24840]
                                                    require mem[_24840] <= 4294967296
                                                    require mem[_24840] + 32 <= return_data.size
                                                    require mem[mem[_24840] + _24840] <= 4294967296 and mem[_24840] + (32 * mem[mem[_24840] + _24840]) + 32 <= return_data.size
                                                    mem[_24840 + ceil32(return_data.size)] = mem[mem[_24840] + _24840]
                                                    _25992 = mem[_25194 + _24840]
                                                    idx = 0
                                                    while idx < 32 * _25992:
                                                        mem[_24840 + ceil32(return_data.size) + idx + 32] = mem[_25194 + _24840 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25992) + _24840 + ceil32(return_data.size) + 32
                                                else:
                                                    if idx == wallets.length - 1:
                                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 0
                                                        mem[mem[64] + 68] = wallets[idx]
                                                        mem[mem[64] + 100] = block.timestamp
                                                        mem[mem[64] + 36] = 128
                                                        mem[mem[64] + 132] = mem[288]
                                                        _21309 = mem[288]
                                                        t = 0
                                                        while t < 32 * _21309:
                                                            mem[mem[64] + t + 164] = mem[t + 320]
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                           value eth.balance(this.address) wei
                                                             gas gas_remaining wei
                                                            args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21309) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _24842 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _25198 = mem[_24842]
                                                        require mem[_24842] <= 4294967296
                                                        require mem[_24842] + 32 <= return_data.size
                                                        require mem[mem[_24842] + _24842] <= 4294967296 and mem[_24842] + (32 * mem[mem[_24842] + _24842]) + 32 <= return_data.size
                                                        mem[_24842 + ceil32(return_data.size)] = mem[mem[_24842] + _24842]
                                                        _25994 = mem[_25198 + _24842]
                                                        idx = 0
                                                        while idx < 32 * _25994:
                                                            mem[_24842 + ceil32(return_data.size) + idx + 32] = mem[_25198 + _24842 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[64] = (32 * _25994) + _24842 + ceil32(return_data.size) + 32
                                                        s = s + 1
                                                        t = eth.balance(this.address)
                                                        continue 
                                                    _21303 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21305 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21305:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21305) + _21303 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24841 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25196 = mem[_24841]
                                                    require mem[_24841] <= 4294967296
                                                    require mem[_24841] + 32 <= return_data.size
                                                    require mem[mem[_24841] + _24841] <= 4294967296 and mem[_24841] + (32 * mem[mem[_24841] + _24841]) + 32 <= return_data.size
                                                    mem[_24841 + ceil32(return_data.size)] = mem[mem[_24841] + _24841]
                                                    _25993 = mem[_25196 + _24841]
                                                    idx = 0
                                                    while idx < 32 * _25993:
                                                        mem[_24841 + ceil32(return_data.size) + idx + 32] = mem[_25196 + _24841 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25993) + _24841 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            idx = idx + 1
                                            continue 
                        else:
                            mem[192] = 3
                            mem[224] = sub_c0b6201cAddress
                            mem[256] = baseTokenAddress
                            mem[288] = ETHAddress
                            mem[420] = this.address
                            mem[452] = block.timestamp + 30
                            mem[484] = 3
                            mem[516 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[516 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20795 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20797 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20797:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20797) + _20795 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24813 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25140 = mem[_24813]
                                                require mem[_24813] <= 4294967296
                                                require mem[_24813] + 32 <= return_data.size
                                                require mem[mem[_24813] + _24813] <= 4294967296 and mem[_24813] + (32 * mem[mem[_24813] + _24813]) + 32 <= return_data.size
                                                mem[_24813 + ceil32(return_data.size)] = mem[mem[_24813] + _24813]
                                                _25965 = mem[_25140 + _24813]
                                                idx = 0
                                                while idx < 32 * _25965:
                                                    mem[_24813 + ceil32(return_data.size) + idx + 32] = mem[_25140 + _24813 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25965) + _24813 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21233 = mem[320]
                                                t = 0
                                                while t < 32 * _21233:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21233) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24814 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25142 = mem[_24814]
                                                require mem[_24814] <= 4294967296
                                                require mem[_24814] + 32 <= return_data.size
                                                require mem[mem[_24814] + _24814] <= 4294967296 and mem[_24814] + (32 * mem[mem[_24814] + _24814]) + 32 <= return_data.size
                                                mem[_24814 + ceil32(return_data.size)] = mem[mem[_24814] + _24814]
                                                _25966 = mem[_25142 + _24814]
                                                idx = 0
                                                while idx < 32 * _25966:
                                                    mem[_24814 + ceil32(return_data.size) + idx + 32] = mem[_25142 + _24814 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25966) + _24814 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21235 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21237 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21237:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21237) + _21235 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24815 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25144 = mem[_24815]
                                            require mem[_24815] <= 4294967296
                                            require mem[_24815] + 32 <= return_data.size
                                            require mem[mem[_24815] + _24815] <= 4294967296 and mem[_24815] + (32 * mem[mem[_24815] + _24815]) + 32 <= return_data.size
                                            mem[_24815 + ceil32(return_data.size)] = mem[mem[_24815] + _24815]
                                            _25967 = mem[_25144 + _24815]
                                            idx = 0
                                            while idx < 32 * _25967:
                                                mem[_24815 + ceil32(return_data.size) + idx + 32] = mem[_25144 + _24815 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25967) + _24815 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20793 = mem[320]
                                                t = 0
                                                while t < 32 * _20793:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20793) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24810 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25134 = mem[_24810]
                                                require mem[_24810] <= 4294967296
                                                require mem[_24810] + 32 <= return_data.size
                                                require mem[mem[_24810] + _24810] <= 4294967296 and mem[_24810] + (32 * mem[mem[_24810] + _24810]) + 32 <= return_data.size
                                                mem[_24810 + ceil32(return_data.size)] = mem[mem[_24810] + _24810]
                                                _25962 = mem[_25134 + _24810]
                                                idx = 0
                                                while idx < 32 * _25962:
                                                    mem[_24810 + ceil32(return_data.size) + idx + 32] = mem[_25134 + _24810 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25962) + _24810 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21223 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21225 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21225:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21225) + _21223 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24811 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25136 = mem[_24811]
                                                require mem[_24811] <= 4294967296
                                                require mem[_24811] + 32 <= return_data.size
                                                require mem[mem[_24811] + _24811] <= 4294967296 and mem[_24811] + (32 * mem[mem[_24811] + _24811]) + 32 <= return_data.size
                                                mem[_24811 + ceil32(return_data.size)] = mem[mem[_24811] + _24811]
                                                _25963 = mem[_25136 + _24811]
                                                idx = 0
                                                while idx < 32 * _25963:
                                                    mem[_24811 + ceil32(return_data.size) + idx + 32] = mem[_25136 + _24811 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25963) + _24811 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21227 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21229 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21229:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21229) + _21227 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24812 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25138 = mem[_24812]
                                            require mem[_24812] <= 4294967296
                                            require mem[_24812] + 32 <= return_data.size
                                            require mem[mem[_24812] + _24812] <= 4294967296 and mem[_24812] + (32 * mem[mem[_24812] + _24812]) + 32 <= return_data.size
                                            mem[_24812 + ceil32(return_data.size)] = mem[mem[_24812] + _24812]
                                            _25964 = mem[_25138 + _24812]
                                            idx = 0
                                            while idx < 32 * _25964:
                                                mem[_24812 + ceil32(return_data.size) + idx + 32] = mem[_25138 + _24812 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25964) + _24812 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20805 = mem[320]
                                                    t = 0
                                                    while t < 32 * _20805:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20805) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24819 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25152 = mem[_24819]
                                                    require mem[_24819] <= 4294967296
                                                    require mem[_24819] + 32 <= return_data.size
                                                    require mem[mem[_24819] + _24819] <= 4294967296 and mem[_24819] + (32 * mem[mem[_24819] + _24819]) + 32 <= return_data.size
                                                    mem[_24819 + ceil32(return_data.size)] = mem[mem[_24819] + _24819]
                                                    _25971 = mem[_25152 + _24819]
                                                    idx = 0
                                                    while idx < 32 * _25971:
                                                        mem[_24819 + ceil32(return_data.size) + idx + 32] = mem[_25152 + _24819 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25971) + _24819 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21247 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21249 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21249:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21249) + _21247 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24820 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25154 = mem[_24820]
                                                    require mem[_24820] <= 4294967296
                                                    require mem[_24820] + 32 <= return_data.size
                                                    require mem[mem[_24820] + _24820] <= 4294967296 and mem[_24820] + (32 * mem[mem[_24820] + _24820]) + 32 <= return_data.size
                                                    mem[_24820 + ceil32(return_data.size)] = mem[mem[_24820] + _24820]
                                                    _25972 = mem[_25154 + _24820]
                                                    idx = 0
                                                    while idx < 32 * _25972:
                                                        mem[_24820 + ceil32(return_data.size) + idx + 32] = mem[_25154 + _24820 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25972) + _24820 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21251 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21253 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21253:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21253) + _21251 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24821 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25156 = mem[_24821]
                                                require mem[_24821] <= 4294967296
                                                require mem[_24821] + 32 <= return_data.size
                                                require mem[mem[_24821] + _24821] <= 4294967296 and mem[_24821] + (32 * mem[mem[_24821] + _24821]) + 32 <= return_data.size
                                                mem[_24821 + ceil32(return_data.size)] = mem[mem[_24821] + _24821]
                                                _25973 = mem[_25156 + _24821]
                                                idx = 0
                                                while idx < 32 * _25973:
                                                    mem[_24821 + ceil32(return_data.size) + idx + 32] = mem[_25156 + _24821 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25973) + _24821 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20799 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20801 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20801:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20801) + _20799 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24816 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25146 = mem[_24816]
                                                    require mem[_24816] <= 4294967296
                                                    require mem[_24816] + 32 <= return_data.size
                                                    require mem[mem[_24816] + _24816] <= 4294967296 and mem[_24816] + (32 * mem[mem[_24816] + _24816]) + 32 <= return_data.size
                                                    mem[_24816 + ceil32(return_data.size)] = mem[mem[_24816] + _24816]
                                                    _25968 = mem[_25146 + _24816]
                                                    idx = 0
                                                    while idx < 32 * _25968:
                                                        mem[_24816 + ceil32(return_data.size) + idx + 32] = mem[_25146 + _24816 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25968) + _24816 + ceil32(return_data.size) + 32
                                                else:
                                                    if idx == wallets.length - 1:
                                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 0
                                                        mem[mem[64] + 68] = wallets[idx]
                                                        mem[mem[64] + 100] = block.timestamp
                                                        mem[mem[64] + 36] = 128
                                                        mem[mem[64] + 132] = mem[320]
                                                        _21245 = mem[320]
                                                        t = 0
                                                        while t < 32 * _21245:
                                                            mem[mem[64] + t + 164] = mem[t + 352]
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                           value eth.balance(this.address) wei
                                                             gas gas_remaining wei
                                                            args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21245) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _24818 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _25150 = mem[_24818]
                                                        require mem[_24818] <= 4294967296
                                                        require mem[_24818] + 32 <= return_data.size
                                                        require mem[mem[_24818] + _24818] <= 4294967296 and mem[_24818] + (32 * mem[mem[_24818] + _24818]) + 32 <= return_data.size
                                                        mem[_24818 + ceil32(return_data.size)] = mem[mem[_24818] + _24818]
                                                        _25970 = mem[_25150 + _24818]
                                                        idx = 0
                                                        while idx < 32 * _25970:
                                                            mem[_24818 + ceil32(return_data.size) + idx + 32] = mem[_25150 + _24818 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[64] = (32 * _25970) + _24818 + ceil32(return_data.size) + 32
                                                        s = s + 1
                                                        t = eth.balance(this.address)
                                                        continue 
                                                    _21239 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21241 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21241:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21241) + _21239 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24817 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25148 = mem[_24817]
                                                    require mem[_24817] <= 4294967296
                                                    require mem[_24817] + 32 <= return_data.size
                                                    require mem[mem[_24817] + _24817] <= 4294967296 and mem[_24817] + (32 * mem[mem[_24817] + _24817]) + 32 <= return_data.size
                                                    mem[_24817 + ceil32(return_data.size)] = mem[mem[_24817] + _24817]
                                                    _25969 = mem[_25148 + _24817]
                                                    idx = 0
                                                    while idx < 32 * _25969:
                                                        mem[_24817 + ceil32(return_data.size) + idx + 32] = mem[_25148 + _24817 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25969) + _24817 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20811 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20813 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20813:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20813) + _20811 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24825 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25164 = mem[_24825]
                                                    require mem[_24825] <= 4294967296
                                                    require mem[_24825] + 32 <= return_data.size
                                                    require mem[mem[_24825] + _24825] <= 4294967296 and mem[_24825] + (32 * mem[mem[_24825] + _24825]) + 32 <= return_data.size
                                                    mem[_24825 + ceil32(return_data.size)] = mem[mem[_24825] + _24825]
                                                    _25977 = mem[_25164 + _24825]
                                                    idx = 0
                                                    while idx < 32 * _25977:
                                                        mem[_24825 + ceil32(return_data.size) + idx + 32] = mem[_25164 + _24825 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25977) + _24825 + ceil32(return_data.size) + 32
                                                else:
                                                    if idx == wallets.length - 1:
                                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 0
                                                        mem[mem[64] + 68] = wallets[idx]
                                                        mem[mem[64] + 100] = block.timestamp
                                                        mem[mem[64] + 36] = 128
                                                        mem[mem[64] + 132] = mem[320]
                                                        _21269 = mem[320]
                                                        t = 0
                                                        while t < 32 * _21269:
                                                            mem[mem[64] + t + 164] = mem[t + 352]
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                           value eth.balance(this.address) wei
                                                             gas gas_remaining wei
                                                            args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21269) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _24827 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _25168 = mem[_24827]
                                                        require mem[_24827] <= 4294967296
                                                        require mem[_24827] + 32 <= return_data.size
                                                        require mem[mem[_24827] + _24827] <= 4294967296 and mem[_24827] + (32 * mem[mem[_24827] + _24827]) + 32 <= return_data.size
                                                        mem[_24827 + ceil32(return_data.size)] = mem[mem[_24827] + _24827]
                                                        _25979 = mem[_25168 + _24827]
                                                        idx = 0
                                                        while idx < 32 * _25979:
                                                            mem[_24827 + ceil32(return_data.size) + idx + 32] = mem[_25168 + _24827 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[64] = (32 * _25979) + _24827 + ceil32(return_data.size) + 32
                                                        s = s + 1
                                                        t = eth.balance(this.address)
                                                        continue 
                                                    _21263 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21265 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21265:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21265) + _21263 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24826 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25166 = mem[_24826]
                                                    require mem[_24826] <= 4294967296
                                                    require mem[_24826] + 32 <= return_data.size
                                                    require mem[mem[_24826] + _24826] <= 4294967296 and mem[_24826] + (32 * mem[mem[_24826] + _24826]) + 32 <= return_data.size
                                                    mem[_24826 + ceil32(return_data.size)] = mem[mem[_24826] + _24826]
                                                    _25978 = mem[_25166 + _24826]
                                                    idx = 0
                                                    while idx < 32 * _25978:
                                                        mem[_24826 + ceil32(return_data.size) + idx + 32] = mem[_25166 + _24826 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25978) + _24826 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20809 = mem[320]
                                                    t = 0
                                                    while t < 32 * _20809:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20809) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24822 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25158 = mem[_24822]
                                                    require mem[_24822] <= 4294967296
                                                    require mem[_24822] + 32 <= return_data.size
                                                    require mem[mem[_24822] + _24822] <= 4294967296 and mem[_24822] + (32 * mem[mem[_24822] + _24822]) + 32 <= return_data.size
                                                    mem[_24822 + ceil32(return_data.size)] = mem[mem[_24822] + _24822]
                                                    _25974 = mem[_25158 + _24822]
                                                    idx = 0
                                                    while idx < 32 * _25974:
                                                        mem[_24822 + ceil32(return_data.size) + idx + 32] = mem[_25158 + _24822 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25974) + _24822 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21255 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21257 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21257:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21257) + _21255 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24823 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25160 = mem[_24823]
                                                    require mem[_24823] <= 4294967296
                                                    require mem[_24823] + 32 <= return_data.size
                                                    require mem[mem[_24823] + _24823] <= 4294967296 and mem[_24823] + (32 * mem[mem[_24823] + _24823]) + 32 <= return_data.size
                                                    mem[_24823 + ceil32(return_data.size)] = mem[mem[_24823] + _24823]
                                                    _25975 = mem[_25160 + _24823]
                                                    idx = 0
                                                    while idx < 32 * _25975:
                                                        mem[_24823 + ceil32(return_data.size) + idx + 32] = mem[_25160 + _24823 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25975) + _24823 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21259 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21261 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21261:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21261) + _21259 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24824 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25162 = mem[_24824]
                                                require mem[_24824] <= 4294967296
                                                require mem[_24824] + 32 <= return_data.size
                                                require mem[mem[_24824] + _24824] <= 4294967296 and mem[_24824] + (32 * mem[mem[_24824] + _24824]) + 32 <= return_data.size
                                                mem[_24824 + ceil32(return_data.size)] = mem[mem[_24824] + _24824]
                                                _25976 = mem[_25162 + _24824]
                                                idx = 0
                                                while idx < 32 * _25976:
                                                    mem[_24824 + ceil32(return_data.size) + idx + 32] = mem[_25162 + _24824 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25976) + _24824 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                    else:
                        mem[96] = 3
                        mem[128] = ETHAddress
                        mem[160] = baseTokenAddress
                        mem[192] = sub_c0b6201cAddress
                        mem[388 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                           value eth.balance(this.address) / 1000 wei
                             gas gas_remaining wei
                            args 0, 128, address(this.address), block.timestamp + 30, 3, mem[388 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c0b6201cAddress)
                        staticcall sub_c0b6201cAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sub_c0b6201cAddress)
                        call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(baseTokenAddress)
                        call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if baseTokenAddress == ETHAddress:
                            mem[224] = 2
                            mem[256] = sub_c0b6201cAddress
                            mem[288] = baseTokenAddress
                            mem[420] = this.address
                            mem[452] = block.timestamp + 30
                            mem[484] = 2
                            mem[516 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[516 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20771 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20773 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20773:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20773) + _20771 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24795 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25104 = mem[_24795]
                                                require mem[_24795] <= 4294967296
                                                require mem[_24795] + 32 <= return_data.size
                                                require mem[mem[_24795] + _24795] <= 4294967296 and mem[_24795] + (32 * mem[mem[_24795] + _24795]) + 32 <= return_data.size
                                                mem[_24795 + ceil32(return_data.size)] = mem[mem[_24795] + _24795]
                                                _25947 = mem[_25104 + _24795]
                                                idx = 0
                                                while idx < 32 * _25947:
                                                    mem[_24795 + ceil32(return_data.size) + idx + 32] = mem[_25104 + _24795 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25947) + _24795 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21183 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21185 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21185:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21185) + _21183 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24796 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25106 = mem[_24796]
                                                require mem[_24796] <= 4294967296
                                                require mem[_24796] + 32 <= return_data.size
                                                require mem[mem[_24796] + _24796] <= 4294967296 and mem[_24796] + (32 * mem[mem[_24796] + _24796]) + 32 <= return_data.size
                                                mem[_24796 + ceil32(return_data.size)] = mem[mem[_24796] + _24796]
                                                _25948 = mem[_25106 + _24796]
                                                idx = 0
                                                while idx < 32 * _25948:
                                                    mem[_24796 + ceil32(return_data.size) + idx + 32] = mem[_25106 + _24796 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25948) + _24796 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21187 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21189 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21189:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21189) + _21187 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24797 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25108 = mem[_24797]
                                            require mem[_24797] <= 4294967296
                                            require mem[_24797] + 32 <= return_data.size
                                            require mem[mem[_24797] + _24797] <= 4294967296 and mem[_24797] + (32 * mem[mem[_24797] + _24797]) + 32 <= return_data.size
                                            mem[_24797 + ceil32(return_data.size)] = mem[mem[_24797] + _24797]
                                            _25949 = mem[_25108 + _24797]
                                            idx = 0
                                            while idx < 32 * _25949:
                                                mem[_24797 + ceil32(return_data.size) + idx + 32] = mem[_25108 + _24797 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25949) + _24797 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20769 = mem[320]
                                                t = 0
                                                while t < 32 * _20769:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20769) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24792 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25098 = mem[_24792]
                                                require mem[_24792] <= 4294967296
                                                require mem[_24792] + 32 <= return_data.size
                                                require mem[mem[_24792] + _24792] <= 4294967296 and mem[_24792] + (32 * mem[mem[_24792] + _24792]) + 32 <= return_data.size
                                                mem[_24792 + ceil32(return_data.size)] = mem[mem[_24792] + _24792]
                                                _25944 = mem[_25098 + _24792]
                                                idx = 0
                                                while idx < 32 * _25944:
                                                    mem[_24792 + ceil32(return_data.size) + idx + 32] = mem[_25098 + _24792 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25944) + _24792 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21175 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21177 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21177:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21177) + _21175 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24793 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25100 = mem[_24793]
                                                require mem[_24793] <= 4294967296
                                                require mem[_24793] + 32 <= return_data.size
                                                require mem[mem[_24793] + _24793] <= 4294967296 and mem[_24793] + (32 * mem[mem[_24793] + _24793]) + 32 <= return_data.size
                                                mem[_24793 + ceil32(return_data.size)] = mem[mem[_24793] + _24793]
                                                _25945 = mem[_25100 + _24793]
                                                idx = 0
                                                while idx < 32 * _25945:
                                                    mem[_24793 + ceil32(return_data.size) + idx + 32] = mem[_25100 + _24793 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25945) + _24793 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21179 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21181 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21181:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21181) + _21179 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24794 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25102 = mem[_24794]
                                            require mem[_24794] <= 4294967296
                                            require mem[_24794] + 32 <= return_data.size
                                            require mem[mem[_24794] + _24794] <= 4294967296 and mem[_24794] + (32 * mem[mem[_24794] + _24794]) + 32 <= return_data.size
                                            mem[_24794 + ceil32(return_data.size)] = mem[mem[_24794] + _24794]
                                            _25946 = mem[_25102 + _24794]
                                            idx = 0
                                            while idx < 32 * _25946:
                                                mem[_24794 + ceil32(return_data.size) + idx + 32] = mem[_25102 + _24794 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25946) + _24794 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20779 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20781 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20781:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20781) + _20779 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24801 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25116 = mem[_24801]
                                                    require mem[_24801] <= 4294967296
                                                    require mem[_24801] + 32 <= return_data.size
                                                    require mem[mem[_24801] + _24801] <= 4294967296 and mem[_24801] + (32 * mem[mem[_24801] + _24801]) + 32 <= return_data.size
                                                    mem[_24801 + ceil32(return_data.size)] = mem[mem[_24801] + _24801]
                                                    _25953 = mem[_25116 + _24801]
                                                    idx = 0
                                                    while idx < 32 * _25953:
                                                        mem[_24801 + ceil32(return_data.size) + idx + 32] = mem[_25116 + _24801 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25953) + _24801 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21199 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21201 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21201:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21201) + _21199 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24802 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25118 = mem[_24802]
                                                    require mem[_24802] <= 4294967296
                                                    require mem[_24802] + 32 <= return_data.size
                                                    require mem[mem[_24802] + _24802] <= 4294967296 and mem[_24802] + (32 * mem[mem[_24802] + _24802]) + 32 <= return_data.size
                                                    mem[_24802 + ceil32(return_data.size)] = mem[mem[_24802] + _24802]
                                                    _25954 = mem[_25118 + _24802]
                                                    idx = 0
                                                    while idx < 32 * _25954:
                                                        mem[_24802 + ceil32(return_data.size) + idx + 32] = mem[_25118 + _24802 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25954) + _24802 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21203 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21205 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21205:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21205) + _21203 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24803 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25120 = mem[_24803]
                                                require mem[_24803] <= 4294967296
                                                require mem[_24803] + 32 <= return_data.size
                                                require mem[mem[_24803] + _24803] <= 4294967296 and mem[_24803] + (32 * mem[mem[_24803] + _24803]) + 32 <= return_data.size
                                                mem[_24803 + ceil32(return_data.size)] = mem[mem[_24803] + _24803]
                                                _25955 = mem[_25120 + _24803]
                                                idx = 0
                                                while idx < 32 * _25955:
                                                    mem[_24803 + ceil32(return_data.size) + idx + 32] = mem[_25120 + _24803 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25955) + _24803 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20775 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20777 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20777:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20777) + _20775 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24798 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25110 = mem[_24798]
                                                    require mem[_24798] <= 4294967296
                                                    require mem[_24798] + 32 <= return_data.size
                                                    require mem[mem[_24798] + _24798] <= 4294967296 and mem[_24798] + (32 * mem[mem[_24798] + _24798]) + 32 <= return_data.size
                                                    mem[_24798 + ceil32(return_data.size)] = mem[mem[_24798] + _24798]
                                                    _25950 = mem[_25110 + _24798]
                                                    idx = 0
                                                    while idx < 32 * _25950:
                                                        mem[_24798 + ceil32(return_data.size) + idx + 32] = mem[_25110 + _24798 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25950) + _24798 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21191 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21193 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21193:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21193) + _21191 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24799 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25112 = mem[_24799]
                                                    require mem[_24799] <= 4294967296
                                                    require mem[_24799] + 32 <= return_data.size
                                                    require mem[mem[_24799] + _24799] <= 4294967296 and mem[_24799] + (32 * mem[mem[_24799] + _24799]) + 32 <= return_data.size
                                                    mem[_24799 + ceil32(return_data.size)] = mem[mem[_24799] + _24799]
                                                    _25951 = mem[_25112 + _24799]
                                                    idx = 0
                                                    while idx < 32 * _25951:
                                                        mem[_24799 + ceil32(return_data.size) + idx + 32] = mem[_25112 + _24799 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25951) + _24799 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21195 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21197 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21197:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21197) + _21195 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24800 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25114 = mem[_24800]
                                                require mem[_24800] <= 4294967296
                                                require mem[_24800] + 32 <= return_data.size
                                                require mem[mem[_24800] + _24800] <= 4294967296 and mem[_24800] + (32 * mem[mem[_24800] + _24800]) + 32 <= return_data.size
                                                mem[_24800 + ceil32(return_data.size)] = mem[mem[_24800] + _24800]
                                                _25952 = mem[_25114 + _24800]
                                                idx = 0
                                                while idx < 32 * _25952:
                                                    mem[_24800 + ceil32(return_data.size) + idx + 32] = mem[_25114 + _24800 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25952) + _24800 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20787 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20789 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20789:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20789) + _20787 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24807 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25128 = mem[_24807]
                                                    require mem[_24807] <= 4294967296
                                                    require mem[_24807] + 32 <= return_data.size
                                                    require mem[mem[_24807] + _24807] <= 4294967296 and mem[_24807] + (32 * mem[mem[_24807] + _24807]) + 32 <= return_data.size
                                                    mem[_24807 + ceil32(return_data.size)] = mem[mem[_24807] + _24807]
                                                    _25959 = mem[_25128 + _24807]
                                                    idx = 0
                                                    while idx < 32 * _25959:
                                                        mem[_24807 + ceil32(return_data.size) + idx + 32] = mem[_25128 + _24807 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25959) + _24807 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21215 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21217 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21217:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21217) + _21215 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24808 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25130 = mem[_24808]
                                                    require mem[_24808] <= 4294967296
                                                    require mem[_24808] + 32 <= return_data.size
                                                    require mem[mem[_24808] + _24808] <= 4294967296 and mem[_24808] + (32 * mem[mem[_24808] + _24808]) + 32 <= return_data.size
                                                    mem[_24808 + ceil32(return_data.size)] = mem[mem[_24808] + _24808]
                                                    _25960 = mem[_25130 + _24808]
                                                    idx = 0
                                                    while idx < 32 * _25960:
                                                        mem[_24808 + ceil32(return_data.size) + idx + 32] = mem[_25130 + _24808 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25960) + _24808 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21219 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21221 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21221:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21221) + _21219 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24809 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25132 = mem[_24809]
                                                require mem[_24809] <= 4294967296
                                                require mem[_24809] + 32 <= return_data.size
                                                require mem[mem[_24809] + _24809] <= 4294967296 and mem[_24809] + (32 * mem[mem[_24809] + _24809]) + 32 <= return_data.size
                                                mem[_24809 + ceil32(return_data.size)] = mem[mem[_24809] + _24809]
                                                _25961 = mem[_25132 + _24809]
                                                idx = 0
                                                while idx < 32 * _25961:
                                                    mem[_24809 + ceil32(return_data.size) + idx + 32] = mem[_25132 + _24809 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25961) + _24809 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20783 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20785 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20785:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20785) + _20783 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24804 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25122 = mem[_24804]
                                                    require mem[_24804] <= 4294967296
                                                    require mem[_24804] + 32 <= return_data.size
                                                    require mem[mem[_24804] + _24804] <= 4294967296 and mem[_24804] + (32 * mem[mem[_24804] + _24804]) + 32 <= return_data.size
                                                    mem[_24804 + ceil32(return_data.size)] = mem[mem[_24804] + _24804]
                                                    _25956 = mem[_25122 + _24804]
                                                    idx = 0
                                                    while idx < 32 * _25956:
                                                        mem[_24804 + ceil32(return_data.size) + idx + 32] = mem[_25122 + _24804 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25956) + _24804 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21209 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21209:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21209) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24805 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25124 = mem[_24805]
                                                    require mem[_24805] <= 4294967296
                                                    require mem[_24805] + 32 <= return_data.size
                                                    require mem[mem[_24805] + _24805] <= 4294967296 and mem[_24805] + (32 * mem[mem[_24805] + _24805]) + 32 <= return_data.size
                                                    mem[_24805 + ceil32(return_data.size)] = mem[mem[_24805] + _24805]
                                                    _25957 = mem[_25124 + _24805]
                                                    idx = 0
                                                    while idx < 32 * _25957:
                                                        mem[_24805 + ceil32(return_data.size) + idx + 32] = mem[_25124 + _24805 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25957) + _24805 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21211 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21213 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21213:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21213) + _21211 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24806 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25126 = mem[_24806]
                                                require mem[_24806] <= 4294967296
                                                require mem[_24806] + 32 <= return_data.size
                                                require mem[mem[_24806] + _24806] <= 4294967296 and mem[_24806] + (32 * mem[mem[_24806] + _24806]) + 32 <= return_data.size
                                                mem[_24806 + ceil32(return_data.size)] = mem[mem[_24806] + _24806]
                                                _25958 = mem[_25126 + _24806]
                                                idx = 0
                                                while idx < 32 * _25958:
                                                    mem[_24806 + ceil32(return_data.size) + idx + 32] = mem[_25126 + _24806 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25958) + _24806 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                        else:
                            mem[224] = 3
                            mem[256] = sub_c0b6201cAddress
                            mem[288] = baseTokenAddress
                            mem[320] = ETHAddress
                            mem[452] = this.address
                            mem[484] = block.timestamp + 30
                            mem[516] = 3
                            mem[548 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[548 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[420] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[352] = 2
                                    mem[64] = 448
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20747 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20749 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20749:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20749) + _20747 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24777 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25068 = mem[_24777]
                                                require mem[_24777] <= 4294967296
                                                require mem[_24777] + 32 <= return_data.size
                                                require mem[mem[_24777] + _24777] <= 4294967296 and mem[_24777] + (32 * mem[mem[_24777] + _24777]) + 32 <= return_data.size
                                                mem[_24777 + ceil32(return_data.size)] = mem[mem[_24777] + _24777]
                                                _25929 = mem[_25068 + _24777]
                                                idx = 0
                                                while idx < 32 * _25929:
                                                    mem[_24777 + ceil32(return_data.size) + idx + 32] = mem[_25068 + _24777 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25929) + _24777 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21135 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21137 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21137:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21137) + _21135 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24778 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25070 = mem[_24778]
                                                require mem[_24778] <= 4294967296
                                                require mem[_24778] + 32 <= return_data.size
                                                require mem[mem[_24778] + _24778] <= 4294967296 and mem[_24778] + (32 * mem[mem[_24778] + _24778]) + 32 <= return_data.size
                                                mem[_24778 + ceil32(return_data.size)] = mem[mem[_24778] + _24778]
                                                _25930 = mem[_25070 + _24778]
                                                idx = 0
                                                while idx < 32 * _25930:
                                                    mem[_24778 + ceil32(return_data.size) + idx + 32] = mem[_25070 + _24778 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25930) + _24778 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21139 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21141 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21141:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21141) + _21139 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24779 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25072 = mem[_24779]
                                            require mem[_24779] <= 4294967296
                                            require mem[_24779] + 32 <= return_data.size
                                            require mem[mem[_24779] + _24779] <= 4294967296 and mem[_24779] + (32 * mem[mem[_24779] + _24779]) + 32 <= return_data.size
                                            mem[_24779 + ceil32(return_data.size)] = mem[mem[_24779] + _24779]
                                            _25931 = mem[_25072 + _24779]
                                            idx = 0
                                            while idx < 32 * _25931:
                                                mem[_24779 + ceil32(return_data.size) + idx + 32] = mem[_25072 + _24779 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25931) + _24779 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[352] = 3
                                    mem[64] = 480
                                    mem[384] = ETHAddress
                                    mem[416] = baseTokenAddress
                                    mem[448] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20743 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20745 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20745:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20745) + _20743 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24774 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25062 = mem[_24774]
                                                require mem[_24774] <= 4294967296
                                                require mem[_24774] + 32 <= return_data.size
                                                require mem[mem[_24774] + _24774] <= 4294967296 and mem[_24774] + (32 * mem[mem[_24774] + _24774]) + 32 <= return_data.size
                                                mem[_24774 + ceil32(return_data.size)] = mem[mem[_24774] + _24774]
                                                _25926 = mem[_25062 + _24774]
                                                idx = 0
                                                while idx < 32 * _25926:
                                                    mem[_24774 + ceil32(return_data.size) + idx + 32] = mem[_25062 + _24774 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25926) + _24774 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21127 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21129 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21129:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21129) + _21127 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24775 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25064 = mem[_24775]
                                                require mem[_24775] <= 4294967296
                                                require mem[_24775] + 32 <= return_data.size
                                                require mem[mem[_24775] + _24775] <= 4294967296 and mem[_24775] + (32 * mem[mem[_24775] + _24775]) + 32 <= return_data.size
                                                mem[_24775 + ceil32(return_data.size)] = mem[mem[_24775] + _24775]
                                                _25927 = mem[_25064 + _24775]
                                                idx = 0
                                                while idx < 32 * _25927:
                                                    mem[_24775 + ceil32(return_data.size) + idx + 32] = mem[_25064 + _24775 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25927) + _24775 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21131 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21133 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21133:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21133) + _21131 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24776 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25066 = mem[_24776]
                                            require mem[_24776] <= 4294967296
                                            require mem[_24776] + 32 <= return_data.size
                                            require mem[mem[_24776] + _24776] <= 4294967296 and mem[_24776] + (32 * mem[mem[_24776] + _24776]) + 32 <= return_data.size
                                            mem[_24776 + ceil32(return_data.size)] = mem[mem[_24776] + _24776]
                                            _25928 = mem[_25066 + _24776]
                                            idx = 0
                                            while idx < 32 * _25928:
                                                mem[_24776 + ceil32(return_data.size) + idx + 32] = mem[_25066 + _24776 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _25928) + _24776 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[420] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[352] = 2
                                        mem[64] = 448
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20755 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20757 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _20757:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20757) + _20755 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24783 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25080 = mem[_24783]
                                                    require mem[_24783] <= 4294967296
                                                    require mem[_24783] + 32 <= return_data.size
                                                    require mem[mem[_24783] + _24783] <= 4294967296 and mem[_24783] + (32 * mem[mem[_24783] + _24783]) + 32 <= return_data.size
                                                    mem[_24783 + ceil32(return_data.size)] = mem[mem[_24783] + _24783]
                                                    _25935 = mem[_25080 + _24783]
                                                    idx = 0
                                                    while idx < 32 * _25935:
                                                        mem[_24783 + ceil32(return_data.size) + idx + 32] = mem[_25080 + _24783 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25935) + _24783 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21151 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21153 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21153:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21153) + _21151 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24784 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25082 = mem[_24784]
                                                    require mem[_24784] <= 4294967296
                                                    require mem[_24784] + 32 <= return_data.size
                                                    require mem[mem[_24784] + _24784] <= 4294967296 and mem[_24784] + (32 * mem[mem[_24784] + _24784]) + 32 <= return_data.size
                                                    mem[_24784 + ceil32(return_data.size)] = mem[mem[_24784] + _24784]
                                                    _25936 = mem[_25082 + _24784]
                                                    idx = 0
                                                    while idx < 32 * _25936:
                                                        mem[_24784 + ceil32(return_data.size) + idx + 32] = mem[_25082 + _24784 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25936) + _24784 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21155 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21157 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21157:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21157) + _21155 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24785 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25084 = mem[_24785]
                                                require mem[_24785] <= 4294967296
                                                require mem[_24785] + 32 <= return_data.size
                                                require mem[mem[_24785] + _24785] <= 4294967296 and mem[_24785] + (32 * mem[mem[_24785] + _24785]) + 32 <= return_data.size
                                                mem[_24785 + ceil32(return_data.size)] = mem[mem[_24785] + _24785]
                                                _25937 = mem[_25084 + _24785]
                                                idx = 0
                                                while idx < 32 * _25937:
                                                    mem[_24785 + ceil32(return_data.size) + idx + 32] = mem[_25084 + _24785 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25937) + _24785 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[352] = 3
                                        mem[64] = 480
                                        mem[384] = ETHAddress
                                        mem[416] = baseTokenAddress
                                        mem[448] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20751 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20753 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _20753:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20753) + _20751 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24780 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25074 = mem[_24780]
                                                    require mem[_24780] <= 4294967296
                                                    require mem[_24780] + 32 <= return_data.size
                                                    require mem[mem[_24780] + _24780] <= 4294967296 and mem[_24780] + (32 * mem[mem[_24780] + _24780]) + 32 <= return_data.size
                                                    mem[_24780 + ceil32(return_data.size)] = mem[mem[_24780] + _24780]
                                                    _25932 = mem[_25074 + _24780]
                                                    idx = 0
                                                    while idx < 32 * _25932:
                                                        mem[_24780 + ceil32(return_data.size) + idx + 32] = mem[_25074 + _24780 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25932) + _24780 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21143 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21145 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21145:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21145) + _21143 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24781 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25076 = mem[_24781]
                                                    require mem[_24781] <= 4294967296
                                                    require mem[_24781] + 32 <= return_data.size
                                                    require mem[mem[_24781] + _24781] <= 4294967296 and mem[_24781] + (32 * mem[mem[_24781] + _24781]) + 32 <= return_data.size
                                                    mem[_24781 + ceil32(return_data.size)] = mem[mem[_24781] + _24781]
                                                    _25933 = mem[_25076 + _24781]
                                                    idx = 0
                                                    while idx < 32 * _25933:
                                                        mem[_24781 + ceil32(return_data.size) + idx + 32] = mem[_25076 + _24781 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25933) + _24781 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21147 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21149 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21149:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21149) + _21147 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24782 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25078 = mem[_24782]
                                                require mem[_24782] <= 4294967296
                                                require mem[_24782] + 32 <= return_data.size
                                                require mem[mem[_24782] + _24782] <= 4294967296 and mem[_24782] + (32 * mem[mem[_24782] + _24782]) + 32 <= return_data.size
                                                mem[_24782 + ceil32(return_data.size)] = mem[mem[_24782] + _24782]
                                                _25934 = mem[_25078 + _24782]
                                                idx = 0
                                                while idx < 32 * _25934:
                                                    mem[_24782 + ceil32(return_data.size) + idx + 32] = mem[_25078 + _24782 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25934) + _24782 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[420] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[352] = 2
                                        mem[64] = 448
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20765 = mem[352]
                                                    t = 0
                                                    while t < 32 * _20765:
                                                        mem[mem[64] + t + 164] = mem[t + 384]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20765) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24789 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25092 = mem[_24789]
                                                    require mem[_24789] <= 4294967296
                                                    require mem[_24789] + 32 <= return_data.size
                                                    require mem[mem[_24789] + _24789] <= 4294967296 and mem[_24789] + (32 * mem[mem[_24789] + _24789]) + 32 <= return_data.size
                                                    mem[_24789 + ceil32(return_data.size)] = mem[mem[_24789] + _24789]
                                                    _25941 = mem[_25092 + _24789]
                                                    idx = 0
                                                    while idx < 32 * _25941:
                                                        mem[_24789 + ceil32(return_data.size) + idx + 32] = mem[_25092 + _24789 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25941) + _24789 + ceil32(return_data.size) + 32
                                                else:
                                                    if idx == wallets.length - 1:
                                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 0
                                                        mem[mem[64] + 68] = wallets[idx]
                                                        mem[mem[64] + 100] = block.timestamp
                                                        mem[mem[64] + 36] = 128
                                                        mem[mem[64] + 132] = mem[352]
                                                        _21173 = mem[352]
                                                        t = 0
                                                        while t < 32 * _21173:
                                                            mem[mem[64] + t + 164] = mem[t + 384]
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                           value eth.balance(this.address) wei
                                                             gas gas_remaining wei
                                                            args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21173) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _24791 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _25096 = mem[_24791]
                                                        require mem[_24791] <= 4294967296
                                                        require mem[_24791] + 32 <= return_data.size
                                                        require mem[mem[_24791] + _24791] <= 4294967296 and mem[_24791] + (32 * mem[mem[_24791] + _24791]) + 32 <= return_data.size
                                                        mem[_24791 + ceil32(return_data.size)] = mem[mem[_24791] + _24791]
                                                        _25943 = mem[_25096 + _24791]
                                                        idx = 0
                                                        while idx < 32 * _25943:
                                                            mem[_24791 + ceil32(return_data.size) + idx + 32] = mem[_25096 + _24791 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[64] = (32 * _25943) + _24791 + ceil32(return_data.size) + 32
                                                        s = s + 1
                                                        t = eth.balance(this.address)
                                                        continue 
                                                    _21167 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21169 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21169:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21169) + _21167 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24790 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25094 = mem[_24790]
                                                    require mem[_24790] <= 4294967296
                                                    require mem[_24790] + 32 <= return_data.size
                                                    require mem[mem[_24790] + _24790] <= 4294967296 and mem[_24790] + (32 * mem[mem[_24790] + _24790]) + 32 <= return_data.size
                                                    mem[_24790 + ceil32(return_data.size)] = mem[mem[_24790] + _24790]
                                                    _25942 = mem[_25094 + _24790]
                                                    idx = 0
                                                    while idx < 32 * _25942:
                                                        mem[_24790 + ceil32(return_data.size) + idx + 32] = mem[_25094 + _24790 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25942) + _24790 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[352] = 3
                                        mem[64] = 480
                                        mem[384] = ETHAddress
                                        mem[416] = baseTokenAddress
                                        mem[448] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20759 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20761 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _20761:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20761) + _20759 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24786 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25086 = mem[_24786]
                                                    require mem[_24786] <= 4294967296
                                                    require mem[_24786] + 32 <= return_data.size
                                                    require mem[mem[_24786] + _24786] <= 4294967296 and mem[_24786] + (32 * mem[mem[_24786] + _24786]) + 32 <= return_data.size
                                                    mem[_24786 + ceil32(return_data.size)] = mem[mem[_24786] + _24786]
                                                    _25938 = mem[_25086 + _24786]
                                                    idx = 0
                                                    while idx < 32 * _25938:
                                                        mem[_24786 + ceil32(return_data.size) + idx + 32] = mem[_25086 + _24786 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25938) + _24786 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                if idx != wallets.length - 1:
                                                    _21161 = mem[352]
                                                    t = 0
                                                    while t < 32 * _21161:
                                                        mem[mem[64] + t + 164] = mem[t + 384]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21161) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24787 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25088 = mem[_24787]
                                                    require mem[_24787] <= 4294967296
                                                    require mem[_24787] + 32 <= return_data.size
                                                    require mem[mem[_24787] + _24787] <= 4294967296 and mem[_24787] + (32 * mem[mem[_24787] + _24787]) + 32 <= return_data.size
                                                    mem[_24787 + ceil32(return_data.size)] = mem[mem[_24787] + _24787]
                                                    _25939 = mem[_25088 + _24787]
                                                    idx = 0
                                                    while idx < 32 * _25939:
                                                        mem[_24787 + ceil32(return_data.size) + idx + 32] = mem[_25088 + _24787 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _25939) + _24787 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21165 = mem[352]
                                                t = 0
                                                while t < 32 * _21165:
                                                    mem[mem[64] + t + 164] = mem[t + 384]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21165) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24788 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25090 = mem[_24788]
                                                require mem[_24788] <= 4294967296
                                                require mem[_24788] + 32 <= return_data.size
                                                require mem[mem[_24788] + _24788] <= 4294967296 and mem[_24788] + (32 * mem[mem[_24788] + _24788]) + 32 <= return_data.size
                                                mem[_24788 + ceil32(return_data.size)] = mem[mem[_24788] + _24788]
                                                _25940 = mem[_25090 + _24788]
                                                idx = 0
                                                while idx < 32 * _25940:
                                                    mem[_24788 + ceil32(return_data.size) + idx + 32] = mem[_25090 + _24788 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _25940) + _24788 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                    if eth.balance(this.address) > 0:
                        if bool(stor9[address(msg.sender)]) != 1:
                            revert with 0, 
                                        32,
                                        56,
                                        0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                        mem[mem[64] + 124 len 8]
                        call msg.sender with:
                           value eth.balance(this.address) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
    else:
        if sub_fce62d8f <= minLp:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        49,
                        0x746f20746f6b656e2074656d206d656e6f73206c6971756964657a20717565206f20736575206d696e696d6f20616d6967,
                        mem[213 len 15]
        if not mode:
            require ext_code.size(baseTokenAddress)
            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, -1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if baseTokenAddress == ETHAddress:
                mem[96] = 2
                mem[64] = 192
                mem[128] = baseTokenAddress
                mem[160] = sub_c0b6201cAddress
                require sub_43ff02f6 * wallets.length
                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                idx = 0
                while idx < wallets.length:
                    s = 0
                    t = 0
                    while s < sub_43ff02f6:
                        require idx < wallets.length
                        mem[0] = 10
                        if s != sub_43ff02f6 - 1:
                            _11363 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11363 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16683 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _17096 = mem[_16683]
                            require mem[_16683] <= 4294967296
                            require mem[_16683] + 32 <= return_data.size
                            require mem[mem[_16683] + _16683] <= 4294967296 and mem[_16683] + (32 * mem[mem[_16683] + _16683]) + 32 <= return_data.size
                            mem[_16683 + ceil32(return_data.size)] = mem[mem[_16683] + _16683]
                            _17575 = mem[_17096 + _16683]
                            idx = 0
                            while idx < 32 * _17575:
                                mem[_16683 + ceil32(return_data.size) + idx + 32] = mem[_17096 + _16683 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17575) + _16683 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        if idx != wallets.length - 1:
                            _11415 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11415 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16684 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _17098 = mem[_16684]
                            require mem[_16684] <= 4294967296
                            require mem[_16684] + 32 <= return_data.size
                            require mem[mem[_16684] + _16684] <= 4294967296 and mem[_16684] + (32 * mem[mem[_16684] + _16684]) + 32 <= return_data.size
                            mem[_16684 + ceil32(return_data.size)] = mem[mem[_16684] + _16684]
                            _17576 = mem[_17098 + _16684]
                            idx = 0
                            while idx < 32 * _17576:
                                mem[_16684 + ceil32(return_data.size) + idx + 32] = mem[_17098 + _16684 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17576) + _16684 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        _11419 = mem[64]
                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        mem[mem[64] + 68] = wallets[idx]
                        mem[mem[64] + 100] = block.timestamp
                        mem[mem[64] + 36] = 128
                        mem[mem[64] + 132] = mem[96]
                        idx = 0
                        while idx < 32 * mem[96]:
                            mem[mem[64] + idx + 164] = mem[idx + 128]
                            idx = idx + 32
                            continue 
                        require ext_code.size(routerAddress)
                        call routerAddress.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (32 * mem[96]) + _11419 + -mem[64] + 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16685 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _17100 = mem[_16685]
                        require mem[_16685] <= 4294967296
                        require mem[_16685] + 32 <= return_data.size
                        require mem[mem[_16685] + _16685] <= 4294967296 and mem[_16685] + (32 * mem[mem[_16685] + _16685]) + 32 <= return_data.size
                        mem[_16685 + ceil32(return_data.size)] = mem[mem[_16685] + _16685]
                        _17577 = mem[_17100 + _16685]
                        idx = 0
                        while idx < 32 * _17577:
                            mem[_16685 + ceil32(return_data.size) + idx + 32] = mem[_17100 + _16685 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[64] = (32 * _17577) + _16685 + ceil32(return_data.size) + 32
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
            else:
                mem[96] = 3
                mem[64] = 224
                mem[128] = ETHAddress
                mem[160] = baseTokenAddress
                mem[192] = sub_c0b6201cAddress
                require sub_43ff02f6 * wallets.length
                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                idx = 0
                while idx < wallets.length:
                    s = 0
                    t = 0
                    while s < sub_43ff02f6:
                        require idx < wallets.length
                        mem[0] = 10
                        if s != sub_43ff02f6 - 1:
                            _11359 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11359 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16680 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _17090 = mem[_16680]
                            require mem[_16680] <= 4294967296
                            require mem[_16680] + 32 <= return_data.size
                            require mem[mem[_16680] + _16680] <= 4294967296 and mem[_16680] + (32 * mem[mem[_16680] + _16680]) + 32 <= return_data.size
                            mem[_16680 + ceil32(return_data.size)] = mem[mem[_16680] + _16680]
                            _17572 = mem[_17090 + _16680]
                            idx = 0
                            while idx < 32 * _17572:
                                mem[_16680 + ceil32(return_data.size) + idx + 32] = mem[_17090 + _16680 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17572) + _16680 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        if idx != wallets.length - 1:
                            _11407 = mem[64]
                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0
                            mem[mem[64] + 68] = wallets[idx]
                            mem[mem[64] + 100] = block.timestamp
                            mem[mem[64] + 36] = 128
                            mem[mem[64] + 132] = mem[96]
                            idx = 0
                            while idx < 32 * mem[96]:
                                mem[mem[64] + idx + 164] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.mem[mem[64] len 4] with:
                               value sub_1ef782ba wei
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (32 * mem[96]) + _11407 + -mem[64] + 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16681 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _17092 = mem[_16681]
                            require mem[_16681] <= 4294967296
                            require mem[_16681] + 32 <= return_data.size
                            require mem[mem[_16681] + _16681] <= 4294967296 and mem[_16681] + (32 * mem[mem[_16681] + _16681]) + 32 <= return_data.size
                            mem[_16681 + ceil32(return_data.size)] = mem[mem[_16681] + _16681]
                            _17573 = mem[_17092 + _16681]
                            idx = 0
                            while idx < 32 * _17573:
                                mem[_16681 + ceil32(return_data.size) + idx + 32] = mem[_17092 + _16681 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[64] = (32 * _17573) + _16681 + ceil32(return_data.size) + 32
                            s = s + 1
                            t = sub_1ef782ba
                            continue 
                        _11411 = mem[64]
                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        mem[mem[64] + 68] = wallets[idx]
                        mem[mem[64] + 100] = block.timestamp
                        mem[mem[64] + 36] = 128
                        mem[mem[64] + 132] = mem[96]
                        idx = 0
                        while idx < 32 * mem[96]:
                            mem[mem[64] + idx + 164] = mem[idx + 128]
                            idx = idx + 32
                            continue 
                        require ext_code.size(routerAddress)
                        call routerAddress.mem[mem[64] len 4] with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (32 * mem[96]) + _11411 + -mem[64] + 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16682 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _17094 = mem[_16682]
                        require mem[_16682] <= 4294967296
                        require mem[_16682] + 32 <= return_data.size
                        require mem[mem[_16682] + _16682] <= 4294967296 and mem[_16682] + (32 * mem[mem[_16682] + _16682]) + 32 <= return_data.size
                        mem[_16682 + ceil32(return_data.size)] = mem[mem[_16682] + _16682]
                        _17574 = mem[_17094 + _16682]
                        idx = 0
                        while idx < 32 * _17574:
                            mem[_16682 + ceil32(return_data.size) + idx + 32] = mem[_17094 + _16682 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[64] = (32 * _17574) + _16682 + ceil32(return_data.size) + 32
                        s = s + 1
                        t = eth.balance(this.address)
                        continue 
                    idx = idx + 1
                    continue 
            if eth.balance(this.address) > 0:
                if bool(stor9[address(msg.sender)]) != 1:
                    revert with 0, 
                                32,
                                56,
                                0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                mem[mem[64] + 124 len 8]
                call msg.sender with:
                   value eth.balance(this.address) wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
        else:
            if mode == 1:
                require ext_code.size(ETHAddress)
                call ETHAddress.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args routerAddress, -1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(baseTokenAddress)
                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args routerAddress, -1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if baseTokenAddress == ETHAddress:
                    mem[96] = 2
                    mem[128] = baseTokenAddress
                    mem[160] = sub_c0b6201cAddress
                    mem[356 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 2, mem[356 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sub_c0b6201cAddress)
                    staticcall sub_c0b6201cAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(sub_c0b6201cAddress)
                    call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(baseTokenAddress)
                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if baseTokenAddress == ETHAddress:
                        mem[192] = 2
                        mem[224] = sub_c0b6201cAddress
                        mem[256] = baseTokenAddress
                        mem[388] = this.address
                        mem[420] = block.timestamp + 30
                        mem[452] = 2
                        mem[484 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[484 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[356] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), wallets, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[288] = 2
                                mem[64] = 384
                                mem[320] = baseTokenAddress
                                mem[352] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _21107 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21109 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21109:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21109) + _21107 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25047 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25608 = mem[_25047]
                                            require mem[_25047] <= 4294967296
                                            require mem[_25047] + 32 <= return_data.size
                                            require mem[mem[_25047] + _25047] <= 4294967296 and mem[_25047] + (32 * mem[mem[_25047] + _25047]) + 32 <= return_data.size
                                            mem[_25047 + ceil32(return_data.size)] = mem[mem[_25047] + _25047]
                                            _26199 = mem[_25608 + _25047]
                                            idx = 0
                                            while idx < 32 * _26199:
                                                mem[_25047 + ceil32(return_data.size) + idx + 32] = mem[_25608 + _25047 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26199) + _25047 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21855 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21857 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21857:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21857) + _21855 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25048 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25610 = mem[_25048]
                                            require mem[_25048] <= 4294967296
                                            require mem[_25048] + 32 <= return_data.size
                                            require mem[mem[_25048] + _25048] <= 4294967296 and mem[_25048] + (32 * mem[mem[_25048] + _25048]) + 32 <= return_data.size
                                            mem[_25048 + ceil32(return_data.size)] = mem[mem[_25048] + _25048]
                                            _26200 = mem[_25610 + _25048]
                                            idx = 0
                                            while idx < 32 * _26200:
                                                mem[_25048 + ceil32(return_data.size) + idx + 32] = mem[_25610 + _25048 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26200) + _25048 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21859 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[288]
                                        _21861 = mem[288]
                                        idx = 0
                                        while idx < 32 * _21861:
                                            mem[mem[64] + idx + 164] = mem[idx + 320]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21861) + _21859 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25049 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25612 = mem[_25049]
                                        require mem[_25049] <= 4294967296
                                        require mem[_25049] + 32 <= return_data.size
                                        require mem[mem[_25049] + _25049] <= 4294967296 and mem[_25049] + (32 * mem[mem[_25049] + _25049]) + 32 <= return_data.size
                                        mem[_25049 + ceil32(return_data.size)] = mem[mem[_25049] + _25049]
                                        _26201 = mem[_25612 + _25049]
                                        idx = 0
                                        while idx < 32 * _26201:
                                            mem[_25049 + ceil32(return_data.size) + idx + 32] = mem[_25612 + _25049 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26201) + _25049 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[288] = 3
                                mem[64] = 416
                                mem[320] = ETHAddress
                                mem[352] = baseTokenAddress
                                mem[384] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _21103 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21105 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21105:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21105) + _21103 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25044 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25602 = mem[_25044]
                                            require mem[_25044] <= 4294967296
                                            require mem[_25044] + 32 <= return_data.size
                                            require mem[mem[_25044] + _25044] <= 4294967296 and mem[_25044] + (32 * mem[mem[_25044] + _25044]) + 32 <= return_data.size
                                            mem[_25044 + ceil32(return_data.size)] = mem[mem[_25044] + _25044]
                                            _26196 = mem[_25602 + _25044]
                                            idx = 0
                                            while idx < 32 * _26196:
                                                mem[_25044 + ceil32(return_data.size) + idx + 32] = mem[_25602 + _25044 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26196) + _25044 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21847 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21849 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21849:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21849) + _21847 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25045 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25604 = mem[_25045]
                                            require mem[_25045] <= 4294967296
                                            require mem[_25045] + 32 <= return_data.size
                                            require mem[mem[_25045] + _25045] <= 4294967296 and mem[_25045] + (32 * mem[mem[_25045] + _25045]) + 32 <= return_data.size
                                            mem[_25045 + ceil32(return_data.size)] = mem[mem[_25045] + _25045]
                                            _26197 = mem[_25604 + _25045]
                                            idx = 0
                                            while idx < 32 * _26197:
                                                mem[_25045 + ceil32(return_data.size) + idx + 32] = mem[_25604 + _25045 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26197) + _25045 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21851 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[288]
                                        _21853 = mem[288]
                                        idx = 0
                                        while idx < 32 * _21853:
                                            mem[mem[64] + idx + 164] = mem[idx + 320]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21853) + _21851 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25046 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25606 = mem[_25046]
                                        require mem[_25046] <= 4294967296
                                        require mem[_25046] + 32 <= return_data.size
                                        require mem[mem[_25046] + _25046] <= 4294967296 and mem[_25046] + (32 * mem[mem[_25046] + _25046]) + 32 <= return_data.size
                                        mem[_25046 + ceil32(return_data.size)] = mem[mem[_25046] + _25046]
                                        _26198 = mem[_25606 + _25046]
                                        idx = 0
                                        while idx < 32 * _26198:
                                            mem[_25046 + ceil32(return_data.size) + idx + 32] = mem[_25606 + _25046 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26198) + _25046 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[356] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[288] = 2
                                    mem[64] = 384
                                    mem[320] = baseTokenAddress
                                    mem[352] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21115 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21117 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21117:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21117) + _21115 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25053 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25620 = mem[_25053]
                                                require mem[_25053] <= 4294967296
                                                require mem[_25053] + 32 <= return_data.size
                                                require mem[mem[_25053] + _25053] <= 4294967296 and mem[_25053] + (32 * mem[mem[_25053] + _25053]) + 32 <= return_data.size
                                                mem[_25053 + ceil32(return_data.size)] = mem[mem[_25053] + _25053]
                                                _26205 = mem[_25620 + _25053]
                                                idx = 0
                                                while idx < 32 * _26205:
                                                    mem[_25053 + ceil32(return_data.size) + idx + 32] = mem[_25620 + _25053 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26205) + _25053 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21871 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21873 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21873:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21873) + _21871 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25054 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25622 = mem[_25054]
                                                require mem[_25054] <= 4294967296
                                                require mem[_25054] + 32 <= return_data.size
                                                require mem[mem[_25054] + _25054] <= 4294967296 and mem[_25054] + (32 * mem[mem[_25054] + _25054]) + 32 <= return_data.size
                                                mem[_25054 + ceil32(return_data.size)] = mem[mem[_25054] + _25054]
                                                _26206 = mem[_25622 + _25054]
                                                idx = 0
                                                while idx < 32 * _26206:
                                                    mem[_25054 + ceil32(return_data.size) + idx + 32] = mem[_25622 + _25054 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26206) + _25054 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21875 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21877 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21877:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21877) + _21875 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25055 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25624 = mem[_25055]
                                            require mem[_25055] <= 4294967296
                                            require mem[_25055] + 32 <= return_data.size
                                            require mem[mem[_25055] + _25055] <= 4294967296 and mem[_25055] + (32 * mem[mem[_25055] + _25055]) + 32 <= return_data.size
                                            mem[_25055 + ceil32(return_data.size)] = mem[mem[_25055] + _25055]
                                            _26207 = mem[_25624 + _25055]
                                            idx = 0
                                            while idx < 32 * _26207:
                                                mem[_25055 + ceil32(return_data.size) + idx + 32] = mem[_25624 + _25055 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26207) + _25055 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[288] = 3
                                    mem[64] = 416
                                    mem[320] = ETHAddress
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21111 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21113 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21113:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21113) + _21111 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25050 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25614 = mem[_25050]
                                                require mem[_25050] <= 4294967296
                                                require mem[_25050] + 32 <= return_data.size
                                                require mem[mem[_25050] + _25050] <= 4294967296 and mem[_25050] + (32 * mem[mem[_25050] + _25050]) + 32 <= return_data.size
                                                mem[_25050 + ceil32(return_data.size)] = mem[mem[_25050] + _25050]
                                                _26202 = mem[_25614 + _25050]
                                                idx = 0
                                                while idx < 32 * _26202:
                                                    mem[_25050 + ceil32(return_data.size) + idx + 32] = mem[_25614 + _25050 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26202) + _25050 + ceil32(return_data.size) + 32
                                            else:
                                                if idx == wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21869 = mem[288]
                                                    t = 0
                                                    while t < 32 * _21869:
                                                        mem[mem[64] + t + 164] = mem[t + 320]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value eth.balance(this.address) wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21869) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _25052 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25618 = mem[_25052]
                                                    require mem[_25052] <= 4294967296
                                                    require mem[_25052] + 32 <= return_data.size
                                                    require mem[mem[_25052] + _25052] <= 4294967296 and mem[_25052] + (32 * mem[mem[_25052] + _25052]) + 32 <= return_data.size
                                                    mem[_25052 + ceil32(return_data.size)] = mem[mem[_25052] + _25052]
                                                    _26204 = mem[_25618 + _25052]
                                                    idx = 0
                                                    while idx < 32 * _26204:
                                                        mem[_25052 + ceil32(return_data.size) + idx + 32] = mem[_25618 + _25052 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26204) + _25052 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = eth.balance(this.address)
                                                    continue 
                                                _21863 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21865 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21865:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21865) + _21863 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25051 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25616 = mem[_25051]
                                                require mem[_25051] <= 4294967296
                                                require mem[_25051] + 32 <= return_data.size
                                                require mem[mem[_25051] + _25051] <= 4294967296 and mem[_25051] + (32 * mem[mem[_25051] + _25051]) + 32 <= return_data.size
                                                mem[_25051 + ceil32(return_data.size)] = mem[mem[_25051] + _25051]
                                                _26203 = mem[_25616 + _25051]
                                                idx = 0
                                                while idx < 32 * _26203:
                                                    mem[_25051 + ceil32(return_data.size) + idx + 32] = mem[_25616 + _25051 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26203) + _25051 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[356] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[288] = 2
                                    mem[64] = 384
                                    mem[320] = baseTokenAddress
                                    mem[352] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21123 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21125 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21125:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21125) + _21123 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25059 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25632 = mem[_25059]
                                                require mem[_25059] <= 4294967296
                                                require mem[_25059] + 32 <= return_data.size
                                                require mem[mem[_25059] + _25059] <= 4294967296 and mem[_25059] + (32 * mem[mem[_25059] + _25059]) + 32 <= return_data.size
                                                mem[_25059 + ceil32(return_data.size)] = mem[mem[_25059] + _25059]
                                                _26211 = mem[_25632 + _25059]
                                                idx = 0
                                                while idx < 32 * _26211:
                                                    mem[_25059 + ceil32(return_data.size) + idx + 32] = mem[_25632 + _25059 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26211) + _25059 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21887 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21889 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21889:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21889) + _21887 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25060 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25634 = mem[_25060]
                                                require mem[_25060] <= 4294967296
                                                require mem[_25060] + 32 <= return_data.size
                                                require mem[mem[_25060] + _25060] <= 4294967296 and mem[_25060] + (32 * mem[mem[_25060] + _25060]) + 32 <= return_data.size
                                                mem[_25060 + ceil32(return_data.size)] = mem[mem[_25060] + _25060]
                                                _26212 = mem[_25634 + _25060]
                                                idx = 0
                                                while idx < 32 * _26212:
                                                    mem[_25060 + ceil32(return_data.size) + idx + 32] = mem[_25634 + _25060 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26212) + _25060 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21891 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21893 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21893:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21893) + _21891 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25061 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25636 = mem[_25061]
                                            require mem[_25061] <= 4294967296
                                            require mem[_25061] + 32 <= return_data.size
                                            require mem[mem[_25061] + _25061] <= 4294967296 and mem[_25061] + (32 * mem[mem[_25061] + _25061]) + 32 <= return_data.size
                                            mem[_25061 + ceil32(return_data.size)] = mem[mem[_25061] + _25061]
                                            _26213 = mem[_25636 + _25061]
                                            idx = 0
                                            while idx < 32 * _26213:
                                                mem[_25061 + ceil32(return_data.size) + idx + 32] = mem[_25636 + _25061 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26213) + _25061 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[288] = 3
                                    mem[64] = 416
                                    mem[320] = ETHAddress
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21119 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21121 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21121:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21121) + _21119 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25056 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25626 = mem[_25056]
                                                require mem[_25056] <= 4294967296
                                                require mem[_25056] + 32 <= return_data.size
                                                require mem[mem[_25056] + _25056] <= 4294967296 and mem[_25056] + (32 * mem[mem[_25056] + _25056]) + 32 <= return_data.size
                                                mem[_25056 + ceil32(return_data.size)] = mem[mem[_25056] + _25056]
                                                _26208 = mem[_25626 + _25056]
                                                idx = 0
                                                while idx < 32 * _26208:
                                                    mem[_25056 + ceil32(return_data.size) + idx + 32] = mem[_25626 + _25056 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26208) + _25056 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21879 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21881 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21881:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21881) + _21879 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25057 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25628 = mem[_25057]
                                                require mem[_25057] <= 4294967296
                                                require mem[_25057] + 32 <= return_data.size
                                                require mem[mem[_25057] + _25057] <= 4294967296 and mem[_25057] + (32 * mem[mem[_25057] + _25057]) + 32 <= return_data.size
                                                mem[_25057 + ceil32(return_data.size)] = mem[mem[_25057] + _25057]
                                                _26209 = mem[_25628 + _25057]
                                                idx = 0
                                                while idx < 32 * _26209:
                                                    mem[_25057 + ceil32(return_data.size) + idx + 32] = mem[_25628 + _25057 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26209) + _25057 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21883 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21885 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21885:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21885) + _21883 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25058 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25630 = mem[_25058]
                                            require mem[_25058] <= 4294967296
                                            require mem[_25058] + 32 <= return_data.size
                                            require mem[mem[_25058] + _25058] <= 4294967296 and mem[_25058] + (32 * mem[mem[_25058] + _25058]) + 32 <= return_data.size
                                            mem[_25058 + ceil32(return_data.size)] = mem[mem[_25058] + _25058]
                                            _26210 = mem[_25630 + _25058]
                                            idx = 0
                                            while idx < 32 * _26210:
                                                mem[_25058 + ceil32(return_data.size) + idx + 32] = mem[_25630 + _25058 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26210) + _25058 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                    else:
                        mem[192] = 3
                        mem[224] = sub_c0b6201cAddress
                        mem[256] = baseTokenAddress
                        mem[288] = ETHAddress
                        mem[420] = this.address
                        mem[452] = block.timestamp + 30
                        mem[484] = 3
                        mem[516 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[516 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[388] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, wallets, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, 0, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[320] = 2
                                mem[64] = 416
                                mem[352] = baseTokenAddress
                                mem[384] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _21083 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21085 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21085:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21085) + _21083 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25029 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25572 = mem[_25029]
                                            require mem[_25029] <= 4294967296
                                            require mem[_25029] + 32 <= return_data.size
                                            require mem[mem[_25029] + _25029] <= 4294967296 and mem[_25029] + (32 * mem[mem[_25029] + _25029]) + 32 <= return_data.size
                                            mem[_25029 + ceil32(return_data.size)] = mem[mem[_25029] + _25029]
                                            _26181 = mem[_25572 + _25029]
                                            idx = 0
                                            while idx < 32 * _26181:
                                                mem[_25029 + ceil32(return_data.size) + idx + 32] = mem[_25572 + _25029 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26181) + _25029 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21807 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21809 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21809:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21809) + _21807 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25030 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25574 = mem[_25030]
                                            require mem[_25030] <= 4294967296
                                            require mem[_25030] + 32 <= return_data.size
                                            require mem[mem[_25030] + _25030] <= 4294967296 and mem[_25030] + (32 * mem[mem[_25030] + _25030]) + 32 <= return_data.size
                                            mem[_25030 + ceil32(return_data.size)] = mem[mem[_25030] + _25030]
                                            _26182 = mem[_25574 + _25030]
                                            idx = 0
                                            while idx < 32 * _26182:
                                                mem[_25030 + ceil32(return_data.size) + idx + 32] = mem[_25574 + _25030 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26182) + _25030 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21811 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21813 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21813:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21813) + _21811 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25031 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25576 = mem[_25031]
                                        require mem[_25031] <= 4294967296
                                        require mem[_25031] + 32 <= return_data.size
                                        require mem[mem[_25031] + _25031] <= 4294967296 and mem[_25031] + (32 * mem[mem[_25031] + _25031]) + 32 <= return_data.size
                                        mem[_25031 + ceil32(return_data.size)] = mem[mem[_25031] + _25031]
                                        _26183 = mem[_25576 + _25031]
                                        idx = 0
                                        while idx < 32 * _26183:
                                            mem[_25031 + ceil32(return_data.size) + idx + 32] = mem[_25576 + _25031 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26183) + _25031 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[320] = 3
                                mem[64] = 448
                                mem[352] = ETHAddress
                                mem[384] = baseTokenAddress
                                mem[416] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _21079 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21081 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21081:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21081) + _21079 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25026 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25566 = mem[_25026]
                                            require mem[_25026] <= 4294967296
                                            require mem[_25026] + 32 <= return_data.size
                                            require mem[mem[_25026] + _25026] <= 4294967296 and mem[_25026] + (32 * mem[mem[_25026] + _25026]) + 32 <= return_data.size
                                            mem[_25026 + ceil32(return_data.size)] = mem[mem[_25026] + _25026]
                                            _26178 = mem[_25566 + _25026]
                                            idx = 0
                                            while idx < 32 * _26178:
                                                mem[_25026 + ceil32(return_data.size) + idx + 32] = mem[_25566 + _25026 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26178) + _25026 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21799 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21801 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21801:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21801) + _21799 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25027 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25568 = mem[_25027]
                                            require mem[_25027] <= 4294967296
                                            require mem[_25027] + 32 <= return_data.size
                                            require mem[mem[_25027] + _25027] <= 4294967296 and mem[_25027] + (32 * mem[mem[_25027] + _25027]) + 32 <= return_data.size
                                            mem[_25027 + ceil32(return_data.size)] = mem[mem[_25027] + _25027]
                                            _26179 = mem[_25568 + _25027]
                                            idx = 0
                                            while idx < 32 * _26179:
                                                mem[_25027 + ceil32(return_data.size) + idx + 32] = mem[_25568 + _25027 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26179) + _25027 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21803 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21805 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21805:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21805) + _21803 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25028 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25570 = mem[_25028]
                                        require mem[_25028] <= 4294967296
                                        require mem[_25028] + 32 <= return_data.size
                                        require mem[mem[_25028] + _25028] <= 4294967296 and mem[_25028] + (32 * mem[mem[_25028] + _25028]) + 32 <= return_data.size
                                        mem[_25028 + ceil32(return_data.size)] = mem[mem[_25028] + _25028]
                                        _26180 = mem[_25570 + _25028]
                                        idx = 0
                                        while idx < 32 * _26180:
                                            mem[_25028 + ceil32(return_data.size) + idx + 32] = mem[_25570 + _25028 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26180) + _25028 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21093 = mem[320]
                                                t = 0
                                                while t < 32 * _21093:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21093) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25035 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25584 = mem[_25035]
                                                require mem[_25035] <= 4294967296
                                                require mem[_25035] + 32 <= return_data.size
                                                require mem[mem[_25035] + _25035] <= 4294967296 and mem[_25035] + (32 * mem[mem[_25035] + _25035]) + 32 <= return_data.size
                                                mem[_25035 + ceil32(return_data.size)] = mem[mem[_25035] + _25035]
                                                _26187 = mem[_25584 + _25035]
                                                idx = 0
                                                while idx < 32 * _26187:
                                                    mem[_25035 + ceil32(return_data.size) + idx + 32] = mem[_25584 + _25035 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26187) + _25035 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21823 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21825 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21825:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21825) + _21823 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25036 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25586 = mem[_25036]
                                                require mem[_25036] <= 4294967296
                                                require mem[_25036] + 32 <= return_data.size
                                                require mem[mem[_25036] + _25036] <= 4294967296 and mem[_25036] + (32 * mem[mem[_25036] + _25036]) + 32 <= return_data.size
                                                mem[_25036 + ceil32(return_data.size)] = mem[mem[_25036] + _25036]
                                                _26188 = mem[_25586 + _25036]
                                                idx = 0
                                                while idx < 32 * _26188:
                                                    mem[_25036 + ceil32(return_data.size) + idx + 32] = mem[_25586 + _25036 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26188) + _25036 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21827 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21829 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21829:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21829) + _21827 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25037 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25588 = mem[_25037]
                                            require mem[_25037] <= 4294967296
                                            require mem[_25037] + 32 <= return_data.size
                                            require mem[mem[_25037] + _25037] <= 4294967296 and mem[_25037] + (32 * mem[mem[_25037] + _25037]) + 32 <= return_data.size
                                            mem[_25037 + ceil32(return_data.size)] = mem[mem[_25037] + _25037]
                                            _26189 = mem[_25588 + _25037]
                                            idx = 0
                                            while idx < 32 * _26189:
                                                mem[_25037 + ceil32(return_data.size) + idx + 32] = mem[_25588 + _25037 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26189) + _25037 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21087 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21089 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21089:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21089) + _21087 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25032 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25578 = mem[_25032]
                                                require mem[_25032] <= 4294967296
                                                require mem[_25032] + 32 <= return_data.size
                                                require mem[mem[_25032] + _25032] <= 4294967296 and mem[_25032] + (32 * mem[mem[_25032] + _25032]) + 32 <= return_data.size
                                                mem[_25032 + ceil32(return_data.size)] = mem[mem[_25032] + _25032]
                                                _26184 = mem[_25578 + _25032]
                                                idx = 0
                                                while idx < 32 * _26184:
                                                    mem[_25032 + ceil32(return_data.size) + idx + 32] = mem[_25578 + _25032 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26184) + _25032 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21815 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21817 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21817:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21817) + _21815 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25033 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25580 = mem[_25033]
                                                require mem[_25033] <= 4294967296
                                                require mem[_25033] + 32 <= return_data.size
                                                require mem[mem[_25033] + _25033] <= 4294967296 and mem[_25033] + (32 * mem[mem[_25033] + _25033]) + 32 <= return_data.size
                                                mem[_25033 + ceil32(return_data.size)] = mem[mem[_25033] + _25033]
                                                _26185 = mem[_25580 + _25033]
                                                idx = 0
                                                while idx < 32 * _26185:
                                                    mem[_25033 + ceil32(return_data.size) + idx + 32] = mem[_25580 + _25033 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26185) + _25033 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21819 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21821 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21821:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21821) + _21819 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25034 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25582 = mem[_25034]
                                            require mem[_25034] <= 4294967296
                                            require mem[_25034] + 32 <= return_data.size
                                            require mem[mem[_25034] + _25034] <= 4294967296 and mem[_25034] + (32 * mem[mem[_25034] + _25034]) + 32 <= return_data.size
                                            mem[_25034 + ceil32(return_data.size)] = mem[mem[_25034] + _25034]
                                            _26186 = mem[_25582 + _25034]
                                            idx = 0
                                            while idx < 32 * _26186:
                                                mem[_25034 + ceil32(return_data.size) + idx + 32] = mem[_25582 + _25034 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26186) + _25034 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21099 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21101 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21101:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21101) + _21099 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25041 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25596 = mem[_25041]
                                                require mem[_25041] <= 4294967296
                                                require mem[_25041] + 32 <= return_data.size
                                                require mem[mem[_25041] + _25041] <= 4294967296 and mem[_25041] + (32 * mem[mem[_25041] + _25041]) + 32 <= return_data.size
                                                mem[_25041 + ceil32(return_data.size)] = mem[mem[_25041] + _25041]
                                                _26193 = mem[_25596 + _25041]
                                                idx = 0
                                                while idx < 32 * _26193:
                                                    mem[_25041 + ceil32(return_data.size) + idx + 32] = mem[_25596 + _25041 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26193) + _25041 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21839 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21841 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21841:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21841) + _21839 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25042 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25598 = mem[_25042]
                                                require mem[_25042] <= 4294967296
                                                require mem[_25042] + 32 <= return_data.size
                                                require mem[mem[_25042] + _25042] <= 4294967296 and mem[_25042] + (32 * mem[mem[_25042] + _25042]) + 32 <= return_data.size
                                                mem[_25042 + ceil32(return_data.size)] = mem[mem[_25042] + _25042]
                                                _26194 = mem[_25598 + _25042]
                                                idx = 0
                                                while idx < 32 * _26194:
                                                    mem[_25042 + ceil32(return_data.size) + idx + 32] = mem[_25598 + _25042 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26194) + _25042 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21843 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21845 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21845:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21845) + _21843 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25043 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25600 = mem[_25043]
                                            require mem[_25043] <= 4294967296
                                            require mem[_25043] + 32 <= return_data.size
                                            require mem[mem[_25043] + _25043] <= 4294967296 and mem[_25043] + (32 * mem[mem[_25043] + _25043]) + 32 <= return_data.size
                                            mem[_25043 + ceil32(return_data.size)] = mem[mem[_25043] + _25043]
                                            _26195 = mem[_25600 + _25043]
                                            idx = 0
                                            while idx < 32 * _26195:
                                                mem[_25043 + ceil32(return_data.size) + idx + 32] = mem[_25600 + _25043 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26195) + _25043 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21095 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21097 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21097:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21097) + _21095 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25038 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25590 = mem[_25038]
                                                require mem[_25038] <= 4294967296
                                                require mem[_25038] + 32 <= return_data.size
                                                require mem[mem[_25038] + _25038] <= 4294967296 and mem[_25038] + (32 * mem[mem[_25038] + _25038]) + 32 <= return_data.size
                                                mem[_25038 + ceil32(return_data.size)] = mem[mem[_25038] + _25038]
                                                _26190 = mem[_25590 + _25038]
                                                idx = 0
                                                while idx < 32 * _26190:
                                                    mem[_25038 + ceil32(return_data.size) + idx + 32] = mem[_25590 + _25038 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26190) + _25038 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21831 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21833 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21833:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21833) + _21831 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25039 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25592 = mem[_25039]
                                                require mem[_25039] <= 4294967296
                                                require mem[_25039] + 32 <= return_data.size
                                                require mem[mem[_25039] + _25039] <= 4294967296 and mem[_25039] + (32 * mem[mem[_25039] + _25039]) + 32 <= return_data.size
                                                mem[_25039 + ceil32(return_data.size)] = mem[mem[_25039] + _25039]
                                                _26191 = mem[_25592 + _25039]
                                                idx = 0
                                                while idx < 32 * _26191:
                                                    mem[_25039 + ceil32(return_data.size) + idx + 32] = mem[_25592 + _25039 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26191) + _25039 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21835 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21837 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21837:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21837) + _21835 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25040 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25594 = mem[_25040]
                                            require mem[_25040] <= 4294967296
                                            require mem[_25040] + 32 <= return_data.size
                                            require mem[mem[_25040] + _25040] <= 4294967296 and mem[_25040] + (32 * mem[mem[_25040] + _25040]) + 32 <= return_data.size
                                            mem[_25040 + ceil32(return_data.size)] = mem[mem[_25040] + _25040]
                                            _26192 = mem[_25594 + _25040]
                                            idx = 0
                                            while idx < 32 * _26192:
                                                mem[_25040 + ceil32(return_data.size) + idx + 32] = mem[_25594 + _25040 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26192) + _25040 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                else:
                    mem[96] = 3
                    mem[128] = ETHAddress
                    mem[160] = baseTokenAddress
                    mem[192] = sub_c0b6201cAddress
                    mem[388 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                       value eth.balance(this.address) / 1000 wei
                         gas gas_remaining wei
                        args 0, 128, address(this.address), block.timestamp + 30, 3, mem[388 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sub_c0b6201cAddress)
                    staticcall sub_c0b6201cAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(sub_c0b6201cAddress)
                    call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(baseTokenAddress)
                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if baseTokenAddress == ETHAddress:
                        mem[224] = 2
                        mem[256] = sub_c0b6201cAddress
                        mem[288] = baseTokenAddress
                        mem[420] = this.address
                        mem[452] = block.timestamp + 30
                        mem[484] = 2
                        mem[516 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[516 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[388] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args address(this.address), wallets, 0, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[320] = 2
                                mem[64] = 416
                                mem[352] = baseTokenAddress
                                mem[384] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _21059 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21061 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21061:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21061) + _21059 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25011 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25536 = mem[_25011]
                                            require mem[_25011] <= 4294967296
                                            require mem[_25011] + 32 <= return_data.size
                                            require mem[mem[_25011] + _25011] <= 4294967296 and mem[_25011] + (32 * mem[mem[_25011] + _25011]) + 32 <= return_data.size
                                            mem[_25011 + ceil32(return_data.size)] = mem[mem[_25011] + _25011]
                                            _26163 = mem[_25536 + _25011]
                                            idx = 0
                                            while idx < 32 * _26163:
                                                mem[_25011 + ceil32(return_data.size) + idx + 32] = mem[_25536 + _25011 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26163) + _25011 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21759 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21761 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21761:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21761) + _21759 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25012 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25538 = mem[_25012]
                                            require mem[_25012] <= 4294967296
                                            require mem[_25012] + 32 <= return_data.size
                                            require mem[mem[_25012] + _25012] <= 4294967296 and mem[_25012] + (32 * mem[mem[_25012] + _25012]) + 32 <= return_data.size
                                            mem[_25012 + ceil32(return_data.size)] = mem[mem[_25012] + _25012]
                                            _26164 = mem[_25538 + _25012]
                                            idx = 0
                                            while idx < 32 * _26164:
                                                mem[_25012 + ceil32(return_data.size) + idx + 32] = mem[_25538 + _25012 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26164) + _25012 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21763 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[320]
                                        _21765 = mem[320]
                                        idx = 0
                                        while idx < 32 * _21765:
                                            mem[mem[64] + idx + 164] = mem[idx + 352]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21765) + _21763 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25013 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25540 = mem[_25013]
                                        require mem[_25013] <= 4294967296
                                        require mem[_25013] + 32 <= return_data.size
                                        require mem[mem[_25013] + _25013] <= 4294967296 and mem[_25013] + (32 * mem[mem[_25013] + _25013]) + 32 <= return_data.size
                                        mem[_25013 + ceil32(return_data.size)] = mem[mem[_25013] + _25013]
                                        _26165 = mem[_25540 + _25013]
                                        idx = 0
                                        while idx < 32 * _26165:
                                            mem[_25013 + ceil32(return_data.size) + idx + 32] = mem[_25540 + _25013 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26165) + _25013 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[320] = 3
                                mem[64] = 448
                                mem[352] = ETHAddress
                                mem[384] = baseTokenAddress
                                mem[416] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21057 = mem[320]
                                            t = 0
                                            while t < 32 * _21057:
                                                mem[mem[64] + t + 164] = mem[t + 352]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21057) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25008 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25530 = mem[_25008]
                                            require mem[_25008] <= 4294967296
                                            require mem[_25008] + 32 <= return_data.size
                                            require mem[mem[_25008] + _25008] <= 4294967296 and mem[_25008] + (32 * mem[mem[_25008] + _25008]) + 32 <= return_data.size
                                            mem[_25008 + ceil32(return_data.size)] = mem[mem[_25008] + _25008]
                                            _26160 = mem[_25530 + _25008]
                                            idx = 0
                                            while idx < 32 * _26160:
                                                mem[_25008 + ceil32(return_data.size) + idx + 32] = mem[_25530 + _25008 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26160) + _25008 + ceil32(return_data.size) + 32
                                        else:
                                            if idx == wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21757 = mem[320]
                                                t = 0
                                                while t < 32 * _21757:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21757) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25010 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25534 = mem[_25010]
                                                require mem[_25010] <= 4294967296
                                                require mem[_25010] + 32 <= return_data.size
                                                require mem[mem[_25010] + _25010] <= 4294967296 and mem[_25010] + (32 * mem[mem[_25010] + _25010]) + 32 <= return_data.size
                                                mem[_25010 + ceil32(return_data.size)] = mem[mem[_25010] + _25010]
                                                _26162 = mem[_25534 + _25010]
                                                idx = 0
                                                while idx < 32 * _26162:
                                                    mem[_25010 + ceil32(return_data.size) + idx + 32] = mem[_25534 + _25010 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26162) + _25010 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            _21751 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21753 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21753:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21753) + _21751 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25009 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25532 = mem[_25009]
                                            require mem[_25009] <= 4294967296
                                            require mem[_25009] + 32 <= return_data.size
                                            require mem[mem[_25009] + _25009] <= 4294967296 and mem[_25009] + (32 * mem[mem[_25009] + _25009]) + 32 <= return_data.size
                                            mem[_25009 + ceil32(return_data.size)] = mem[mem[_25009] + _25009]
                                            _26161 = mem[_25532 + _25009]
                                            idx = 0
                                            while idx < 32 * _26161:
                                                mem[_25009 + ceil32(return_data.size) + idx + 32] = mem[_25532 + _25009 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26161) + _25009 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21067 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21069 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21069:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21069) + _21067 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25017 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25548 = mem[_25017]
                                                require mem[_25017] <= 4294967296
                                                require mem[_25017] + 32 <= return_data.size
                                                require mem[mem[_25017] + _25017] <= 4294967296 and mem[_25017] + (32 * mem[mem[_25017] + _25017]) + 32 <= return_data.size
                                                mem[_25017 + ceil32(return_data.size)] = mem[mem[_25017] + _25017]
                                                _26169 = mem[_25548 + _25017]
                                                idx = 0
                                                while idx < 32 * _26169:
                                                    mem[_25017 + ceil32(return_data.size) + idx + 32] = mem[_25548 + _25017 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26169) + _25017 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21775 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21777 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21777:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21777) + _21775 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25018 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25550 = mem[_25018]
                                                require mem[_25018] <= 4294967296
                                                require mem[_25018] + 32 <= return_data.size
                                                require mem[mem[_25018] + _25018] <= 4294967296 and mem[_25018] + (32 * mem[mem[_25018] + _25018]) + 32 <= return_data.size
                                                mem[_25018 + ceil32(return_data.size)] = mem[mem[_25018] + _25018]
                                                _26170 = mem[_25550 + _25018]
                                                idx = 0
                                                while idx < 32 * _26170:
                                                    mem[_25018 + ceil32(return_data.size) + idx + 32] = mem[_25550 + _25018 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26170) + _25018 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21779 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21781 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21781:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21781) + _21779 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25019 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25552 = mem[_25019]
                                            require mem[_25019] <= 4294967296
                                            require mem[_25019] + 32 <= return_data.size
                                            require mem[mem[_25019] + _25019] <= 4294967296 and mem[_25019] + (32 * mem[mem[_25019] + _25019]) + 32 <= return_data.size
                                            mem[_25019 + ceil32(return_data.size)] = mem[mem[_25019] + _25019]
                                            _26171 = mem[_25552 + _25019]
                                            idx = 0
                                            while idx < 32 * _26171:
                                                mem[_25019 + ceil32(return_data.size) + idx + 32] = mem[_25552 + _25019 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26171) + _25019 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21063 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21065 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21065:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21065) + _21063 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25014 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25542 = mem[_25014]
                                                require mem[_25014] <= 4294967296
                                                require mem[_25014] + 32 <= return_data.size
                                                require mem[mem[_25014] + _25014] <= 4294967296 and mem[_25014] + (32 * mem[mem[_25014] + _25014]) + 32 <= return_data.size
                                                mem[_25014 + ceil32(return_data.size)] = mem[mem[_25014] + _25014]
                                                _26166 = mem[_25542 + _25014]
                                                idx = 0
                                                while idx < 32 * _26166:
                                                    mem[_25014 + ceil32(return_data.size) + idx + 32] = mem[_25542 + _25014 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26166) + _25014 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21767 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21769 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21769:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21769) + _21767 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25015 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25544 = mem[_25015]
                                                require mem[_25015] <= 4294967296
                                                require mem[_25015] + 32 <= return_data.size
                                                require mem[mem[_25015] + _25015] <= 4294967296 and mem[_25015] + (32 * mem[mem[_25015] + _25015]) + 32 <= return_data.size
                                                mem[_25015 + ceil32(return_data.size)] = mem[mem[_25015] + _25015]
                                                _26167 = mem[_25544 + _25015]
                                                idx = 0
                                                while idx < 32 * _26167:
                                                    mem[_25015 + ceil32(return_data.size) + idx + 32] = mem[_25544 + _25015 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26167) + _25015 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21771 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21773 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21773:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21773) + _21771 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25016 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25546 = mem[_25016]
                                            require mem[_25016] <= 4294967296
                                            require mem[_25016] + 32 <= return_data.size
                                            require mem[mem[_25016] + _25016] <= 4294967296 and mem[_25016] + (32 * mem[mem[_25016] + _25016]) + 32 <= return_data.size
                                            mem[_25016 + ceil32(return_data.size)] = mem[mem[_25016] + _25016]
                                            _26168 = mem[_25546 + _25016]
                                            idx = 0
                                            while idx < 32 * _26168:
                                                mem[_25016 + ceil32(return_data.size) + idx + 32] = mem[_25546 + _25016 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26168) + _25016 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21075 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21077 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21077:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21077) + _21075 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25023 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25560 = mem[_25023]
                                                require mem[_25023] <= 4294967296
                                                require mem[_25023] + 32 <= return_data.size
                                                require mem[mem[_25023] + _25023] <= 4294967296 and mem[_25023] + (32 * mem[mem[_25023] + _25023]) + 32 <= return_data.size
                                                mem[_25023 + ceil32(return_data.size)] = mem[mem[_25023] + _25023]
                                                _26175 = mem[_25560 + _25023]
                                                idx = 0
                                                while idx < 32 * _26175:
                                                    mem[_25023 + ceil32(return_data.size) + idx + 32] = mem[_25560 + _25023 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26175) + _25023 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21791 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21793 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21793:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21793) + _21791 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25024 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25562 = mem[_25024]
                                                require mem[_25024] <= 4294967296
                                                require mem[_25024] + 32 <= return_data.size
                                                require mem[mem[_25024] + _25024] <= 4294967296 and mem[_25024] + (32 * mem[mem[_25024] + _25024]) + 32 <= return_data.size
                                                mem[_25024 + ceil32(return_data.size)] = mem[mem[_25024] + _25024]
                                                _26176 = mem[_25562 + _25024]
                                                idx = 0
                                                while idx < 32 * _26176:
                                                    mem[_25024 + ceil32(return_data.size) + idx + 32] = mem[_25562 + _25024 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26176) + _25024 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21795 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21797 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21797:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21797) + _21795 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25025 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25564 = mem[_25025]
                                            require mem[_25025] <= 4294967296
                                            require mem[_25025] + 32 <= return_data.size
                                            require mem[mem[_25025] + _25025] <= 4294967296 and mem[_25025] + (32 * mem[mem[_25025] + _25025]) + 32 <= return_data.size
                                            mem[_25025 + ceil32(return_data.size)] = mem[mem[_25025] + _25025]
                                            _26177 = mem[_25564 + _25025]
                                            idx = 0
                                            while idx < 32 * _26177:
                                                mem[_25025 + ceil32(return_data.size) + idx + 32] = mem[_25564 + _25025 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26177) + _25025 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21071 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21073 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21073:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21073) + _21071 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25020 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25554 = mem[_25020]
                                                require mem[_25020] <= 4294967296
                                                require mem[_25020] + 32 <= return_data.size
                                                require mem[mem[_25020] + _25020] <= 4294967296 and mem[_25020] + (32 * mem[mem[_25020] + _25020]) + 32 <= return_data.size
                                                mem[_25020 + ceil32(return_data.size)] = mem[mem[_25020] + _25020]
                                                _26172 = mem[_25554 + _25020]
                                                idx = 0
                                                while idx < 32 * _26172:
                                                    mem[_25020 + ceil32(return_data.size) + idx + 32] = mem[_25554 + _25020 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26172) + _25020 + ceil32(return_data.size) + 32
                                            else:
                                                if idx == wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21789 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21789:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value eth.balance(this.address) wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21789) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _25022 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25558 = mem[_25022]
                                                    require mem[_25022] <= 4294967296
                                                    require mem[_25022] + 32 <= return_data.size
                                                    require mem[mem[_25022] + _25022] <= 4294967296 and mem[_25022] + (32 * mem[mem[_25022] + _25022]) + 32 <= return_data.size
                                                    mem[_25022 + ceil32(return_data.size)] = mem[mem[_25022] + _25022]
                                                    _26174 = mem[_25558 + _25022]
                                                    idx = 0
                                                    while idx < 32 * _26174:
                                                        mem[_25022 + ceil32(return_data.size) + idx + 32] = mem[_25558 + _25022 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26174) + _25022 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = eth.balance(this.address)
                                                    continue 
                                                _21783 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21785 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21785:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21785) + _21783 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25021 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25556 = mem[_25021]
                                                require mem[_25021] <= 4294967296
                                                require mem[_25021] + 32 <= return_data.size
                                                require mem[mem[_25021] + _25021] <= 4294967296 and mem[_25021] + (32 * mem[mem[_25021] + _25021]) + 32 <= return_data.size
                                                mem[_25021 + ceil32(return_data.size)] = mem[mem[_25021] + _25021]
                                                _26173 = mem[_25556 + _25021]
                                                idx = 0
                                                while idx < 32 * _26173:
                                                    mem[_25021 + ceil32(return_data.size) + idx + 32] = mem[_25556 + _25021 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26173) + _25021 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        idx = idx + 1
                                        continue 
                    else:
                        mem[224] = 3
                        mem[256] = sub_c0b6201cAddress
                        mem[288] = baseTokenAddress
                        mem[320] = ETHAddress
                        mem[452] = this.address
                        mem[484] = block.timestamp + 30
                        mem[516] = 3
                        mem[548 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[548 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(ETHAddress)
                        staticcall ETHAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        endingBalance = ext_call.return_data[0]
                        if mode == 5:
                            require eth.balance(this.address) / 1000 / 10000
                            sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                            if sub_ab731cfa > sub_cb523a14:
                                revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                            require 0 < wallets.length
                            mem[0] = 10
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[420] = ext_call.return_data[0]
                            require ext_code.size(ETHAddress)
                            call ETHAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args this.address, 0, wallets, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(baseTokenAddress)
                            call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, 0, -1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if baseTokenAddress == ETHAddress:
                                mem[352] = 2
                                mem[64] = 448
                                mem[384] = baseTokenAddress
                                mem[416] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            _21035 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21037 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21037:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21037) + _21035 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24993 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25500 = mem[_24993]
                                            require mem[_24993] <= 4294967296
                                            require mem[_24993] + 32 <= return_data.size
                                            require mem[mem[_24993] + _24993] <= 4294967296 and mem[_24993] + (32 * mem[mem[_24993] + _24993]) + 32 <= return_data.size
                                            mem[_24993 + ceil32(return_data.size)] = mem[mem[_24993] + _24993]
                                            _26145 = mem[_25500 + _24993]
                                            idx = 0
                                            while idx < 32 * _26145:
                                                mem[_24993 + ceil32(return_data.size) + idx + 32] = mem[_25500 + _24993 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26145) + _24993 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        if idx != wallets.length - 1:
                                            _21711 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21713 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21713:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21713) + _21711 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24994 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25502 = mem[_24994]
                                            require mem[_24994] <= 4294967296
                                            require mem[_24994] + 32 <= return_data.size
                                            require mem[mem[_24994] + _24994] <= 4294967296 and mem[_24994] + (32 * mem[mem[_24994] + _24994]) + 32 <= return_data.size
                                            mem[_24994 + ceil32(return_data.size)] = mem[mem[_24994] + _24994]
                                            _26146 = mem[_25502 + _24994]
                                            idx = 0
                                            while idx < 32 * _26146:
                                                mem[_24994 + ceil32(return_data.size) + idx + 32] = mem[_25502 + _24994 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26146) + _24994 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = sub_1ef782ba
                                            continue 
                                        _21715 = mem[64]
                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 68] = wallets[idx]
                                        mem[mem[64] + 100] = block.timestamp
                                        mem[mem[64] + 36] = 128
                                        mem[mem[64] + 132] = mem[352]
                                        _21717 = mem[352]
                                        idx = 0
                                        while idx < 32 * _21717:
                                            mem[mem[64] + idx + 164] = mem[idx + 384]
                                            idx = idx + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value eth.balance(this.address) wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (32 * _21717) + _21715 + -mem[64] + 160]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _24995 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _25504 = mem[_24995]
                                        require mem[_24995] <= 4294967296
                                        require mem[_24995] + 32 <= return_data.size
                                        require mem[mem[_24995] + _24995] <= 4294967296 and mem[_24995] + (32 * mem[mem[_24995] + _24995]) + 32 <= return_data.size
                                        mem[_24995 + ceil32(return_data.size)] = mem[mem[_24995] + _24995]
                                        _26147 = mem[_25504 + _24995]
                                        idx = 0
                                        while idx < 32 * _26147:
                                            mem[_24995 + ceil32(return_data.size) + idx + 32] = mem[_25504 + _24995 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[64] = (32 * _26147) + _24995 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = eth.balance(this.address)
                                        continue 
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[352] = 3
                                mem[64] = 480
                                mem[384] = ETHAddress
                                mem[416] = baseTokenAddress
                                mem[448] = sub_c0b6201cAddress
                                require sub_43ff02f6 * wallets.length
                                sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                idx = 0
                                while idx < wallets.length:
                                    s = 0
                                    t = 0
                                    while s < sub_43ff02f6:
                                        require idx < wallets.length
                                        mem[0] = 10
                                        if s != sub_43ff02f6 - 1:
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21033 = mem[352]
                                            t = 0
                                            while t < 32 * _21033:
                                                mem[mem[64] + t + 164] = mem[t + 384]
                                                t = t + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21033) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24990 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25494 = mem[_24990]
                                            require mem[_24990] <= 4294967296
                                            require mem[_24990] + 32 <= return_data.size
                                            require mem[mem[_24990] + _24990] <= 4294967296 and mem[_24990] + (32 * mem[mem[_24990] + _24990]) + 32 <= return_data.size
                                            mem[_24990 + ceil32(return_data.size)] = mem[mem[_24990] + _24990]
                                            _26142 = mem[_25494 + _24990]
                                            idx = 0
                                            while idx < 32 * _26142:
                                                mem[_24990 + ceil32(return_data.size) + idx + 32] = mem[_25494 + _24990 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26142) + _24990 + ceil32(return_data.size) + 32
                                        else:
                                            if idx == wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21709 = mem[352]
                                                t = 0
                                                while t < 32 * _21709:
                                                    mem[mem[64] + t + 164] = mem[t + 384]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21709) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24992 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25498 = mem[_24992]
                                                require mem[_24992] <= 4294967296
                                                require mem[_24992] + 32 <= return_data.size
                                                require mem[mem[_24992] + _24992] <= 4294967296 and mem[_24992] + (32 * mem[mem[_24992] + _24992]) + 32 <= return_data.size
                                                mem[_24992 + ceil32(return_data.size)] = mem[mem[_24992] + _24992]
                                                _26144 = mem[_25498 + _24992]
                                                idx = 0
                                                while idx < 32 * _26144:
                                                    mem[_24992 + ceil32(return_data.size) + idx + 32] = mem[_25498 + _24992 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26144) + _24992 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            _21703 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21705 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21705:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value sub_1ef782ba wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21705) + _21703 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24991 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25496 = mem[_24991]
                                            require mem[_24991] <= 4294967296
                                            require mem[_24991] + 32 <= return_data.size
                                            require mem[mem[_24991] + _24991] <= 4294967296 and mem[_24991] + (32 * mem[mem[_24991] + _24991]) + 32 <= return_data.size
                                            mem[_24991 + ceil32(return_data.size)] = mem[mem[_24991] + _24991]
                                            _26143 = mem[_25496 + _24991]
                                            idx = 0
                                            while idx < 32 * _26143:
                                                mem[_24991 + ceil32(return_data.size) + idx + 32] = mem[_25496 + _24991 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26143) + _24991 + ceil32(return_data.size) + 32
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    idx = idx + 1
                                    continue 
                        else:
                            if mode != 2:
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[420] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[352] = 2
                                    mem[64] = 448
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21043 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21045 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21045:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21045) + _21043 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24999 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25512 = mem[_24999]
                                                require mem[_24999] <= 4294967296
                                                require mem[_24999] + 32 <= return_data.size
                                                require mem[mem[_24999] + _24999] <= 4294967296 and mem[_24999] + (32 * mem[mem[_24999] + _24999]) + 32 <= return_data.size
                                                mem[_24999 + ceil32(return_data.size)] = mem[mem[_24999] + _24999]
                                                _26151 = mem[_25512 + _24999]
                                                idx = 0
                                                while idx < 32 * _26151:
                                                    mem[_24999 + ceil32(return_data.size) + idx + 32] = mem[_25512 + _24999 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26151) + _24999 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21727 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21729 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21729:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21729) + _21727 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25000 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25514 = mem[_25000]
                                                require mem[_25000] <= 4294967296
                                                require mem[_25000] + 32 <= return_data.size
                                                require mem[mem[_25000] + _25000] <= 4294967296 and mem[_25000] + (32 * mem[mem[_25000] + _25000]) + 32 <= return_data.size
                                                mem[_25000 + ceil32(return_data.size)] = mem[mem[_25000] + _25000]
                                                _26152 = mem[_25514 + _25000]
                                                idx = 0
                                                while idx < 32 * _26152:
                                                    mem[_25000 + ceil32(return_data.size) + idx + 32] = mem[_25514 + _25000 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26152) + _25000 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21731 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21733 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21733:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21733) + _21731 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25001 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25516 = mem[_25001]
                                            require mem[_25001] <= 4294967296
                                            require mem[_25001] + 32 <= return_data.size
                                            require mem[mem[_25001] + _25001] <= 4294967296 and mem[_25001] + (32 * mem[mem[_25001] + _25001]) + 32 <= return_data.size
                                            mem[_25001 + ceil32(return_data.size)] = mem[mem[_25001] + _25001]
                                            _26153 = mem[_25516 + _25001]
                                            idx = 0
                                            while idx < 32 * _26153:
                                                mem[_25001 + ceil32(return_data.size) + idx + 32] = mem[_25516 + _25001 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26153) + _25001 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[352] = 3
                                    mem[64] = 480
                                    mem[384] = ETHAddress
                                    mem[416] = baseTokenAddress
                                    mem[448] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21039 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21041 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21041:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21041) + _21039 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24996 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25506 = mem[_24996]
                                                require mem[_24996] <= 4294967296
                                                require mem[_24996] + 32 <= return_data.size
                                                require mem[mem[_24996] + _24996] <= 4294967296 and mem[_24996] + (32 * mem[mem[_24996] + _24996]) + 32 <= return_data.size
                                                mem[_24996 + ceil32(return_data.size)] = mem[mem[_24996] + _24996]
                                                _26148 = mem[_25506 + _24996]
                                                idx = 0
                                                while idx < 32 * _26148:
                                                    mem[_24996 + ceil32(return_data.size) + idx + 32] = mem[_25506 + _24996 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26148) + _24996 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21719 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21721 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21721:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21721) + _21719 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24997 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25508 = mem[_24997]
                                                require mem[_24997] <= 4294967296
                                                require mem[_24997] + 32 <= return_data.size
                                                require mem[mem[_24997] + _24997] <= 4294967296 and mem[_24997] + (32 * mem[mem[_24997] + _24997]) + 32 <= return_data.size
                                                mem[_24997 + ceil32(return_data.size)] = mem[mem[_24997] + _24997]
                                                _26149 = mem[_25508 + _24997]
                                                idx = 0
                                                while idx < 32 * _26149:
                                                    mem[_24997 + ceil32(return_data.size) + idx + 32] = mem[_25508 + _24997 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26149) + _24997 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21723 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21725 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21725:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21725) + _21723 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24998 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25510 = mem[_24998]
                                            require mem[_24998] <= 4294967296
                                            require mem[_24998] + 32 <= return_data.size
                                            require mem[mem[_24998] + _24998] <= 4294967296 and mem[_24998] + (32 * mem[mem[_24998] + _24998]) + 32 <= return_data.size
                                            mem[_24998 + ceil32(return_data.size)] = mem[mem[_24998] + _24998]
                                            _26150 = mem[_25510 + _24998]
                                            idx = 0
                                            while idx < 32 * _26150:
                                                mem[_24998 + ceil32(return_data.size) + idx + 32] = mem[_25510 + _24998 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26150) + _24998 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[420] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[352] = 2
                                    mem[64] = 448
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21051 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21053 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21053:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21053) + _21051 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25005 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25524 = mem[_25005]
                                                require mem[_25005] <= 4294967296
                                                require mem[_25005] + 32 <= return_data.size
                                                require mem[mem[_25005] + _25005] <= 4294967296 and mem[_25005] + (32 * mem[mem[_25005] + _25005]) + 32 <= return_data.size
                                                mem[_25005 + ceil32(return_data.size)] = mem[mem[_25005] + _25005]
                                                _26157 = mem[_25524 + _25005]
                                                idx = 0
                                                while idx < 32 * _26157:
                                                    mem[_25005 + ceil32(return_data.size) + idx + 32] = mem[_25524 + _25005 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26157) + _25005 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21743 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21745 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21745:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21745) + _21743 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25006 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25526 = mem[_25006]
                                                require mem[_25006] <= 4294967296
                                                require mem[_25006] + 32 <= return_data.size
                                                require mem[mem[_25006] + _25006] <= 4294967296 and mem[_25006] + (32 * mem[mem[_25006] + _25006]) + 32 <= return_data.size
                                                mem[_25006 + ceil32(return_data.size)] = mem[mem[_25006] + _25006]
                                                _26158 = mem[_25526 + _25006]
                                                idx = 0
                                                while idx < 32 * _26158:
                                                    mem[_25006 + ceil32(return_data.size) + idx + 32] = mem[_25526 + _25006 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26158) + _25006 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21747 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21749 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21749:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21749) + _21747 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25007 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25528 = mem[_25007]
                                            require mem[_25007] <= 4294967296
                                            require mem[_25007] + 32 <= return_data.size
                                            require mem[mem[_25007] + _25007] <= 4294967296 and mem[_25007] + (32 * mem[mem[_25007] + _25007]) + 32 <= return_data.size
                                            mem[_25007 + ceil32(return_data.size)] = mem[mem[_25007] + _25007]
                                            _26159 = mem[_25528 + _25007]
                                            idx = 0
                                            while idx < 32 * _26159:
                                                mem[_25007 + ceil32(return_data.size) + idx + 32] = mem[_25528 + _25007 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26159) + _25007 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[352] = 3
                                    mem[64] = 480
                                    mem[384] = ETHAddress
                                    mem[416] = baseTokenAddress
                                    mem[448] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21047 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21049 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21049:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21049) + _21047 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25002 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25518 = mem[_25002]
                                                require mem[_25002] <= 4294967296
                                                require mem[_25002] + 32 <= return_data.size
                                                require mem[mem[_25002] + _25002] <= 4294967296 and mem[_25002] + (32 * mem[mem[_25002] + _25002]) + 32 <= return_data.size
                                                mem[_25002 + ceil32(return_data.size)] = mem[mem[_25002] + _25002]
                                                _26154 = mem[_25518 + _25002]
                                                idx = 0
                                                while idx < 32 * _26154:
                                                    mem[_25002 + ceil32(return_data.size) + idx + 32] = mem[_25518 + _25002 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26154) + _25002 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21737 = mem[352]
                                                t = 0
                                                while t < 32 * _21737:
                                                    mem[mem[64] + t + 164] = mem[t + 384]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21737) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _25003 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25520 = mem[_25003]
                                                require mem[_25003] <= 4294967296
                                                require mem[_25003] + 32 <= return_data.size
                                                require mem[mem[_25003] + _25003] <= 4294967296 and mem[_25003] + (32 * mem[mem[_25003] + _25003]) + 32 <= return_data.size
                                                mem[_25003 + ceil32(return_data.size)] = mem[mem[_25003] + _25003]
                                                _26155 = mem[_25520 + _25003]
                                                idx = 0
                                                while idx < 32 * _26155:
                                                    mem[_25003 + ceil32(return_data.size) + idx + 32] = mem[_25520 + _25003 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26155) + _25003 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21739 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21741 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21741:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21741) + _21739 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25004 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25522 = mem[_25004]
                                            require mem[_25004] <= 4294967296
                                            require mem[_25004] + 32 <= return_data.size
                                            require mem[mem[_25004] + _25004] <= 4294967296 and mem[_25004] + (32 * mem[mem[_25004] + _25004]) + 32 <= return_data.size
                                            mem[_25004 + ceil32(return_data.size)] = mem[mem[_25004] + _25004]
                                            _26156 = mem[_25522 + _25004]
                                            idx = 0
                                            while idx < 32 * _26156:
                                                mem[_25004 + ceil32(return_data.size) + idx + 32] = mem[_25522 + _25004 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26156) + _25004 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                if eth.balance(this.address) > 0:
                    if bool(stor9[address(msg.sender)]) != 1:
                        revert with 0, 
                                    32,
                                    56,
                                    0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                    mem[mem[64] + 124 len 8]
                    call msg.sender with:
                       value eth.balance(this.address) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            else:
                if mode != 2:
                    if mode == 3:
                        require ext_code.size(baseTokenAddress)
                        call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if baseTokenAddress == ETHAddress:
                            mem[96] = 2
                            mem[64] = 192
                            mem[128] = baseTokenAddress
                            mem[160] = sub_c0b6201cAddress
                            require sub_43ff02f6 * wallets.length
                            sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                            idx = 0
                            while idx < wallets.length:
                                mem[0] = 10
                                _5739 = mem[64]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 100] = wallets[idx]
                                mem[mem[64] + 132] = block.timestamp
                                mem[mem[64] + 68] = 128
                                mem[mem[64] + 164] = mem[96]
                                _5741 = mem[96]
                                s = 0
                                while s < 32 * mem[96]:
                                    mem[mem[64] + s + 196] = mem[s + 128]
                                    s = s + 32
                                    continue 
                                _11283 = mem[64]
                                mem[mem[64]] = (32 * mem[96]) + _5739 + -mem[64] + 164
                                mem[64] = (32 * _5741) + _5739 + 196
                                mem[_11283 + 32] = mem[_11283 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                s = 0
                                t = 0
                                while s < sub_43ff02f6:
                                    if s != sub_43ff02f6 - 1:
                                        _16896 = mem[64]
                                        _16897 = mem[_11283]
                                        t = _11283 + 32
                                        u = mem[64]
                                        idx = mem[_11283]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11283])] = mem[_11283 + floor32(mem[_11283]) + -(mem[_11283] % 32) + 64 len mem[_11283] % 32] or Mask(8 * -(mem[_11283] % 32) + 32, -(8 * -(mem[_11283] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11283])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _16897 + _16896 + -mem[64] - 4]
                                        if return_data.size:
                                            _20739 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20739] = return_data.size
                                            mem[_20739 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    if idx != wallets.length - 1:
                                        _17114 = mem[64]
                                        _17115 = mem[_11283]
                                        t = _11283 + 32
                                        u = mem[64]
                                        idx = mem[_11283]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11283])] = mem[_11283 + floor32(mem[_11283]) + -(mem[_11283] % 32) + 64 len mem[_11283] % 32] or Mask(8 * -(mem[_11283] % 32) + 32, -(8 * -(mem[_11283] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11283])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _17115 + _17114 + -mem[64] - 4]
                                        if return_data.size:
                                            _20740 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20740] = return_data.size
                                            mem[_20740 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    _17116 = mem[64]
                                    _17117 = mem[_11283]
                                    t = _11283 + 32
                                    u = mem[64]
                                    idx = mem[_11283]
                                    while idx >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        idx = idx - 32
                                        continue 
                                    mem[mem[64] + floor32(mem[_11283])] = mem[_11283 + floor32(mem[_11283]) + -(mem[_11283] % 32) + 64 len mem[_11283] % 32] or Mask(8 * -(mem[_11283] % 32) + 32, -(8 * -(mem[_11283] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11283])])
                                    call routerAddress.mem[mem[64] len 4] with:
                                       value eth.balance(this.address) wei
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _17117 + _17116 + -mem[64] - 4]
                                    if return_data.size:
                                        _20741 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                        mem[_20741] = return_data.size
                                        mem[_20741 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    s = s + 1
                                    t = eth.balance(this.address)
                                    continue 
                                idx = idx + 1
                                continue 
                        else:
                            mem[96] = 3
                            mem[64] = 224
                            mem[128] = ETHAddress
                            mem[160] = baseTokenAddress
                            mem[192] = sub_c0b6201cAddress
                            require sub_43ff02f6 * wallets.length
                            sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                            idx = 0
                            while idx < wallets.length:
                                mem[0] = 10
                                _5735 = mem[64]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 100] = wallets[idx]
                                mem[mem[64] + 132] = block.timestamp
                                mem[mem[64] + 68] = 128
                                mem[mem[64] + 164] = mem[96]
                                _5737 = mem[96]
                                s = 0
                                while s < 32 * mem[96]:
                                    mem[mem[64] + s + 196] = mem[s + 128]
                                    s = s + 32
                                    continue 
                                _11280 = mem[64]
                                mem[mem[64]] = (32 * mem[96]) + _5735 + -mem[64] + 164
                                mem[64] = (32 * _5737) + _5735 + 196
                                mem[_11280 + 32] = mem[_11280 + 36 len 28] or 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                s = 0
                                t = 0
                                while s < sub_43ff02f6:
                                    if s != sub_43ff02f6 - 1:
                                        _16894 = mem[64]
                                        _16895 = mem[_11280]
                                        t = _11280 + 32
                                        u = mem[64]
                                        idx = mem[_11280]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11280])] = mem[_11280 + floor32(mem[_11280]) + -(mem[_11280] % 32) + 64 len mem[_11280] % 32] or Mask(8 * -(mem[_11280] % 32) + 32, -(8 * -(mem[_11280] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11280])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _16895 + _16894 + -mem[64] - 4]
                                        if return_data.size:
                                            _20736 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20736] = return_data.size
                                            mem[_20736 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    if idx != wallets.length - 1:
                                        _17110 = mem[64]
                                        _17111 = mem[_11280]
                                        t = _11280 + 32
                                        u = mem[64]
                                        idx = mem[_11280]
                                        while idx >= 32:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            idx = idx - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[_11280])] = mem[_11280 + floor32(mem[_11280]) + -(mem[_11280] % 32) + 64 len mem[_11280] % 32] or Mask(8 * -(mem[_11280] % 32) + 32, -(8 * -(mem[_11280] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11280])])
                                        call routerAddress.mem[mem[64] len 4] with:
                                           value sub_1ef782ba wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _17111 + _17110 + -mem[64] - 4]
                                        if return_data.size:
                                            _20737 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_20737] = return_data.size
                                            mem[_20737 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        s = s + 1
                                        t = sub_1ef782ba
                                        continue 
                                    _17112 = mem[64]
                                    _17113 = mem[_11280]
                                    t = _11280 + 32
                                    u = mem[64]
                                    idx = mem[_11280]
                                    while idx >= 32:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        idx = idx - 32
                                        continue 
                                    mem[mem[64] + floor32(mem[_11280])] = mem[_11280 + floor32(mem[_11280]) + -(mem[_11280] % 32) + 64 len mem[_11280] % 32] or Mask(8 * -(mem[_11280] % 32) + 32, -(8 * -(mem[_11280] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11280])])
                                    call routerAddress.mem[mem[64] len 4] with:
                                       value eth.balance(this.address) wei
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _17113 + _17112 + -mem[64] - 4]
                                    if return_data.size:
                                        _20738 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                        mem[_20738] = return_data.size
                                        mem[_20738 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    s = s + 1
                                    t = eth.balance(this.address)
                                    continue 
                                idx = idx + 1
                                continue 
                else:
                    require ext_code.size(ETHAddress)
                    call ETHAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(baseTokenAddress)
                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args routerAddress, -1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if baseTokenAddress == ETHAddress:
                        mem[96] = 2
                        mem[128] = baseTokenAddress
                        mem[160] = sub_c0b6201cAddress
                        mem[356 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                           value eth.balance(this.address) / 1000 wei
                             gas gas_remaining wei
                            args 0, 128, address(this.address), block.timestamp + 30, 2, mem[356 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c0b6201cAddress)
                        staticcall sub_c0b6201cAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sub_c0b6201cAddress)
                        call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(baseTokenAddress)
                        call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if baseTokenAddress == ETHAddress:
                            mem[192] = 2
                            mem[224] = sub_c0b6201cAddress
                            mem[256] = baseTokenAddress
                            mem[388] = this.address
                            mem[420] = block.timestamp + 30
                            mem[452] = 2
                            mem[484 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[484 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[356] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[288] = 2
                                    mem[64] = 384
                                    mem[320] = baseTokenAddress
                                    mem[352] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _21011 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21013 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21013:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21013) + _21011 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24975 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25464 = mem[_24975]
                                                require mem[_24975] <= 4294967296
                                                require mem[_24975] + 32 <= return_data.size
                                                require mem[mem[_24975] + _24975] <= 4294967296 and mem[_24975] + (32 * mem[mem[_24975] + _24975]) + 32 <= return_data.size
                                                mem[_24975 + ceil32(return_data.size)] = mem[mem[_24975] + _24975]
                                                _26127 = mem[_25464 + _24975]
                                                idx = 0
                                                while idx < 32 * _26127:
                                                    mem[_24975 + ceil32(return_data.size) + idx + 32] = mem[_25464 + _24975 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26127) + _24975 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21663 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21665 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21665:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21665) + _21663 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24976 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25466 = mem[_24976]
                                                require mem[_24976] <= 4294967296
                                                require mem[_24976] + 32 <= return_data.size
                                                require mem[mem[_24976] + _24976] <= 4294967296 and mem[_24976] + (32 * mem[mem[_24976] + _24976]) + 32 <= return_data.size
                                                mem[_24976 + ceil32(return_data.size)] = mem[mem[_24976] + _24976]
                                                _26128 = mem[_25466 + _24976]
                                                idx = 0
                                                while idx < 32 * _26128:
                                                    mem[_24976 + ceil32(return_data.size) + idx + 32] = mem[_25466 + _24976 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26128) + _24976 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21667 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21669 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21669:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21669) + _21667 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24977 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25468 = mem[_24977]
                                            require mem[_24977] <= 4294967296
                                            require mem[_24977] + 32 <= return_data.size
                                            require mem[mem[_24977] + _24977] <= 4294967296 and mem[_24977] + (32 * mem[mem[_24977] + _24977]) + 32 <= return_data.size
                                            mem[_24977 + ceil32(return_data.size)] = mem[mem[_24977] + _24977]
                                            _26129 = mem[_25468 + _24977]
                                            idx = 0
                                            while idx < 32 * _26129:
                                                mem[_24977 + ceil32(return_data.size) + idx + 32] = mem[_25468 + _24977 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26129) + _24977 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[288] = 3
                                    mem[64] = 416
                                    mem[320] = ETHAddress
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21009 = mem[288]
                                                t = 0
                                                while t < 32 * _21009:
                                                    mem[mem[64] + t + 164] = mem[t + 320]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21009) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24972 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25458 = mem[_24972]
                                                require mem[_24972] <= 4294967296
                                                require mem[_24972] + 32 <= return_data.size
                                                require mem[mem[_24972] + _24972] <= 4294967296 and mem[_24972] + (32 * mem[mem[_24972] + _24972]) + 32 <= return_data.size
                                                mem[_24972 + ceil32(return_data.size)] = mem[mem[_24972] + _24972]
                                                _26124 = mem[_25458 + _24972]
                                                idx = 0
                                                while idx < 32 * _26124:
                                                    mem[_24972 + ceil32(return_data.size) + idx + 32] = mem[_25458 + _24972 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26124) + _24972 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21655 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21657 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21657:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21657) + _21655 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24973 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25460 = mem[_24973]
                                                require mem[_24973] <= 4294967296
                                                require mem[_24973] + 32 <= return_data.size
                                                require mem[mem[_24973] + _24973] <= 4294967296 and mem[_24973] + (32 * mem[mem[_24973] + _24973]) + 32 <= return_data.size
                                                mem[_24973 + ceil32(return_data.size)] = mem[mem[_24973] + _24973]
                                                _26125 = mem[_25460 + _24973]
                                                idx = 0
                                                while idx < 32 * _26125:
                                                    mem[_24973 + ceil32(return_data.size) + idx + 32] = mem[_25460 + _24973 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26125) + _24973 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21659 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[288]
                                            _21661 = mem[288]
                                            idx = 0
                                            while idx < 32 * _21661:
                                                mem[mem[64] + idx + 164] = mem[idx + 320]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21661) + _21659 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24974 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25462 = mem[_24974]
                                            require mem[_24974] <= 4294967296
                                            require mem[_24974] + 32 <= return_data.size
                                            require mem[mem[_24974] + _24974] <= 4294967296 and mem[_24974] + (32 * mem[mem[_24974] + _24974]) + 32 <= return_data.size
                                            mem[_24974 + ceil32(return_data.size)] = mem[mem[_24974] + _24974]
                                            _26126 = mem[_25462 + _24974]
                                            idx = 0
                                            while idx < 32 * _26126:
                                                mem[_24974 + ceil32(return_data.size) + idx + 32] = mem[_25462 + _24974 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26126) + _24974 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[356] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[288] = 2
                                        mem[64] = 384
                                        mem[320] = baseTokenAddress
                                        mem[352] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _21019 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21021 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21021:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21021) + _21019 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24981 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25476 = mem[_24981]
                                                    require mem[_24981] <= 4294967296
                                                    require mem[_24981] + 32 <= return_data.size
                                                    require mem[mem[_24981] + _24981] <= 4294967296 and mem[_24981] + (32 * mem[mem[_24981] + _24981]) + 32 <= return_data.size
                                                    mem[_24981 + ceil32(return_data.size)] = mem[mem[_24981] + _24981]
                                                    _26133 = mem[_25476 + _24981]
                                                    idx = 0
                                                    while idx < 32 * _26133:
                                                        mem[_24981 + ceil32(return_data.size) + idx + 32] = mem[_25476 + _24981 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26133) + _24981 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21679 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21681 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21681:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21681) + _21679 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24982 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25478 = mem[_24982]
                                                    require mem[_24982] <= 4294967296
                                                    require mem[_24982] + 32 <= return_data.size
                                                    require mem[mem[_24982] + _24982] <= 4294967296 and mem[_24982] + (32 * mem[mem[_24982] + _24982]) + 32 <= return_data.size
                                                    mem[_24982 + ceil32(return_data.size)] = mem[mem[_24982] + _24982]
                                                    _26134 = mem[_25478 + _24982]
                                                    idx = 0
                                                    while idx < 32 * _26134:
                                                        mem[_24982 + ceil32(return_data.size) + idx + 32] = mem[_25478 + _24982 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26134) + _24982 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21683 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21685 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21685:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21685) + _21683 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24983 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25480 = mem[_24983]
                                                require mem[_24983] <= 4294967296
                                                require mem[_24983] + 32 <= return_data.size
                                                require mem[mem[_24983] + _24983] <= 4294967296 and mem[_24983] + (32 * mem[mem[_24983] + _24983]) + 32 <= return_data.size
                                                mem[_24983 + ceil32(return_data.size)] = mem[mem[_24983] + _24983]
                                                _26135 = mem[_25480 + _24983]
                                                idx = 0
                                                while idx < 32 * _26135:
                                                    mem[_24983 + ceil32(return_data.size) + idx + 32] = mem[_25480 + _24983 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26135) + _24983 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[288] = 3
                                        mem[64] = 416
                                        mem[320] = ETHAddress
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _21015 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21017 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21017:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21017) + _21015 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24978 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25470 = mem[_24978]
                                                    require mem[_24978] <= 4294967296
                                                    require mem[_24978] + 32 <= return_data.size
                                                    require mem[mem[_24978] + _24978] <= 4294967296 and mem[_24978] + (32 * mem[mem[_24978] + _24978]) + 32 <= return_data.size
                                                    mem[_24978 + ceil32(return_data.size)] = mem[mem[_24978] + _24978]
                                                    _26130 = mem[_25470 + _24978]
                                                    idx = 0
                                                    while idx < 32 * _26130:
                                                        mem[_24978 + ceil32(return_data.size) + idx + 32] = mem[_25470 + _24978 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26130) + _24978 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21671 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21673 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21673:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21673) + _21671 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24979 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25472 = mem[_24979]
                                                    require mem[_24979] <= 4294967296
                                                    require mem[_24979] + 32 <= return_data.size
                                                    require mem[mem[_24979] + _24979] <= 4294967296 and mem[_24979] + (32 * mem[mem[_24979] + _24979]) + 32 <= return_data.size
                                                    mem[_24979 + ceil32(return_data.size)] = mem[mem[_24979] + _24979]
                                                    _26131 = mem[_25472 + _24979]
                                                    idx = 0
                                                    while idx < 32 * _26131:
                                                        mem[_24979 + ceil32(return_data.size) + idx + 32] = mem[_25472 + _24979 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26131) + _24979 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21675 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21677 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21677:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21677) + _21675 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24980 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25474 = mem[_24980]
                                                require mem[_24980] <= 4294967296
                                                require mem[_24980] + 32 <= return_data.size
                                                require mem[mem[_24980] + _24980] <= 4294967296 and mem[_24980] + (32 * mem[mem[_24980] + _24980]) + 32 <= return_data.size
                                                mem[_24980 + ceil32(return_data.size)] = mem[mem[_24980] + _24980]
                                                _26132 = mem[_25474 + _24980]
                                                idx = 0
                                                while idx < 32 * _26132:
                                                    mem[_24980 + ceil32(return_data.size) + idx + 32] = mem[_25474 + _24980 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26132) + _24980 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[356] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[288] = 2
                                        mem[64] = 384
                                        mem[320] = baseTokenAddress
                                        mem[352] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _21027 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21029 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21029:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21029) + _21027 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24987 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25488 = mem[_24987]
                                                    require mem[_24987] <= 4294967296
                                                    require mem[_24987] + 32 <= return_data.size
                                                    require mem[mem[_24987] + _24987] <= 4294967296 and mem[_24987] + (32 * mem[mem[_24987] + _24987]) + 32 <= return_data.size
                                                    mem[_24987 + ceil32(return_data.size)] = mem[mem[_24987] + _24987]
                                                    _26139 = mem[_25488 + _24987]
                                                    idx = 0
                                                    while idx < 32 * _26139:
                                                        mem[_24987 + ceil32(return_data.size) + idx + 32] = mem[_25488 + _24987 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26139) + _24987 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21695 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21697 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21697:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21697) + _21695 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24988 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25490 = mem[_24988]
                                                    require mem[_24988] <= 4294967296
                                                    require mem[_24988] + 32 <= return_data.size
                                                    require mem[mem[_24988] + _24988] <= 4294967296 and mem[_24988] + (32 * mem[mem[_24988] + _24988]) + 32 <= return_data.size
                                                    mem[_24988 + ceil32(return_data.size)] = mem[mem[_24988] + _24988]
                                                    _26140 = mem[_25490 + _24988]
                                                    idx = 0
                                                    while idx < 32 * _26140:
                                                        mem[_24988 + ceil32(return_data.size) + idx + 32] = mem[_25490 + _24988 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26140) + _24988 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21699 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21701 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21701:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21701) + _21699 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24989 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25492 = mem[_24989]
                                                require mem[_24989] <= 4294967296
                                                require mem[_24989] + 32 <= return_data.size
                                                require mem[mem[_24989] + _24989] <= 4294967296 and mem[_24989] + (32 * mem[mem[_24989] + _24989]) + 32 <= return_data.size
                                                mem[_24989 + ceil32(return_data.size)] = mem[mem[_24989] + _24989]
                                                _26141 = mem[_25492 + _24989]
                                                idx = 0
                                                while idx < 32 * _26141:
                                                    mem[_24989 + ceil32(return_data.size) + idx + 32] = mem[_25492 + _24989 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26141) + _24989 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[288] = 3
                                        mem[64] = 416
                                        mem[320] = ETHAddress
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _21023 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21025 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21025:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21025) + _21023 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24984 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25482 = mem[_24984]
                                                    require mem[_24984] <= 4294967296
                                                    require mem[_24984] + 32 <= return_data.size
                                                    require mem[mem[_24984] + _24984] <= 4294967296 and mem[_24984] + (32 * mem[mem[_24984] + _24984]) + 32 <= return_data.size
                                                    mem[_24984 + ceil32(return_data.size)] = mem[mem[_24984] + _24984]
                                                    _26136 = mem[_25482 + _24984]
                                                    idx = 0
                                                    while idx < 32 * _26136:
                                                        mem[_24984 + ceil32(return_data.size) + idx + 32] = mem[_25482 + _24984 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26136) + _24984 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21687 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[288]
                                                    _21689 = mem[288]
                                                    idx = 0
                                                    while idx < 32 * _21689:
                                                        mem[mem[64] + idx + 164] = mem[idx + 320]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21689) + _21687 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24985 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25484 = mem[_24985]
                                                    require mem[_24985] <= 4294967296
                                                    require mem[_24985] + 32 <= return_data.size
                                                    require mem[mem[_24985] + _24985] <= 4294967296 and mem[_24985] + (32 * mem[mem[_24985] + _24985]) + 32 <= return_data.size
                                                    mem[_24985 + ceil32(return_data.size)] = mem[mem[_24985] + _24985]
                                                    _26137 = mem[_25484 + _24985]
                                                    idx = 0
                                                    while idx < 32 * _26137:
                                                        mem[_24985 + ceil32(return_data.size) + idx + 32] = mem[_25484 + _24985 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26137) + _24985 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21691 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[288]
                                                _21693 = mem[288]
                                                idx = 0
                                                while idx < 32 * _21693:
                                                    mem[mem[64] + idx + 164] = mem[idx + 320]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21693) + _21691 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24986 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25486 = mem[_24986]
                                                require mem[_24986] <= 4294967296
                                                require mem[_24986] + 32 <= return_data.size
                                                require mem[mem[_24986] + _24986] <= 4294967296 and mem[_24986] + (32 * mem[mem[_24986] + _24986]) + 32 <= return_data.size
                                                mem[_24986 + ceil32(return_data.size)] = mem[mem[_24986] + _24986]
                                                _26138 = mem[_25486 + _24986]
                                                idx = 0
                                                while idx < 32 * _26138:
                                                    mem[_24986 + ceil32(return_data.size) + idx + 32] = mem[_25486 + _24986 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26138) + _24986 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                        else:
                            mem[192] = 3
                            mem[224] = sub_c0b6201cAddress
                            mem[256] = baseTokenAddress
                            mem[288] = ETHAddress
                            mem[420] = this.address
                            mem[452] = block.timestamp + 30
                            mem[484] = 3
                            mem[516 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[516 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20987 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20989 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20989:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20989) + _20987 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24957 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25428 = mem[_24957]
                                                require mem[_24957] <= 4294967296
                                                require mem[_24957] + 32 <= return_data.size
                                                require mem[mem[_24957] + _24957] <= 4294967296 and mem[_24957] + (32 * mem[mem[_24957] + _24957]) + 32 <= return_data.size
                                                mem[_24957 + ceil32(return_data.size)] = mem[mem[_24957] + _24957]
                                                _26109 = mem[_25428 + _24957]
                                                idx = 0
                                                while idx < 32 * _26109:
                                                    mem[_24957 + ceil32(return_data.size) + idx + 32] = mem[_25428 + _24957 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26109) + _24957 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21615 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21617 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21617:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21617) + _21615 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24958 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25430 = mem[_24958]
                                                require mem[_24958] <= 4294967296
                                                require mem[_24958] + 32 <= return_data.size
                                                require mem[mem[_24958] + _24958] <= 4294967296 and mem[_24958] + (32 * mem[mem[_24958] + _24958]) + 32 <= return_data.size
                                                mem[_24958 + ceil32(return_data.size)] = mem[mem[_24958] + _24958]
                                                _26110 = mem[_25430 + _24958]
                                                idx = 0
                                                while idx < 32 * _26110:
                                                    mem[_24958 + ceil32(return_data.size) + idx + 32] = mem[_25430 + _24958 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26110) + _24958 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21619 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21621 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21621:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21621) + _21619 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24959 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25432 = mem[_24959]
                                            require mem[_24959] <= 4294967296
                                            require mem[_24959] + 32 <= return_data.size
                                            require mem[mem[_24959] + _24959] <= 4294967296 and mem[_24959] + (32 * mem[mem[_24959] + _24959]) + 32 <= return_data.size
                                            mem[_24959 + ceil32(return_data.size)] = mem[mem[_24959] + _24959]
                                            _26111 = mem[_25432 + _24959]
                                            idx = 0
                                            while idx < 32 * _26111:
                                                mem[_24959 + ceil32(return_data.size) + idx + 32] = mem[_25432 + _24959 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26111) + _24959 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20983 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20985 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20985:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20985) + _20983 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24954 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25422 = mem[_24954]
                                                require mem[_24954] <= 4294967296
                                                require mem[_24954] + 32 <= return_data.size
                                                require mem[mem[_24954] + _24954] <= 4294967296 and mem[_24954] + (32 * mem[mem[_24954] + _24954]) + 32 <= return_data.size
                                                mem[_24954 + ceil32(return_data.size)] = mem[mem[_24954] + _24954]
                                                _26106 = mem[_25422 + _24954]
                                                idx = 0
                                                while idx < 32 * _26106:
                                                    mem[_24954 + ceil32(return_data.size) + idx + 32] = mem[_25422 + _24954 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26106) + _24954 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21607 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21609 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21609:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21609) + _21607 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24955 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25424 = mem[_24955]
                                                require mem[_24955] <= 4294967296
                                                require mem[_24955] + 32 <= return_data.size
                                                require mem[mem[_24955] + _24955] <= 4294967296 and mem[_24955] + (32 * mem[mem[_24955] + _24955]) + 32 <= return_data.size
                                                mem[_24955 + ceil32(return_data.size)] = mem[mem[_24955] + _24955]
                                                _26107 = mem[_25424 + _24955]
                                                idx = 0
                                                while idx < 32 * _26107:
                                                    mem[_24955 + ceil32(return_data.size) + idx + 32] = mem[_25424 + _24955 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26107) + _24955 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21611 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21613 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21613:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21613) + _21611 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24956 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25426 = mem[_24956]
                                            require mem[_24956] <= 4294967296
                                            require mem[_24956] + 32 <= return_data.size
                                            require mem[mem[_24956] + _24956] <= 4294967296 and mem[_24956] + (32 * mem[mem[_24956] + _24956]) + 32 <= return_data.size
                                            mem[_24956 + ceil32(return_data.size)] = mem[mem[_24956] + _24956]
                                            _26108 = mem[_25426 + _24956]
                                            idx = 0
                                            while idx < 32 * _26108:
                                                mem[_24956 + ceil32(return_data.size) + idx + 32] = mem[_25426 + _24956 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26108) + _24956 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20995 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20997 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20997:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20997) + _20995 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24963 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25440 = mem[_24963]
                                                    require mem[_24963] <= 4294967296
                                                    require mem[_24963] + 32 <= return_data.size
                                                    require mem[mem[_24963] + _24963] <= 4294967296 and mem[_24963] + (32 * mem[mem[_24963] + _24963]) + 32 <= return_data.size
                                                    mem[_24963 + ceil32(return_data.size)] = mem[mem[_24963] + _24963]
                                                    _26115 = mem[_25440 + _24963]
                                                    idx = 0
                                                    while idx < 32 * _26115:
                                                        mem[_24963 + ceil32(return_data.size) + idx + 32] = mem[_25440 + _24963 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26115) + _24963 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                if idx != wallets.length - 1:
                                                    _21633 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21633:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21633) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24964 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25442 = mem[_24964]
                                                    require mem[_24964] <= 4294967296
                                                    require mem[_24964] + 32 <= return_data.size
                                                    require mem[mem[_24964] + _24964] <= 4294967296 and mem[_24964] + (32 * mem[mem[_24964] + _24964]) + 32 <= return_data.size
                                                    mem[_24964 + ceil32(return_data.size)] = mem[mem[_24964] + _24964]
                                                    _26116 = mem[_25442 + _24964]
                                                    idx = 0
                                                    while idx < 32 * _26116:
                                                        mem[_24964 + ceil32(return_data.size) + idx + 32] = mem[_25442 + _24964 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26116) + _24964 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21637 = mem[320]
                                                t = 0
                                                while t < 32 * _21637:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21637) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24965 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25444 = mem[_24965]
                                                require mem[_24965] <= 4294967296
                                                require mem[_24965] + 32 <= return_data.size
                                                require mem[mem[_24965] + _24965] <= 4294967296 and mem[_24965] + (32 * mem[mem[_24965] + _24965]) + 32 <= return_data.size
                                                mem[_24965 + ceil32(return_data.size)] = mem[mem[_24965] + _24965]
                                                _26117 = mem[_25444 + _24965]
                                                idx = 0
                                                while idx < 32 * _26117:
                                                    mem[_24965 + ceil32(return_data.size) + idx + 32] = mem[_25444 + _24965 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26117) + _24965 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20991 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20993 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20993:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20993) + _20991 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24960 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25434 = mem[_24960]
                                                    require mem[_24960] <= 4294967296
                                                    require mem[_24960] + 32 <= return_data.size
                                                    require mem[mem[_24960] + _24960] <= 4294967296 and mem[_24960] + (32 * mem[mem[_24960] + _24960]) + 32 <= return_data.size
                                                    mem[_24960 + ceil32(return_data.size)] = mem[mem[_24960] + _24960]
                                                    _26112 = mem[_25434 + _24960]
                                                    idx = 0
                                                    while idx < 32 * _26112:
                                                        mem[_24960 + ceil32(return_data.size) + idx + 32] = mem[_25434 + _24960 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26112) + _24960 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21623 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21625 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21625:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21625) + _21623 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24961 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25436 = mem[_24961]
                                                    require mem[_24961] <= 4294967296
                                                    require mem[_24961] + 32 <= return_data.size
                                                    require mem[mem[_24961] + _24961] <= 4294967296 and mem[_24961] + (32 * mem[mem[_24961] + _24961]) + 32 <= return_data.size
                                                    mem[_24961 + ceil32(return_data.size)] = mem[mem[_24961] + _24961]
                                                    _26113 = mem[_25436 + _24961]
                                                    idx = 0
                                                    while idx < 32 * _26113:
                                                        mem[_24961 + ceil32(return_data.size) + idx + 32] = mem[_25436 + _24961 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26113) + _24961 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21627 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21629 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21629:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21629) + _21627 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24962 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25438 = mem[_24962]
                                                require mem[_24962] <= 4294967296
                                                require mem[_24962] + 32 <= return_data.size
                                                require mem[mem[_24962] + _24962] <= 4294967296 and mem[_24962] + (32 * mem[mem[_24962] + _24962]) + 32 <= return_data.size
                                                mem[_24962 + ceil32(return_data.size)] = mem[mem[_24962] + _24962]
                                                _26114 = mem[_25438 + _24962]
                                                idx = 0
                                                while idx < 32 * _26114:
                                                    mem[_24962 + ceil32(return_data.size) + idx + 32] = mem[_25438 + _24962 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26114) + _24962 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _21003 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21005 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21005:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21005) + _21003 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24969 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25452 = mem[_24969]
                                                    require mem[_24969] <= 4294967296
                                                    require mem[_24969] + 32 <= return_data.size
                                                    require mem[mem[_24969] + _24969] <= 4294967296 and mem[_24969] + (32 * mem[mem[_24969] + _24969]) + 32 <= return_data.size
                                                    mem[_24969 + ceil32(return_data.size)] = mem[mem[_24969] + _24969]
                                                    _26121 = mem[_25452 + _24969]
                                                    idx = 0
                                                    while idx < 32 * _26121:
                                                        mem[_24969 + ceil32(return_data.size) + idx + 32] = mem[_25452 + _24969 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26121) + _24969 + ceil32(return_data.size) + 32
                                                else:
                                                    if idx == wallets.length - 1:
                                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 0
                                                        mem[mem[64] + 68] = wallets[idx]
                                                        mem[mem[64] + 100] = block.timestamp
                                                        mem[mem[64] + 36] = 128
                                                        mem[mem[64] + 132] = mem[320]
                                                        _21653 = mem[320]
                                                        t = 0
                                                        while t < 32 * _21653:
                                                            mem[mem[64] + t + 164] = mem[t + 352]
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                           value eth.balance(this.address) wei
                                                             gas gas_remaining wei
                                                            args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21653) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _24971 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _25456 = mem[_24971]
                                                        require mem[_24971] <= 4294967296
                                                        require mem[_24971] + 32 <= return_data.size
                                                        require mem[mem[_24971] + _24971] <= 4294967296 and mem[_24971] + (32 * mem[mem[_24971] + _24971]) + 32 <= return_data.size
                                                        mem[_24971 + ceil32(return_data.size)] = mem[mem[_24971] + _24971]
                                                        _26123 = mem[_25456 + _24971]
                                                        idx = 0
                                                        while idx < 32 * _26123:
                                                            mem[_24971 + ceil32(return_data.size) + idx + 32] = mem[_25456 + _24971 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[64] = (32 * _26123) + _24971 + ceil32(return_data.size) + 32
                                                        s = s + 1
                                                        t = eth.balance(this.address)
                                                        continue 
                                                    _21647 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21649 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21649:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21649) + _21647 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24970 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25454 = mem[_24970]
                                                    require mem[_24970] <= 4294967296
                                                    require mem[_24970] + 32 <= return_data.size
                                                    require mem[mem[_24970] + _24970] <= 4294967296 and mem[_24970] + (32 * mem[mem[_24970] + _24970]) + 32 <= return_data.size
                                                    mem[_24970 + ceil32(return_data.size)] = mem[mem[_24970] + _24970]
                                                    _26122 = mem[_25454 + _24970]
                                                    idx = 0
                                                    while idx < 32 * _26122:
                                                        mem[_24970 + ceil32(return_data.size) + idx + 32] = mem[_25454 + _24970 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26122) + _24970 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21001 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21001:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21001) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24966 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25446 = mem[_24966]
                                                    require mem[_24966] <= 4294967296
                                                    require mem[_24966] + 32 <= return_data.size
                                                    require mem[mem[_24966] + _24966] <= 4294967296 and mem[_24966] + (32 * mem[mem[_24966] + _24966]) + 32 <= return_data.size
                                                    mem[_24966 + ceil32(return_data.size)] = mem[mem[_24966] + _24966]
                                                    _26118 = mem[_25446 + _24966]
                                                    idx = 0
                                                    while idx < 32 * _26118:
                                                        mem[_24966 + ceil32(return_data.size) + idx + 32] = mem[_25446 + _24966 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26118) + _24966 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21639 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21641 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21641:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21641) + _21639 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24967 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25448 = mem[_24967]
                                                    require mem[_24967] <= 4294967296
                                                    require mem[_24967] + 32 <= return_data.size
                                                    require mem[mem[_24967] + _24967] <= 4294967296 and mem[_24967] + (32 * mem[mem[_24967] + _24967]) + 32 <= return_data.size
                                                    mem[_24967 + ceil32(return_data.size)] = mem[mem[_24967] + _24967]
                                                    _26119 = mem[_25448 + _24967]
                                                    idx = 0
                                                    while idx < 32 * _26119:
                                                        mem[_24967 + ceil32(return_data.size) + idx + 32] = mem[_25448 + _24967 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26119) + _24967 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21643 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21645 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21645:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21645) + _21643 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24968 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25450 = mem[_24968]
                                                require mem[_24968] <= 4294967296
                                                require mem[_24968] + 32 <= return_data.size
                                                require mem[mem[_24968] + _24968] <= 4294967296 and mem[_24968] + (32 * mem[mem[_24968] + _24968]) + 32 <= return_data.size
                                                mem[_24968 + ceil32(return_data.size)] = mem[mem[_24968] + _24968]
                                                _26120 = mem[_25450 + _24968]
                                                idx = 0
                                                while idx < 32 * _26120:
                                                    mem[_24968 + ceil32(return_data.size) + idx + 32] = mem[_25450 + _24968 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26120) + _24968 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                    else:
                        mem[96] = 3
                        mem[128] = ETHAddress
                        mem[160] = baseTokenAddress
                        mem[192] = sub_c0b6201cAddress
                        mem[388 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactAVAXForTokensSupportingFeeOnTransferTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                           value eth.balance(this.address) / 1000 wei
                             gas gas_remaining wei
                            args 0, 128, address(this.address), block.timestamp + 30, 3, mem[388 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_c0b6201cAddress)
                        staticcall sub_c0b6201cAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sub_c0b6201cAddress)
                        call sub_c0b6201cAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(baseTokenAddress)
                        call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args routerAddress, -1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if baseTokenAddress == ETHAddress:
                            mem[224] = 2
                            mem[256] = sub_c0b6201cAddress
                            mem[288] = baseTokenAddress
                            mem[420] = this.address
                            mem[452] = block.timestamp + 30
                            mem[484] = 2
                            mem[516 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 2, mem[516 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[388] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args address(this.address), wallets, 0, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[320] = 2
                                    mem[64] = 416
                                    mem[352] = baseTokenAddress
                                    mem[384] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20963 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20965 = mem[320]
                                                idx = 0
                                                while idx < 32 * _20965:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20965) + _20963 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24939 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25392 = mem[_24939]
                                                require mem[_24939] <= 4294967296
                                                require mem[_24939] + 32 <= return_data.size
                                                require mem[mem[_24939] + _24939] <= 4294967296 and mem[_24939] + (32 * mem[mem[_24939] + _24939]) + 32 <= return_data.size
                                                mem[_24939 + ceil32(return_data.size)] = mem[mem[_24939] + _24939]
                                                _26091 = mem[_25392 + _24939]
                                                idx = 0
                                                while idx < 32 * _26091:
                                                    mem[_24939 + ceil32(return_data.size) + idx + 32] = mem[_25392 + _24939 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26091) + _24939 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21567 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21569 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21569:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21569) + _21567 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24940 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25394 = mem[_24940]
                                                require mem[_24940] <= 4294967296
                                                require mem[_24940] + 32 <= return_data.size
                                                require mem[mem[_24940] + _24940] <= 4294967296 and mem[_24940] + (32 * mem[mem[_24940] + _24940]) + 32 <= return_data.size
                                                mem[_24940 + ceil32(return_data.size)] = mem[mem[_24940] + _24940]
                                                _26092 = mem[_25394 + _24940]
                                                idx = 0
                                                while idx < 32 * _26092:
                                                    mem[_24940 + ceil32(return_data.size) + idx + 32] = mem[_25394 + _24940 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26092) + _24940 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21571 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21573 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21573:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21573) + _21571 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24941 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25396 = mem[_24941]
                                            require mem[_24941] <= 4294967296
                                            require mem[_24941] + 32 <= return_data.size
                                            require mem[mem[_24941] + _24941] <= 4294967296 and mem[_24941] + (32 * mem[mem[_24941] + _24941]) + 32 <= return_data.size
                                            mem[_24941 + ceil32(return_data.size)] = mem[mem[_24941] + _24941]
                                            _26093 = mem[_25396 + _24941]
                                            idx = 0
                                            while idx < 32 * _26093:
                                                mem[_24941 + ceil32(return_data.size) + idx + 32] = mem[_25396 + _24941 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26093) + _24941 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[320] = 3
                                    mem[64] = 448
                                    mem[352] = ETHAddress
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _20961 = mem[320]
                                                t = 0
                                                while t < 32 * _20961:
                                                    mem[mem[64] + t + 164] = mem[t + 352]
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20961) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24936 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25386 = mem[_24936]
                                                require mem[_24936] <= 4294967296
                                                require mem[_24936] + 32 <= return_data.size
                                                require mem[mem[_24936] + _24936] <= 4294967296 and mem[_24936] + (32 * mem[mem[_24936] + _24936]) + 32 <= return_data.size
                                                mem[_24936 + ceil32(return_data.size)] = mem[mem[_24936] + _24936]
                                                _26088 = mem[_25386 + _24936]
                                                idx = 0
                                                while idx < 32 * _26088:
                                                    mem[_24936 + ceil32(return_data.size) + idx + 32] = mem[_25386 + _24936 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26088) + _24936 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21559 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21561 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21561:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21561) + _21559 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24937 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25388 = mem[_24937]
                                                require mem[_24937] <= 4294967296
                                                require mem[_24937] + 32 <= return_data.size
                                                require mem[mem[_24937] + _24937] <= 4294967296 and mem[_24937] + (32 * mem[mem[_24937] + _24937]) + 32 <= return_data.size
                                                mem[_24937 + ceil32(return_data.size)] = mem[mem[_24937] + _24937]
                                                _26089 = mem[_25388 + _24937]
                                                idx = 0
                                                while idx < 32 * _26089:
                                                    mem[_24937 + ceil32(return_data.size) + idx + 32] = mem[_25388 + _24937 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26089) + _24937 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21563 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[320]
                                            _21565 = mem[320]
                                            idx = 0
                                            while idx < 32 * _21565:
                                                mem[mem[64] + idx + 164] = mem[idx + 352]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21565) + _21563 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24938 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25390 = mem[_24938]
                                            require mem[_24938] <= 4294967296
                                            require mem[_24938] + 32 <= return_data.size
                                            require mem[mem[_24938] + _24938] <= 4294967296 and mem[_24938] + (32 * mem[mem[_24938] + _24938]) + 32 <= return_data.size
                                            mem[_24938 + ceil32(return_data.size)] = mem[mem[_24938] + _24938]
                                            _26090 = mem[_25390 + _24938]
                                            idx = 0
                                            while idx < 32 * _26090:
                                                mem[_24938 + ceil32(return_data.size) + idx + 32] = mem[_25390 + _24938 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26090) + _24938 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20971 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20973 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20973:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20973) + _20971 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24945 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25404 = mem[_24945]
                                                    require mem[_24945] <= 4294967296
                                                    require mem[_24945] + 32 <= return_data.size
                                                    require mem[mem[_24945] + _24945] <= 4294967296 and mem[_24945] + (32 * mem[mem[_24945] + _24945]) + 32 <= return_data.size
                                                    mem[_24945 + ceil32(return_data.size)] = mem[mem[_24945] + _24945]
                                                    _26097 = mem[_25404 + _24945]
                                                    idx = 0
                                                    while idx < 32 * _26097:
                                                        mem[_24945 + ceil32(return_data.size) + idx + 32] = mem[_25404 + _24945 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26097) + _24945 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21585 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21585:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21585) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24946 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25406 = mem[_24946]
                                                    require mem[_24946] <= 4294967296
                                                    require mem[_24946] + 32 <= return_data.size
                                                    require mem[mem[_24946] + _24946] <= 4294967296 and mem[_24946] + (32 * mem[mem[_24946] + _24946]) + 32 <= return_data.size
                                                    mem[_24946 + ceil32(return_data.size)] = mem[mem[_24946] + _24946]
                                                    _26098 = mem[_25406 + _24946]
                                                    idx = 0
                                                    while idx < 32 * _26098:
                                                        mem[_24946 + ceil32(return_data.size) + idx + 32] = mem[_25406 + _24946 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26098) + _24946 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21587 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21589 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21589:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21589) + _21587 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24947 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25408 = mem[_24947]
                                                require mem[_24947] <= 4294967296
                                                require mem[_24947] + 32 <= return_data.size
                                                require mem[mem[_24947] + _24947] <= 4294967296 and mem[_24947] + (32 * mem[mem[_24947] + _24947]) + 32 <= return_data.size
                                                mem[_24947 + ceil32(return_data.size)] = mem[mem[_24947] + _24947]
                                                _26099 = mem[_25408 + _24947]
                                                idx = 0
                                                while idx < 32 * _26099:
                                                    mem[_24947 + ceil32(return_data.size) + idx + 32] = mem[_25408 + _24947 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26099) + _24947 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20969 = mem[320]
                                                    t = 0
                                                    while t < 32 * _20969:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20969) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24942 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25398 = mem[_24942]
                                                    require mem[_24942] <= 4294967296
                                                    require mem[_24942] + 32 <= return_data.size
                                                    require mem[mem[_24942] + _24942] <= 4294967296 and mem[_24942] + (32 * mem[mem[_24942] + _24942]) + 32 <= return_data.size
                                                    mem[_24942 + ceil32(return_data.size)] = mem[mem[_24942] + _24942]
                                                    _26094 = mem[_25398 + _24942]
                                                    idx = 0
                                                    while idx < 32 * _26094:
                                                        mem[_24942 + ceil32(return_data.size) + idx + 32] = mem[_25398 + _24942 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26094) + _24942 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21575 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21577 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21577:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21577) + _21575 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24943 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25400 = mem[_24943]
                                                    require mem[_24943] <= 4294967296
                                                    require mem[_24943] + 32 <= return_data.size
                                                    require mem[mem[_24943] + _24943] <= 4294967296 and mem[_24943] + (32 * mem[mem[_24943] + _24943]) + 32 <= return_data.size
                                                    mem[_24943 + ceil32(return_data.size)] = mem[mem[_24943] + _24943]
                                                    _26095 = mem[_25400 + _24943]
                                                    idx = 0
                                                    while idx < 32 * _26095:
                                                        mem[_24943 + ceil32(return_data.size) + idx + 32] = mem[_25400 + _24943 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26095) + _24943 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21579 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21581 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21581:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21581) + _21579 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24944 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25402 = mem[_24944]
                                                require mem[_24944] <= 4294967296
                                                require mem[_24944] + 32 <= return_data.size
                                                require mem[mem[_24944] + _24944] <= 4294967296 and mem[_24944] + (32 * mem[mem[_24944] + _24944]) + 32 <= return_data.size
                                                mem[_24944 + ceil32(return_data.size)] = mem[mem[_24944] + _24944]
                                                _26096 = mem[_25402 + _24944]
                                                idx = 0
                                                while idx < 32 * _26096:
                                                    mem[_24944 + ceil32(return_data.size) + idx + 32] = mem[_25402 + _24944 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26096) + _24944 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[388] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args address(this.address), wallets, 0, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[320] = 2
                                        mem[64] = 416
                                        mem[352] = baseTokenAddress
                                        mem[384] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20979 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20981 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20981:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20981) + _20979 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24951 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25416 = mem[_24951]
                                                    require mem[_24951] <= 4294967296
                                                    require mem[_24951] + 32 <= return_data.size
                                                    require mem[mem[_24951] + _24951] <= 4294967296 and mem[_24951] + (32 * mem[mem[_24951] + _24951]) + 32 <= return_data.size
                                                    mem[_24951 + ceil32(return_data.size)] = mem[mem[_24951] + _24951]
                                                    _26103 = mem[_25416 + _24951]
                                                    idx = 0
                                                    while idx < 32 * _26103:
                                                        mem[_24951 + ceil32(return_data.size) + idx + 32] = mem[_25416 + _24951 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26103) + _24951 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21601 = mem[320]
                                                    t = 0
                                                    while t < 32 * _21601:
                                                        mem[mem[64] + t + 164] = mem[t + 352]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21601) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24952 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25418 = mem[_24952]
                                                    require mem[_24952] <= 4294967296
                                                    require mem[_24952] + 32 <= return_data.size
                                                    require mem[mem[_24952] + _24952] <= 4294967296 and mem[_24952] + (32 * mem[mem[_24952] + _24952]) + 32 <= return_data.size
                                                    mem[_24952 + ceil32(return_data.size)] = mem[mem[_24952] + _24952]
                                                    _26104 = mem[_25418 + _24952]
                                                    idx = 0
                                                    while idx < 32 * _26104:
                                                        mem[_24952 + ceil32(return_data.size) + idx + 32] = mem[_25418 + _24952 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26104) + _24952 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21603 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21605 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21605:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21605) + _21603 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24953 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25420 = mem[_24953]
                                                require mem[_24953] <= 4294967296
                                                require mem[_24953] + 32 <= return_data.size
                                                require mem[mem[_24953] + _24953] <= 4294967296 and mem[_24953] + (32 * mem[mem[_24953] + _24953]) + 32 <= return_data.size
                                                mem[_24953 + ceil32(return_data.size)] = mem[mem[_24953] + _24953]
                                                _26105 = mem[_25420 + _24953]
                                                idx = 0
                                                while idx < 32 * _26105:
                                                    mem[_24953 + ceil32(return_data.size) + idx + 32] = mem[_25420 + _24953 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26105) + _24953 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[320] = 3
                                        mem[64] = 448
                                        mem[352] = ETHAddress
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20975 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _20977 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _20977:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20977) + _20975 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24948 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25410 = mem[_24948]
                                                    require mem[_24948] <= 4294967296
                                                    require mem[_24948] + 32 <= return_data.size
                                                    require mem[mem[_24948] + _24948] <= 4294967296 and mem[_24948] + (32 * mem[mem[_24948] + _24948]) + 32 <= return_data.size
                                                    mem[_24948 + ceil32(return_data.size)] = mem[mem[_24948] + _24948]
                                                    _26100 = mem[_25410 + _24948]
                                                    idx = 0
                                                    while idx < 32 * _26100:
                                                        mem[_24948 + ceil32(return_data.size) + idx + 32] = mem[_25410 + _24948 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26100) + _24948 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21591 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[320]
                                                    _21593 = mem[320]
                                                    idx = 0
                                                    while idx < 32 * _21593:
                                                        mem[mem[64] + idx + 164] = mem[idx + 352]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21593) + _21591 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24949 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25412 = mem[_24949]
                                                    require mem[_24949] <= 4294967296
                                                    require mem[_24949] + 32 <= return_data.size
                                                    require mem[mem[_24949] + _24949] <= 4294967296 and mem[_24949] + (32 * mem[mem[_24949] + _24949]) + 32 <= return_data.size
                                                    mem[_24949 + ceil32(return_data.size)] = mem[mem[_24949] + _24949]
                                                    _26101 = mem[_25412 + _24949]
                                                    idx = 0
                                                    while idx < 32 * _26101:
                                                        mem[_24949 + ceil32(return_data.size) + idx + 32] = mem[_25412 + _24949 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26101) + _24949 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21595 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[320]
                                                _21597 = mem[320]
                                                idx = 0
                                                while idx < 32 * _21597:
                                                    mem[mem[64] + idx + 164] = mem[idx + 352]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21597) + _21595 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24950 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25414 = mem[_24950]
                                                require mem[_24950] <= 4294967296
                                                require mem[_24950] + 32 <= return_data.size
                                                require mem[mem[_24950] + _24950] <= 4294967296 and mem[_24950] + (32 * mem[mem[_24950] + _24950]) + 32 <= return_data.size
                                                mem[_24950 + ceil32(return_data.size)] = mem[mem[_24950] + _24950]
                                                _26102 = mem[_25414 + _24950]
                                                idx = 0
                                                while idx < 32 * _26102:
                                                    mem[_24950 + ceil32(return_data.size) + idx + 32] = mem[_25414 + _24950 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26102) + _24950 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                        else:
                            mem[224] = 3
                            mem[256] = sub_c0b6201cAddress
                            mem[288] = baseTokenAddress
                            mem[320] = ETHAddress
                            mem[452] = this.address
                            mem[484] = block.timestamp + 30
                            mem[516] = 3
                            mem[548 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 0, 160, address(this.address), block.timestamp + 30, 3, mem[548 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(ETHAddress)
                            staticcall ETHAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            endingBalance = ext_call.return_data[0]
                            if mode == 5:
                                require eth.balance(this.address) / 1000 / 10000
                                sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                if sub_ab731cfa > sub_cb523a14:
                                    revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                require 0 < wallets.length
                                mem[0] = 10
                                require ext_code.size(ETHAddress)
                                staticcall ETHAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[420] = ext_call.return_data[0]
                                require ext_code.size(ETHAddress)
                                call ETHAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args this.address, 0, wallets, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(baseTokenAddress)
                                call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args routerAddress, 0, -1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if baseTokenAddress == ETHAddress:
                                    mem[352] = 2
                                    mem[64] = 448
                                    mem[384] = baseTokenAddress
                                    mem[416] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20939 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20941 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20941:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20941) + _20939 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24921 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25356 = mem[_24921]
                                                require mem[_24921] <= 4294967296
                                                require mem[_24921] + 32 <= return_data.size
                                                require mem[mem[_24921] + _24921] <= 4294967296 and mem[_24921] + (32 * mem[mem[_24921] + _24921]) + 32 <= return_data.size
                                                mem[_24921 + ceil32(return_data.size)] = mem[mem[_24921] + _24921]
                                                _26073 = mem[_25356 + _24921]
                                                idx = 0
                                                while idx < 32 * _26073:
                                                    mem[_24921 + ceil32(return_data.size) + idx + 32] = mem[_25356 + _24921 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26073) + _24921 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21519 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21521 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21521:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21521) + _21519 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24922 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25358 = mem[_24922]
                                                require mem[_24922] <= 4294967296
                                                require mem[_24922] + 32 <= return_data.size
                                                require mem[mem[_24922] + _24922] <= 4294967296 and mem[_24922] + (32 * mem[mem[_24922] + _24922]) + 32 <= return_data.size
                                                mem[_24922 + ceil32(return_data.size)] = mem[mem[_24922] + _24922]
                                                _26074 = mem[_25358 + _24922]
                                                idx = 0
                                                while idx < 32 * _26074:
                                                    mem[_24922 + ceil32(return_data.size) + idx + 32] = mem[_25358 + _24922 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26074) + _24922 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21523 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21525 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21525:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21525) + _21523 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24923 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25360 = mem[_24923]
                                            require mem[_24923] <= 4294967296
                                            require mem[_24923] + 32 <= return_data.size
                                            require mem[mem[_24923] + _24923] <= 4294967296 and mem[_24923] + (32 * mem[mem[_24923] + _24923]) + 32 <= return_data.size
                                            mem[_24923 + ceil32(return_data.size)] = mem[mem[_24923] + _24923]
                                            _26075 = mem[_25360 + _24923]
                                            idx = 0
                                            while idx < 32 * _26075:
                                                mem[_24923 + ceil32(return_data.size) + idx + 32] = mem[_25360 + _24923 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26075) + _24923 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[352] = 3
                                    mem[64] = 480
                                    mem[384] = ETHAddress
                                    mem[416] = baseTokenAddress
                                    mem[448] = sub_c0b6201cAddress
                                    require sub_43ff02f6 * wallets.length
                                    sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                    idx = 0
                                    while idx < wallets.length:
                                        s = 0
                                        t = 0
                                        while s < sub_43ff02f6:
                                            require idx < wallets.length
                                            mem[0] = 10
                                            if s != sub_43ff02f6 - 1:
                                                _20935 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _20937 = mem[352]
                                                idx = 0
                                                while idx < 32 * _20937:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _20937) + _20935 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24918 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25350 = mem[_24918]
                                                require mem[_24918] <= 4294967296
                                                require mem[_24918] + 32 <= return_data.size
                                                require mem[mem[_24918] + _24918] <= 4294967296 and mem[_24918] + (32 * mem[mem[_24918] + _24918]) + 32 <= return_data.size
                                                mem[_24918 + ceil32(return_data.size)] = mem[mem[_24918] + _24918]
                                                _26070 = mem[_25350 + _24918]
                                                idx = 0
                                                while idx < 32 * _26070:
                                                    mem[_24918 + ceil32(return_data.size) + idx + 32] = mem[_25350 + _24918 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26070) + _24918 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            if idx != wallets.length - 1:
                                                _21511 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21513 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21513:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value sub_1ef782ba wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21513) + _21511 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24919 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25352 = mem[_24919]
                                                require mem[_24919] <= 4294967296
                                                require mem[_24919] + 32 <= return_data.size
                                                require mem[mem[_24919] + _24919] <= 4294967296 and mem[_24919] + (32 * mem[mem[_24919] + _24919]) + 32 <= return_data.size
                                                mem[_24919 + ceil32(return_data.size)] = mem[mem[_24919] + _24919]
                                                _26071 = mem[_25352 + _24919]
                                                idx = 0
                                                while idx < 32 * _26071:
                                                    mem[_24919 + ceil32(return_data.size) + idx + 32] = mem[_25352 + _24919 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26071) + _24919 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            _21515 = mem[64]
                                            mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 68] = wallets[idx]
                                            mem[mem[64] + 100] = block.timestamp
                                            mem[mem[64] + 36] = 128
                                            mem[mem[64] + 132] = mem[352]
                                            _21517 = mem[352]
                                            idx = 0
                                            while idx < 32 * _21517:
                                                mem[mem[64] + idx + 164] = mem[idx + 384]
                                                idx = idx + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                               value eth.balance(this.address) wei
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (32 * _21517) + _21515 + -mem[64] + 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _24920 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _25354 = mem[_24920]
                                            require mem[_24920] <= 4294967296
                                            require mem[_24920] + 32 <= return_data.size
                                            require mem[mem[_24920] + _24920] <= 4294967296 and mem[_24920] + (32 * mem[mem[_24920] + _24920]) + 32 <= return_data.size
                                            mem[_24920 + ceil32(return_data.size)] = mem[mem[_24920] + _24920]
                                            _26072 = mem[_25354 + _24920]
                                            idx = 0
                                            while idx < 32 * _26072:
                                                mem[_24920 + ceil32(return_data.size) + idx + 32] = mem[_25354 + _24920 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[64] = (32 * _26072) + _24920 + ceil32(return_data.size) + 32
                                            s = s + 1
                                            t = eth.balance(this.address)
                                            continue 
                                        idx = idx + 1
                                        continue 
                            else:
                                if mode != 2:
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[420] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[352] = 2
                                        mem[64] = 448
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20947 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20949 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _20949:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20949) + _20947 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24927 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25368 = mem[_24927]
                                                    require mem[_24927] <= 4294967296
                                                    require mem[_24927] + 32 <= return_data.size
                                                    require mem[mem[_24927] + _24927] <= 4294967296 and mem[_24927] + (32 * mem[mem[_24927] + _24927]) + 32 <= return_data.size
                                                    mem[_24927 + ceil32(return_data.size)] = mem[mem[_24927] + _24927]
                                                    _26079 = mem[_25368 + _24927]
                                                    idx = 0
                                                    while idx < 32 * _26079:
                                                        mem[_24927 + ceil32(return_data.size) + idx + 32] = mem[_25368 + _24927 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26079) + _24927 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21535 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21537 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21537:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21537) + _21535 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24928 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25370 = mem[_24928]
                                                    require mem[_24928] <= 4294967296
                                                    require mem[_24928] + 32 <= return_data.size
                                                    require mem[mem[_24928] + _24928] <= 4294967296 and mem[_24928] + (32 * mem[mem[_24928] + _24928]) + 32 <= return_data.size
                                                    mem[_24928 + ceil32(return_data.size)] = mem[mem[_24928] + _24928]
                                                    _26080 = mem[_25370 + _24928]
                                                    idx = 0
                                                    while idx < 32 * _26080:
                                                        mem[_24928 + ceil32(return_data.size) + idx + 32] = mem[_25370 + _24928 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26080) + _24928 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21539 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21541 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21541:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21541) + _21539 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24929 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25372 = mem[_24929]
                                                require mem[_24929] <= 4294967296
                                                require mem[_24929] + 32 <= return_data.size
                                                require mem[mem[_24929] + _24929] <= 4294967296 and mem[_24929] + (32 * mem[mem[_24929] + _24929]) + 32 <= return_data.size
                                                mem[_24929 + ceil32(return_data.size)] = mem[mem[_24929] + _24929]
                                                _26081 = mem[_25372 + _24929]
                                                idx = 0
                                                while idx < 32 * _26081:
                                                    mem[_24929 + ceil32(return_data.size) + idx + 32] = mem[_25372 + _24929 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26081) + _24929 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[352] = 3
                                        mem[64] = 480
                                        mem[384] = ETHAddress
                                        mem[416] = baseTokenAddress
                                        mem[448] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20943 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20945 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _20945:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20945) + _20943 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24924 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25362 = mem[_24924]
                                                    require mem[_24924] <= 4294967296
                                                    require mem[_24924] + 32 <= return_data.size
                                                    require mem[mem[_24924] + _24924] <= 4294967296 and mem[_24924] + (32 * mem[mem[_24924] + _24924]) + 32 <= return_data.size
                                                    mem[_24924 + ceil32(return_data.size)] = mem[mem[_24924] + _24924]
                                                    _26076 = mem[_25362 + _24924]
                                                    idx = 0
                                                    while idx < 32 * _26076:
                                                        mem[_24924 + ceil32(return_data.size) + idx + 32] = mem[_25362 + _24924 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26076) + _24924 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21527 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21529 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21529:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21529) + _21527 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24925 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25364 = mem[_24925]
                                                    require mem[_24925] <= 4294967296
                                                    require mem[_24925] + 32 <= return_data.size
                                                    require mem[mem[_24925] + _24925] <= 4294967296 and mem[_24925] + (32 * mem[mem[_24925] + _24925]) + 32 <= return_data.size
                                                    mem[_24925 + ceil32(return_data.size)] = mem[mem[_24925] + _24925]
                                                    _26077 = mem[_25364 + _24925]
                                                    idx = 0
                                                    while idx < 32 * _26077:
                                                        mem[_24925 + ceil32(return_data.size) + idx + 32] = mem[_25364 + _24925 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26077) + _24925 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21531 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21533 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21533:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21533) + _21531 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24926 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25366 = mem[_24926]
                                                require mem[_24926] <= 4294967296
                                                require mem[_24926] + 32 <= return_data.size
                                                require mem[mem[_24926] + _24926] <= 4294967296 and mem[_24926] + (32 * mem[mem[_24926] + _24926]) + 32 <= return_data.size
                                                mem[_24926 + ceil32(return_data.size)] = mem[mem[_24926] + _24926]
                                                _26078 = mem[_25366 + _24926]
                                                idx = 0
                                                while idx < 32 * _26078:
                                                    mem[_24926 + ceil32(return_data.size) + idx + 32] = mem[_25366 + _24926 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26078) + _24926 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                else:
                                    require eth.balance(this.address) / 1000 / 10000
                                    sub_ab731cfa = -(endingBalance / eth.balance(this.address) / 1000 / 10000) + 10000
                                    if sub_ab731cfa > sub_cb523a14:
                                        revert with 0, '', 27, 'taxa ta alta pra caralhoooo'
                                    require 0 < wallets.length
                                    mem[0] = 10
                                    require ext_code.size(ETHAddress)
                                    staticcall ETHAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[420] = ext_call.return_data[0]
                                    require ext_code.size(ETHAddress)
                                    call ETHAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args this.address, 0, wallets, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(baseTokenAddress)
                                    call baseTokenAddress.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args routerAddress, 0, -1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if baseTokenAddress == ETHAddress:
                                        mem[352] = 2
                                        mem[64] = 448
                                        mem[384] = baseTokenAddress
                                        mem[416] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20957 = mem[352]
                                                    t = 0
                                                    while t < 32 * _20957:
                                                        mem[mem[64] + t + 164] = mem[t + 384]
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _20957) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24933 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25380 = mem[_24933]
                                                    require mem[_24933] <= 4294967296
                                                    require mem[_24933] + 32 <= return_data.size
                                                    require mem[mem[_24933] + _24933] <= 4294967296 and mem[_24933] + (32 * mem[mem[_24933] + _24933]) + 32 <= return_data.size
                                                    mem[_24933 + ceil32(return_data.size)] = mem[mem[_24933] + _24933]
                                                    _26085 = mem[_25380 + _24933]
                                                    idx = 0
                                                    while idx < 32 * _26085:
                                                        mem[_24933 + ceil32(return_data.size) + idx + 32] = mem[_25380 + _24933 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26085) + _24933 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                if idx != wallets.length - 1:
                                                    _21551 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21553 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21553:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21553) + _21551 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24934 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25382 = mem[_24934]
                                                    require mem[_24934] <= 4294967296
                                                    require mem[_24934] + 32 <= return_data.size
                                                    require mem[mem[_24934] + _24934] <= 4294967296 and mem[_24934] + (32 * mem[mem[_24934] + _24934]) + 32 <= return_data.size
                                                    mem[_24934 + ceil32(return_data.size)] = mem[mem[_24934] + _24934]
                                                    _26086 = mem[_25382 + _24934]
                                                    idx = 0
                                                    while idx < 32 * _26086:
                                                        mem[_24934 + ceil32(return_data.size) + idx + 32] = mem[_25382 + _24934 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26086) + _24934 + ceil32(return_data.size) + 32
                                                    s = s + 1
                                                    t = sub_1ef782ba
                                                    continue 
                                                _21555 = mem[64]
                                                mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 0
                                                mem[mem[64] + 68] = wallets[idx]
                                                mem[mem[64] + 100] = block.timestamp
                                                mem[mem[64] + 36] = 128
                                                mem[mem[64] + 132] = mem[352]
                                                _21557 = mem[352]
                                                idx = 0
                                                while idx < 32 * _21557:
                                                    mem[mem[64] + idx + 164] = mem[idx + 384]
                                                    idx = idx + 32
                                                    continue 
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                   value eth.balance(this.address) wei
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len (32 * _21557) + _21555 + -mem[64] + 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _24935 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _25384 = mem[_24935]
                                                require mem[_24935] <= 4294967296
                                                require mem[_24935] + 32 <= return_data.size
                                                require mem[mem[_24935] + _24935] <= 4294967296 and mem[_24935] + (32 * mem[mem[_24935] + _24935]) + 32 <= return_data.size
                                                mem[_24935 + ceil32(return_data.size)] = mem[mem[_24935] + _24935]
                                                _26087 = mem[_25384 + _24935]
                                                idx = 0
                                                while idx < 32 * _26087:
                                                    mem[_24935 + ceil32(return_data.size) + idx + 32] = mem[_25384 + _24935 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[64] = (32 * _26087) + _24935 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = eth.balance(this.address)
                                                continue 
                                            idx = idx + 1
                                            continue 
                                    else:
                                        mem[352] = 3
                                        mem[64] = 480
                                        mem[384] = ETHAddress
                                        mem[416] = baseTokenAddress
                                        mem[448] = sub_c0b6201cAddress
                                        require sub_43ff02f6 * wallets.length
                                        sub_1ef782ba = eth.balance(this.address) / sub_43ff02f6 * wallets.length
                                        idx = 0
                                        while idx < wallets.length:
                                            s = 0
                                            t = 0
                                            while s < sub_43ff02f6:
                                                require idx < wallets.length
                                                mem[0] = 10
                                                if s != sub_43ff02f6 - 1:
                                                    _20951 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _20953 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _20953:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _20953) + _20951 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24930 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25374 = mem[_24930]
                                                    require mem[_24930] <= 4294967296
                                                    require mem[_24930] + 32 <= return_data.size
                                                    require mem[mem[_24930] + _24930] <= 4294967296 and mem[_24930] + (32 * mem[mem[_24930] + _24930]) + 32 <= return_data.size
                                                    mem[_24930 + ceil32(return_data.size)] = mem[mem[_24930] + _24930]
                                                    _26082 = mem[_25374 + _24930]
                                                    idx = 0
                                                    while idx < 32 * _26082:
                                                        mem[_24930 + ceil32(return_data.size) + idx + 32] = mem[_25374 + _24930 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26082) + _24930 + ceil32(return_data.size) + 32
                                                else:
                                                    if idx == wallets.length - 1:
                                                        mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 0
                                                        mem[mem[64] + 68] = wallets[idx]
                                                        mem[mem[64] + 100] = block.timestamp
                                                        mem[mem[64] + 36] = 128
                                                        mem[mem[64] + 132] = mem[352]
                                                        _21549 = mem[352]
                                                        t = 0
                                                        while t < 32 * _21549:
                                                            mem[mem[64] + t + 164] = mem[t + 384]
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(routerAddress)
                                                        call routerAddress.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                                           value eth.balance(this.address) wei
                                                             gas gas_remaining wei
                                                            args 0, 128, wallets[idx], block.timestamp, mem[mem[64] + 132 len (32 * _21549) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _24932 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _25378 = mem[_24932]
                                                        require mem[_24932] <= 4294967296
                                                        require mem[_24932] + 32 <= return_data.size
                                                        require mem[mem[_24932] + _24932] <= 4294967296 and mem[_24932] + (32 * mem[mem[_24932] + _24932]) + 32 <= return_data.size
                                                        mem[_24932 + ceil32(return_data.size)] = mem[mem[_24932] + _24932]
                                                        _26084 = mem[_25378 + _24932]
                                                        idx = 0
                                                        while idx < 32 * _26084:
                                                            mem[_24932 + ceil32(return_data.size) + idx + 32] = mem[_25378 + _24932 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[64] = (32 * _26084) + _24932 + ceil32(return_data.size) + 32
                                                        s = s + 1
                                                        t = eth.balance(this.address)
                                                        continue 
                                                    _21543 = mem[64]
                                                    mem[mem[64]] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 0
                                                    mem[mem[64] + 68] = wallets[idx]
                                                    mem[mem[64] + 100] = block.timestamp
                                                    mem[mem[64] + 36] = 128
                                                    mem[mem[64] + 132] = mem[352]
                                                    _21545 = mem[352]
                                                    idx = 0
                                                    while idx < 32 * _21545:
                                                        mem[mem[64] + idx + 164] = mem[idx + 384]
                                                        idx = idx + 32
                                                        continue 
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                       value sub_1ef782ba wei
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (32 * _21545) + _21543 + -mem[64] + 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _24931 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _25376 = mem[_24931]
                                                    require mem[_24931] <= 4294967296
                                                    require mem[_24931] + 32 <= return_data.size
                                                    require mem[mem[_24931] + _24931] <= 4294967296 and mem[_24931] + (32 * mem[mem[_24931] + _24931]) + 32 <= return_data.size
                                                    mem[_24931 + ceil32(return_data.size)] = mem[mem[_24931] + _24931]
                                                    _26083 = mem[_25376 + _24931]
                                                    idx = 0
                                                    while idx < 32 * _26083:
                                                        mem[_24931 + ceil32(return_data.size) + idx + 32] = mem[_25376 + _24931 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[64] = (32 * _26083) + _24931 + ceil32(return_data.size) + 32
                                                s = s + 1
                                                t = sub_1ef782ba
                                                continue 
                                            idx = idx + 1
                                            continue 
                    if eth.balance(this.address) > 0:
                        if bool(stor9[address(msg.sender)]) != 1:
                            revert with 0, 
                                        32,
                                        56,
                                        0x6531303020626e627320616e6420692077686974656c69737420796f752c20636f6e74616374207073696c7661202d205073696c7661426f,
                                        mem[mem[64] + 124 len 8]
                        call msg.sender with:
                           value eth.balance(this.address) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - sub_1d9575a5(?)
#
mapping of uint8 stor0;
address adminAddress;

function admin() {
    return adminAddress
}

function _fallback() payable {
  stop
}

function changeAdmin(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require msg.sender == adminAddress
    if not arg1:
        revert with 0, 'new admin is the zero address'
    if ext_code.size(arg1):
        revert with 0, 'new admin is a contract'
    stor0[stor1] = 0
    adminAddress = arg1
    stor0[arg1] = 1
    return 1
}

function withdrawToken(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require msg.sender == adminAddress
    require ext_code.size(arg1)
    staticcall arg1.balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg2 > ext_call.return_data[0]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    71,
                    0x6e576974686472617720616d6f756e74206d75737420626520736d616c6c6572206f7220657175616c20746f2074686520617661696c61626c6520746f6b656e20616d6f756e74,
                    mem[235 len 25]
    call arg1 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args Mask(224, 32, arg2) << 224, mem[260 len 4]
    require ext_call.success
    return 1
}

function sub_c0ce282a(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    u = 32 * ('cd', 4).length
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        u = cd[s]
        idx = idx + 1
        continue 
    require msg.sender == adminAddress
    idx = 0
    while idx < ('cd', 4).length:
        require idx < ('cd', 4).length
        if ext_code.size(mem[(32 * idx) + 128]):
            revert with 0, 'callable cannot be a contract'
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 0
        stor0[mem[(32 * idx) + 140 len 20]] = 1
        idx = idx + 1
        continue 
    return 1
}

function withdrawEth(uint256 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    require msg.sender == adminAddress
    if not arg2:
        revert with 0, 'recipient cannot be 0 address'
    if not stor0[address(arg2)]:
        if arg2 != msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        49,
                        0x77726563697069656e74206d75737420626520612063616c6c61626c652061646472657373206f72207468652061646d69,
                        mem[213 len 15]
    if arg1 > eth.balance(this.address):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    69,
                    0x54576974686472617720616d6f756e74206d75737420626520736d616c6c6572206f7220657175616c20746f2074686520617661696c61626c652065746820616d6f756e74,
                    mem[233 len 27]
    call arg2 with:
       value arg1 wei
         gas 2300 * is_zero(value) wei
    return bool(ext_call.success)
}

function sub_22466fee(?) {
    require calldata.size - 4 >= 96
    require cd[36] == bool(cd[36])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (160 * ('cd', 68).length) + 36 <= calldata.size
    require ('cd', 68).length <= test266151307()
    mem[96] = ('cd', 68).length
    mem[64] = (32 * ('cd', 68).length) + 128
    if not ('cd', 68).length:
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = 10000
        u = cd[4]
        while idx < ('cd', 68).length:
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            require idx < ('cd', 68).length
            if uint16(cd[((160 * idx) + cd[68] + 100)]):
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _3056 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_3056] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_3056 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_3056 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_3056 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_3056 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3129 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _3153 = mem[_3129]
                    require mem[_3129 + 32] == bool(mem[_3129 + 32])
                    require idx < mem[96]
                    _3262 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3129 + 32])
                    mem[_3262] = _3153
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if 7 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                mem[mem[64] + 36] = address(s)
                                mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 68)])
                                mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 36)])
                                require ext_code.size(0x9229151ce11bf180b630bda0fdc567304adb2801)
                                delegate 0x9229151ce11bf180b630bda0fdc567304adb2801.0xc4dc5ff7 with:
                                     gas gas_remaining wei
                                    args u, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)])
                                mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3165 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _3192 = mem[_3165]
                                require mem[_3165 + 32] == bool(mem[_3165 + 32])
                                require idx < mem[96]
                                _3318 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3165 + 32])
                                mem[_3318] = _3192
                            else:
                                if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 26:
                                        revert with 0, 'exchangeType not exist'
                                    require idx < mem[96]
                                    _3176 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = 0
                                    mem[_3176] = u
                                else:
                                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                                    require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                                    delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                         gas gas_remaining wei
                                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3178 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    _3211 = mem[_3178]
                                    require mem[_3178 + 32] == bool(mem[_3178 + 32])
                                    require idx < mem[96]
                                    _3337 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3178 + 32])
                                    mem[_3337] = _3211
                        else:
                            _3126 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_3126]
                            mem[_3126 + 32] = address(s)
                            require 1 < mem[_3126]
                            mem[_3126 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_3126] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _3240 = mem[_3126]
                                require mem[_3126] <= test266151307()
                                mem[_3126 + 96] = mem[_3126]
                                mem[64] = _3126 + (32 * mem[_3126]) + 128
                                if not _3240:
                                    require 0 < mem[_3126 + 96]
                                    mem[_3126 + 128] = u
                                    _7531 = mem[_3126]
                                    s = 0
                                    while s < _7531 - 1:
                                        require s < mem[_3126]
                                        _7560 = mem[(32 * s) + _3126 + 32]
                                        require s + 1 < mem[_3126]
                                        _7584 = mem[(32 * s + 1) + _3126 + 32]
                                        if mem[(32 * s) + _3126 + 44 len 20] == mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3126 + 44 len 20] < mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            if not mem[(32 * s) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7584)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7560) == address(_7560):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7584)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7584) == address(_7560):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3126 + 96]
                                    _7583 = mem[_3126 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7644 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7644] = _7583
                                    else:
                                        _7710 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7710] = _7583 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3126 + 128 len 32 * _3240] = call.data[calldata.size len 32 * _3240]
                                    require 0 < mem[_3126 + 96]
                                    mem[_3126 + 128] = u
                                    _7532 = mem[_3126]
                                    s = 0
                                    while s < _7532 - 1:
                                        require s < mem[_3126]
                                        _7563 = mem[(32 * s) + _3126 + 32]
                                        require s + 1 < mem[_3126]
                                        _7586 = mem[(32 * s + 1) + _3126 + 32]
                                        if mem[(32 * s) + _3126 + 44 len 20] == mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3126 + 44 len 20] < mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            if not mem[(32 * s) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7586)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7563) == address(_7563):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7586)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7586) == address(_7563):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3126 + 96]
                                    _7585 = mem[_3126 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7651 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7651] = _7585
                                    else:
                                        _7714 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7714] = _7585 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _3258 = mem[_3126]
                                require mem[_3126] <= test266151307()
                                mem[_3126 + 96] = mem[_3126]
                                mem[64] = _3126 + (32 * mem[_3126]) + 128
                                if not _3258:
                                    require 0 < mem[_3126 + 96]
                                    mem[_3126 + 128] = uint16(t) * u / 10000
                                    _7533 = mem[_3126]
                                    s = 0
                                    while s < _7533 - 1:
                                        require s < mem[_3126]
                                        _7566 = mem[(32 * s) + _3126 + 32]
                                        require s + 1 < mem[_3126]
                                        _7588 = mem[(32 * s + 1) + _3126 + 32]
                                        if mem[(32 * s) + _3126 + 44 len 20] == mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3126 + 44 len 20] < mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            if not mem[(32 * s) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7588)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7566) == address(_7566):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7588)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7588) == address(_7566):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3126 + 96]
                                    _7587 = mem[_3126 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7658 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7658] = _7587
                                    else:
                                        _7718 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7718] = _7587 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3126 + 128 len 32 * _3258] = call.data[calldata.size len 32 * _3258]
                                    require 0 < mem[_3126 + 96]
                                    mem[_3126 + 128] = uint16(t) * u / 10000
                                    _7534 = mem[_3126]
                                    s = 0
                                    while s < _7534 - 1:
                                        require s < mem[_3126]
                                        _7569 = mem[(32 * s) + _3126 + 32]
                                        require s + 1 < mem[_3126]
                                        _7590 = mem[(32 * s + 1) + _3126 + 32]
                                        if mem[(32 * s) + _3126 + 44 len 20] == mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3126 + 44 len 20] < mem[(32 * s + 1) + _3126 + 44 len 20]:
                                            if not mem[(32 * s) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7590)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7569) == address(_7569):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3126 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3126 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7590)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3126 + 96]
                                            if mem[(32 * s) + _3126 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7590) == address(_7569):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 995 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (995 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3126 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3126 + 96]
                                                        mem[(32 * s + 1) + _3126 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3126 + 128] / mem[(32 * s) + _3126 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3126 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 0 / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3126 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3126 + 128]
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / 997 * mem[(32 * s) + _3126 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3126 + 96]
                                                                mem[(32 * s + 1) + _3126 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3126 + 128] / (997 * mem[(32 * s) + _3126 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3126 + 96]
                                    _7589 = mem[_3126 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7665 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7665] = _7589
                                    else:
                                        _7722 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7722] = _7589 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _3117 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_3117]
                        mem[_3117 + 32] = address(s)
                        require 1 < mem[_3117]
                        mem[_3117 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_3117 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_3117 + 100] = u
                            mem[_3117 + 132] = 64
                            mem[_3117 + 164] = mem[_3117]
                            s = 0
                            while s < 32 * mem[_3117]:
                                mem[s + _3117 + 196] = mem[s + _3117 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_3117 + 164 len (32 * mem[_3117]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3117 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3117 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7603 = mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_3117 + mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_3117 + mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3117 + ceil32(return_data.size) + 96] = mem[_3117 + mem[_3117 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _7632 = mem[_3117 + _7603 + 96]
                            s = 0
                            while s < 32 * _7632:
                                mem[s + _3117 + ceil32(return_data.size) + 128] = mem[s + _3117 + _7603 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7632) + _3117 + ceil32(return_data.size) + 128
                            require 1 < mem[_3117 + ceil32(return_data.size) + 96]
                            _11815 = mem[_3117 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11826 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11826] = _11815
                            else:
                                _11840 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11840] = _11815 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_3117 + 100] = uint16(t) * u / 10000
                            mem[_3117 + 132] = 64
                            mem[_3117 + 164] = mem[_3117]
                            s = 0
                            while s < 32 * mem[_3117]:
                                mem[s + _3117 + 196] = mem[s + _3117 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_3117 + 164 len (32 * mem[_3117]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3117 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3117 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7605 = mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_3117 + mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_3117 + mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3117 + ceil32(return_data.size) + 96] = mem[_3117 + mem[_3117 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _7633 = mem[_3117 + _7605 + 96]
                            s = 0
                            while s < 32 * _7633:
                                mem[s + _3117 + ceil32(return_data.size) + 128] = mem[s + _3117 + _7605 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7633) + _3117 + ceil32(return_data.size) + 128
                            require 1 < mem[_3117 + ceil32(return_data.size) + 96]
                            _11816 = mem[_3117 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11829 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11829] = _11816
                            else:
                                _11844 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11844] = _11816 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            else:
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[mem[64]] = 0xfff6cae900000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                call address(cd[((160 * idx) + cd[68] + 36)]).sync() with:
                     gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require idx < ('cd', 68).length
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _3062 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_3062] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_3062 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_3062 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_3062 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_3062 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3289 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _3328 = mem[_3289]
                    require mem[_3289 + 32] == bool(mem[_3289 + 32])
                    require idx < mem[96]
                    _3498 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3289 + 32])
                    mem[_3498] = _3328
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if 7 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                mem[mem[64] + 36] = address(s)
                                mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 68)])
                                mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 36)])
                                require ext_code.size(0x9229151ce11bf180b630bda0fdc567304adb2801)
                                delegate 0x9229151ce11bf180b630bda0fdc567304adb2801.0xc4dc5ff7 with:
                                     gas gas_remaining wei
                                    args u, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)])
                                mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3349 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _3405 = mem[_3349]
                                require mem[_3349 + 32] == bool(mem[_3349 + 32])
                                require idx < mem[96]
                                _3598 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3349 + 32])
                                mem[_3598] = _3405
                            else:
                                if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 26:
                                        revert with 0, 'exchangeType not exist'
                                    require idx < mem[96]
                                    _3375 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = 0
                                    mem[_3375] = u
                                else:
                                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                                    require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                                    delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                         gas gas_remaining wei
                                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3377 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    _3432 = mem[_3377]
                                    require mem[_3377 + 32] == bool(mem[_3377 + 32])
                                    require idx < mem[96]
                                    _3632 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3377 + 32])
                                    mem[_3632] = _3432
                        else:
                            _3286 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_3286]
                            mem[_3286 + 32] = address(s)
                            require 1 < mem[_3286]
                            mem[_3286 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_3286] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _3466 = mem[_3286]
                                require mem[_3286] <= test266151307()
                                mem[_3286 + 96] = mem[_3286]
                                mem[64] = _3286 + (32 * mem[_3286]) + 128
                                if not _3466:
                                    require 0 < mem[_3286 + 96]
                                    mem[_3286 + 128] = u
                                    _7535 = mem[_3286]
                                    s = 0
                                    while s < _7535 - 1:
                                        require s < mem[_3286]
                                        _7572 = mem[(32 * s) + _3286 + 32]
                                        require s + 1 < mem[_3286]
                                        _7594 = mem[(32 * s + 1) + _3286 + 32]
                                        if mem[(32 * s) + _3286 + 44 len 20] == mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3286 + 44 len 20] < mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            if not mem[(32 * s) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7594)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7572) == address(_7572):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7594)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7594) == address(_7572):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3286 + 96]
                                    _7593 = mem[_3286 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7676 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7676] = _7593
                                    else:
                                        _7728 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7728] = _7593 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3286 + 128 len 32 * _3466] = call.data[calldata.size len 32 * _3466]
                                    require 0 < mem[_3286 + 96]
                                    mem[_3286 + 128] = u
                                    _7536 = mem[_3286]
                                    s = 0
                                    while s < _7536 - 1:
                                        require s < mem[_3286]
                                        _7575 = mem[(32 * s) + _3286 + 32]
                                        require s + 1 < mem[_3286]
                                        _7596 = mem[(32 * s + 1) + _3286 + 32]
                                        if mem[(32 * s) + _3286 + 44 len 20] == mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3286 + 44 len 20] < mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            if not mem[(32 * s) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7596)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7575) == address(_7575):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7596)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7596) == address(_7575):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3286 + 96]
                                    _7595 = mem[_3286 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7683 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7683] = _7595
                                    else:
                                        _7732 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7732] = _7595 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _3494 = mem[_3286]
                                require mem[_3286] <= test266151307()
                                mem[_3286 + 96] = mem[_3286]
                                mem[64] = _3286 + (32 * mem[_3286]) + 128
                                if not _3494:
                                    require 0 < mem[_3286 + 96]
                                    mem[_3286 + 128] = uint16(t) * u / 10000
                                    _7537 = mem[_3286]
                                    s = 0
                                    while s < _7537 - 1:
                                        require s < mem[_3286]
                                        _7578 = mem[(32 * s) + _3286 + 32]
                                        require s + 1 < mem[_3286]
                                        _7598 = mem[(32 * s + 1) + _3286 + 32]
                                        if mem[(32 * s) + _3286 + 44 len 20] == mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3286 + 44 len 20] < mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            if not mem[(32 * s) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7598)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7578) == address(_7578):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7598)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7598) == address(_7578):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3286 + 96]
                                    _7597 = mem[_3286 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7690 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7690] = _7597
                                    else:
                                        _7736 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7736] = _7597 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3286 + 128 len 32 * _3494] = call.data[calldata.size len 32 * _3494]
                                    require 0 < mem[_3286 + 96]
                                    mem[_3286 + 128] = uint16(t) * u / 10000
                                    _7538 = mem[_3286]
                                    s = 0
                                    while s < _7538 - 1:
                                        require s < mem[_3286]
                                        _7581 = mem[(32 * s) + _3286 + 32]
                                        require s + 1 < mem[_3286]
                                        _7600 = mem[(32 * s + 1) + _3286 + 32]
                                        if mem[(32 * s) + _3286 + 44 len 20] == mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3286 + 44 len 20] < mem[(32 * s + 1) + _3286 + 44 len 20]:
                                            if not mem[(32 * s) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7600)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7581) == address(_7581):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3286 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3286 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7600)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3286 + 96]
                                            if mem[(32 * s) + _3286 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7600) == address(_7581):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 995 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (995 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3286 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3286 + 96]
                                                        mem[(32 * s + 1) + _3286 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3286 + 128] / mem[(32 * s) + _3286 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3286 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 0 / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3286 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3286 + 128]
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / 997 * mem[(32 * s) + _3286 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3286 + 96]
                                                                mem[(32 * s + 1) + _3286 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3286 + 128] / (997 * mem[(32 * s) + _3286 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3286 + 96]
                                    _7599 = mem[_3286 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7697 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7697] = _7599
                                    else:
                                        _7740 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7740] = _7599 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _3268 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_3268]
                        mem[_3268 + 32] = address(s)
                        require 1 < mem[_3268]
                        mem[_3268 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_3268 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_3268 + 100] = u
                            mem[_3268 + 132] = 64
                            mem[_3268 + 164] = mem[_3268]
                            s = 0
                            while s < 32 * mem[_3268]:
                                mem[s + _3268 + 196] = mem[s + _3268 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_3268 + 164 len (32 * mem[_3268]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3268 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3268 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7607 = mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_3268 + mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_3268 + mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3268 + ceil32(return_data.size) + 96] = mem[_3268 + mem[_3268 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _7634 = mem[_3268 + _7607 + 96]
                            s = 0
                            while s < 32 * _7634:
                                mem[s + _3268 + ceil32(return_data.size) + 128] = mem[s + _3268 + _7607 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7634) + _3268 + ceil32(return_data.size) + 128
                            require 1 < mem[_3268 + ceil32(return_data.size) + 96]
                            _11817 = mem[_3268 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11832 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11832] = _11817
                            else:
                                _11848 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11848] = _11817 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_3268 + 100] = uint16(t) * u / 10000
                            mem[_3268 + 132] = 64
                            mem[_3268 + 164] = mem[_3268]
                            s = 0
                            while s < 32 * mem[_3268]:
                                mem[s + _3268 + 196] = mem[s + _3268 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_3268 + 164 len (32 * mem[_3268]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3268 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3268 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7609 = mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_3268 + mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_3268 + mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3268 + ceil32(return_data.size) + 96] = mem[_3268 + mem[_3268 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _7635 = mem[_3268 + _7609 + 96]
                            s = 0
                            while s < 32 * _7635:
                                mem[s + _3268 + ceil32(return_data.size) + 128] = mem[s + _3268 + _7609 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7635) + _3268 + ceil32(return_data.size) + 128
                            require 1 < mem[_3268 + ceil32(return_data.size) + 96]
                            _11818 = mem[_3268 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11835 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11835] = _11818
                            else:
                                _11852 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11852] = _11818 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = cd[((160 * idx) + cd[68] + 164)]
            u = mem[mem[(32 * idx) + 128]]
            continue 
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = cd[4]
        while idx < ('cd', 68).length:
            require idx < mem[96]
            _7558 = mem[mem[(32 * idx) + 128]]
            require idx < ('cd', 68).length
            require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
            _7611 = mem[64]
            require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
            mem[64] = mem[64] + 160
            require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
            mem[_7611] = cd[((160 * idx) + cd[68] + 36)]
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            mem[_7611 + 32] = cd[((160 * idx) + cd[68] + 68)]
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            mem[_7611 + 64] = cd[((160 * idx) + cd[68] + 100)]
            require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
            mem[_7611 + 96] = cd[((160 * idx) + cd[68] + 132)]
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            mem[_7611 + 128] = cd[((160 * idx) + cd[68] + 164)]
            if not uint16(cd[((160 * idx) + cd[68] + 100)]):
                mem[mem[64]] = 0xa58d57400000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                mem[mem[64] + 36] = t
                mem[mem[64] + 68] = _7558
                mem[mem[64] + 100] = address(s)
                mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                mem[mem[64] + 196] = bool(cd[36])
                mem[mem[64] + 228] = uint16(cd[((160 * idx) + cd[68] + 132)])
                require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0xa58d574 with:
                     gas gas_remaining wei
                    args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _7558, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36]), uint16(cd[((160 * idx) + cd[68] + 132)])
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                if 3 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                    mem[mem[64] + 36] = t
                    mem[mem[64] + 68] = address(s)
                    mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 164] = bool(cd[36])
                    require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                    delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                         gas gas_remaining wei
                        args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    if 6 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                        mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                        mem[mem[64] + 36] = t
                        mem[mem[64] + 68] = address(s)
                        mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                        mem[mem[64] + 164] = bool(cd[36])
                        require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                        delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                             gas gas_remaining wei
                            args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if 7 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                            mem[mem[64]] = 0x589b898d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = t
                            mem[mem[64] + 36] = _7558
                            mem[mem[64] + 68] = address(s)
                            mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                            require ext_code.size(0x9229151ce11bf180b630bda0fdc567304adb2801)
                            delegate 0x9229151ce11bf180b630bda0fdc567304adb2801.0x589b898d with:
                                 gas gas_remaining wei
                                args t, _7558, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)])
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if 26 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                mem[mem[64]] = 0xd9fd7500000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = t
                                mem[mem[64] + 36] = address(s)
                                mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 68)])
                                mem[mem[64] + 100] = bool(cd[36])
                                require ext_code.size(0xf909b8931aff96c81f6c1380b6814960145b03fc)
                                delegate 0xf909b8931aff96c81f6c1380b6814960145b03fc.0xd9fd75 with:
                                     gas gas_remaining wei
                                    args t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), bool(cd[36])
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                if 32 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                    mem[mem[64]] = 0x35d92d6900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                                    mem[mem[64] + 36] = t
                                    mem[mem[64] + 68] = _7558
                                    mem[mem[64] + 100] = address(s)
                                    mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                                    mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                                    mem[mem[64] + 196] = bool(cd[36])
                                    require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                                    delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0x35d92d69 with:
                                         gas gas_remaining wei
                                        args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _7558, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = mem[mem[(32 * idx) + 128]]
            continue 
    else:
        mem[64] = (32 * ('cd', 68).length) + 192
        mem[(32 * ('cd', 68).length) + 128] = 0
        mem[(32 * ('cd', 68).length) + 160] = 0
        mem[var23001] = (32 * ('cd', 68).length) + 128
        s = var23001
        idx = var23002
        while idx - 1:
            mem[64] = mem[64] + 64
            mem[(32 * ('cd', 68).length) + 128] = 0
            mem[(32 * ('cd', 68).length) + 160] = 0
            mem[s + 32] = (32 * ('cd', 68).length) + 128
            s = s + 32
            idx = idx - 1
            continue 
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = 10000
        u = cd[4]
        while idx < ('cd', 68).length:
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            require idx < ('cd', 68).length
            if uint16(cd[((160 * idx) + cd[68] + 100)]):
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _11879 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_11879] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_11879 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_11879 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_11879 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_11879 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _11965 = mem[_11948]
                    require mem[_11948 + 32] == bool(mem[_11948 + 32])
                    require idx < mem[96]
                    _12036 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11948 + 32])
                    mem[_12036] = _11965
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if 7 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                mem[mem[64] + 36] = address(s)
                                mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 68)])
                                mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 36)])
                                require ext_code.size(0x9229151ce11bf180b630bda0fdc567304adb2801)
                                delegate 0x9229151ce11bf180b630bda0fdc567304adb2801.0xc4dc5ff7 with:
                                     gas gas_remaining wei
                                    args u, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)])
                                mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11973 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _11989 = mem[_11973]
                                require mem[_11973 + 32] == bool(mem[_11973 + 32])
                                require idx < mem[96]
                                _12069 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11973 + 32])
                                mem[_12069] = _11989
                            else:
                                if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 26:
                                        revert with 0, 'exchangeType not exist'
                                    require idx < mem[96]
                                    _11979 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = 0
                                    mem[_11979] = u
                                else:
                                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                                    require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                                    delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                         gas gas_remaining wei
                                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11981 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    _11999 = mem[_11981]
                                    require mem[_11981 + 32] == bool(mem[_11981 + 32])
                                    require idx < mem[96]
                                    _12081 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11981 + 32])
                                    mem[_12081] = _11999
                        else:
                            _11945 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_11945]
                            mem[_11945 + 32] = address(s)
                            require 1 < mem[_11945]
                            mem[_11945 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_11945] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _12019 = mem[_11945]
                                require mem[_11945] <= test266151307()
                                mem[_11945 + 96] = mem[_11945]
                                mem[64] = _11945 + (32 * mem[_11945]) + 128
                                if not _12019:
                                    require 0 < mem[_11945 + 96]
                                    mem[_11945 + 128] = u
                                    _14830 = mem[_11945]
                                    s = 0
                                    while s < _14830 - 1:
                                        require s < mem[_11945]
                                        _14858 = mem[(32 * s) + _11945 + 32]
                                        require s + 1 < mem[_11945]
                                        _14882 = mem[(32 * s + 1) + _11945 + 32]
                                        if mem[(32 * s) + _11945 + 44 len 20] == mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11945 + 44 len 20] < mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            if not mem[(32 * s) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14882)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14858) == address(_14858):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14882)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14882) == address(_14858):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11945 + 96]
                                    _14881 = mem[_11945 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14942 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14942] = _14881
                                    else:
                                        _15008 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15008] = _14881 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_11945 + 128 len 32 * _12019] = call.data[calldata.size len 32 * _12019]
                                    require 0 < mem[_11945 + 96]
                                    mem[_11945 + 128] = u
                                    _14831 = mem[_11945]
                                    s = 0
                                    while s < _14831 - 1:
                                        require s < mem[_11945]
                                        _14861 = mem[(32 * s) + _11945 + 32]
                                        require s + 1 < mem[_11945]
                                        _14884 = mem[(32 * s + 1) + _11945 + 32]
                                        if mem[(32 * s) + _11945 + 44 len 20] == mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11945 + 44 len 20] < mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            if not mem[(32 * s) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14884)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14861) == address(_14861):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14884)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14884) == address(_14861):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11945 + 96]
                                    _14883 = mem[_11945 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14949 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14949] = _14883
                                    else:
                                        _15012 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15012] = _14883 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _12032 = mem[_11945]
                                require mem[_11945] <= test266151307()
                                mem[_11945 + 96] = mem[_11945]
                                mem[64] = _11945 + (32 * mem[_11945]) + 128
                                if not _12032:
                                    require 0 < mem[_11945 + 96]
                                    mem[_11945 + 128] = uint16(t) * u / 10000
                                    _14832 = mem[_11945]
                                    s = 0
                                    while s < _14832 - 1:
                                        require s < mem[_11945]
                                        _14864 = mem[(32 * s) + _11945 + 32]
                                        require s + 1 < mem[_11945]
                                        _14886 = mem[(32 * s + 1) + _11945 + 32]
                                        if mem[(32 * s) + _11945 + 44 len 20] == mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11945 + 44 len 20] < mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            if not mem[(32 * s) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14886)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14864) == address(_14864):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14886)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14886) == address(_14864):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11945 + 96]
                                    _14885 = mem[_11945 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14956 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14956] = _14885
                                    else:
                                        _15016 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15016] = _14885 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_11945 + 128 len 32 * _12032] = call.data[calldata.size len 32 * _12032]
                                    require 0 < mem[_11945 + 96]
                                    mem[_11945 + 128] = uint16(t) * u / 10000
                                    _14833 = mem[_11945]
                                    s = 0
                                    while s < _14833 - 1:
                                        require s < mem[_11945]
                                        _14867 = mem[(32 * s) + _11945 + 32]
                                        require s + 1 < mem[_11945]
                                        _14888 = mem[(32 * s + 1) + _11945 + 32]
                                        if mem[(32 * s) + _11945 + 44 len 20] == mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11945 + 44 len 20] < mem[(32 * s + 1) + _11945 + 44 len 20]:
                                            if not mem[(32 * s) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14888)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14867) == address(_14867):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11945 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11945 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14888)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11945 + 96]
                                            if mem[(32 * s) + _11945 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14888) == address(_14867):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 995 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (995 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11945 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11945 + 96]
                                                        mem[(32 * s + 1) + _11945 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11945 + 128] / mem[(32 * s) + _11945 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11945 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 0 / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11945 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11945 + 128]
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / 997 * mem[(32 * s) + _11945 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11945 + 96]
                                                                mem[(32 * s + 1) + _11945 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11945 + 128] / (997 * mem[(32 * s) + _11945 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11945 + 96]
                                    _14887 = mem[_11945 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14963 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14963] = _14887
                                    else:
                                        _15020 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15020] = _14887 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _11936 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_11936]
                        mem[_11936 + 32] = address(s)
                        require 1 < mem[_11936]
                        mem[_11936 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_11936 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_11936 + 100] = u
                            mem[_11936 + 132] = 64
                            mem[_11936 + 164] = mem[_11936]
                            s = 0
                            while s < 32 * mem[_11936]:
                                mem[s + _11936 + 196] = mem[s + _11936 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_11936 + 164 len (32 * mem[_11936]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_11936 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _11936 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14901 = mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_11936 + mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_11936 + mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_11936 + ceil32(return_data.size) + 96] = mem[_11936 + mem[_11936 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _14930 = mem[_11936 + _14901 + 96]
                            s = 0
                            while s < 32 * _14930:
                                mem[s + _11936 + ceil32(return_data.size) + 128] = mem[s + _11936 + _14901 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14930) + _11936 + ceil32(return_data.size) + 128
                            require 1 < mem[_11936 + ceil32(return_data.size) + 96]
                            _17589 = mem[_11936 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17597 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17597] = _17589
                            else:
                                _17611 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17611] = _17589 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_11936 + 100] = uint16(t) * u / 10000
                            mem[_11936 + 132] = 64
                            mem[_11936 + 164] = mem[_11936]
                            s = 0
                            while s < 32 * mem[_11936]:
                                mem[s + _11936 + 196] = mem[s + _11936 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_11936 + 164 len (32 * mem[_11936]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_11936 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _11936 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14903 = mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_11936 + mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_11936 + mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_11936 + ceil32(return_data.size) + 96] = mem[_11936 + mem[_11936 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _14931 = mem[_11936 + _14903 + 96]
                            s = 0
                            while s < 32 * _14931:
                                mem[s + _11936 + ceil32(return_data.size) + 128] = mem[s + _11936 + _14903 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14931) + _11936 + ceil32(return_data.size) + 128
                            require 1 < mem[_11936 + ceil32(return_data.size) + 96]
                            _17590 = mem[_11936 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17600 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17600] = _17590
                            else:
                                _17615 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17615] = _17590 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            else:
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[mem[64]] = 0xfff6cae900000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                call address(cd[((160 * idx) + cd[68] + 36)]).sync() with:
                     gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require idx < ('cd', 68).length
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _11882 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_11882] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_11882 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_11882 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_11882 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_11882 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _12058 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _12079 = mem[_12058]
                    require mem[_12058 + 32] == bool(mem[_12058 + 32])
                    require idx < mem[96]
                    _12179 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_12058 + 32])
                    mem[_12179] = _12079
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if 7 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                mem[mem[64] + 36] = address(s)
                                mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 68)])
                                mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 36)])
                                require ext_code.size(0x9229151ce11bf180b630bda0fdc567304adb2801)
                                delegate 0x9229151ce11bf180b630bda0fdc567304adb2801.0xc4dc5ff7 with:
                                     gas gas_remaining wei
                                    args u, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)])
                                mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12093 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _12130 = mem[_12093]
                                require mem[_12093 + 32] == bool(mem[_12093 + 32])
                                require idx < mem[96]
                                _12246 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = bool(mem[_12093 + 32])
                                mem[_12246] = _12130
                            else:
                                if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 26:
                                        revert with 0, 'exchangeType not exist'
                                    require idx < mem[96]
                                    _12110 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = 0
                                    mem[_12110] = u
                                else:
                                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                                    require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                                    delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                         gas gas_remaining wei
                                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _12112 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    _12144 = mem[_12112]
                                    require mem[_12112 + 32] == bool(mem[_12112 + 32])
                                    require idx < mem[96]
                                    _12277 = mem[(32 * idx) + 128]
                                    require idx < mem[96]
                                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_12112 + 32])
                                    mem[_12277] = _12144
                        else:
                            _12055 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_12055]
                            mem[_12055 + 32] = address(s)
                            require 1 < mem[_12055]
                            mem[_12055 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_12055] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _12159 = mem[_12055]
                                require mem[_12055] <= test266151307()
                                mem[_12055 + 96] = mem[_12055]
                                mem[64] = _12055 + (32 * mem[_12055]) + 128
                                if not _12159:
                                    require 0 < mem[_12055 + 96]
                                    mem[_12055 + 128] = u
                                    _14834 = mem[_12055]
                                    s = 0
                                    while s < _14834 - 1:
                                        require s < mem[_12055]
                                        _14870 = mem[(32 * s) + _12055 + 32]
                                        require s + 1 < mem[_12055]
                                        _14892 = mem[(32 * s + 1) + _12055 + 32]
                                        if mem[(32 * s) + _12055 + 44 len 20] == mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _12055 + 44 len 20] < mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            if not mem[(32 * s) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14892)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14870) == address(_14870):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14892)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14892) == address(_14870):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_12055 + 96]
                                    _14891 = mem[_12055 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14974 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14974] = _14891
                                    else:
                                        _15026 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15026] = _14891 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_12055 + 128 len 32 * _12159] = call.data[calldata.size len 32 * _12159]
                                    require 0 < mem[_12055 + 96]
                                    mem[_12055 + 128] = u
                                    _14835 = mem[_12055]
                                    s = 0
                                    while s < _14835 - 1:
                                        require s < mem[_12055]
                                        _14873 = mem[(32 * s) + _12055 + 32]
                                        require s + 1 < mem[_12055]
                                        _14894 = mem[(32 * s + 1) + _12055 + 32]
                                        if mem[(32 * s) + _12055 + 44 len 20] == mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _12055 + 44 len 20] < mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            if not mem[(32 * s) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14894)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14873) == address(_14873):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14894)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14894) == address(_14873):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_12055 + 96]
                                    _14893 = mem[_12055 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14981 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14981] = _14893
                                    else:
                                        _15030 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15030] = _14893 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _12175 = mem[_12055]
                                require mem[_12055] <= test266151307()
                                mem[_12055 + 96] = mem[_12055]
                                mem[64] = _12055 + (32 * mem[_12055]) + 128
                                if not _12175:
                                    require 0 < mem[_12055 + 96]
                                    mem[_12055 + 128] = uint16(t) * u / 10000
                                    _14836 = mem[_12055]
                                    s = 0
                                    while s < _14836 - 1:
                                        require s < mem[_12055]
                                        _14876 = mem[(32 * s) + _12055 + 32]
                                        require s + 1 < mem[_12055]
                                        _14896 = mem[(32 * s + 1) + _12055 + 32]
                                        if mem[(32 * s) + _12055 + 44 len 20] == mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _12055 + 44 len 20] < mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            if not mem[(32 * s) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14896)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14876) == address(_14876):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14896)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14896) == address(_14876):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_12055 + 96]
                                    _14895 = mem[_12055 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14988 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14988] = _14895
                                    else:
                                        _15034 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15034] = _14895 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_12055 + 128 len 32 * _12175] = call.data[calldata.size len 32 * _12175]
                                    require 0 < mem[_12055 + 96]
                                    mem[_12055 + 128] = uint16(t) * u / 10000
                                    _14837 = mem[_12055]
                                    s = 0
                                    while s < _14837 - 1:
                                        require s < mem[_12055]
                                        _14879 = mem[(32 * s) + _12055 + 32]
                                        require s + 1 < mem[_12055]
                                        _14898 = mem[(32 * s + 1) + _12055 + 32]
                                        if mem[(32 * s) + _12055 + 44 len 20] == mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _12055 + 44 len 20] < mem[(32 * s + 1) + _12055 + 44 len 20]:
                                            if not mem[(32 * s) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14898)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14879) == address(_14879):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _12055 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _12055 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14898)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_12055 + 96]
                                            if mem[(32 * s) + _12055 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14898) == address(_14879):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 995 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (995 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _12055 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_12055 + 96]
                                                        mem[(32 * s + 1) + _12055 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _12055 + 128] / mem[(32 * s) + _12055 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _12055 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 0 / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _12055 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _12055 + 128]
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / 997 * mem[(32 * s) + _12055 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_12055 + 96]
                                                                mem[(32 * s + 1) + _12055 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _12055 + 128] / (997 * mem[(32 * s) + _12055 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_12055 + 96]
                                    _14897 = mem[_12055 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14995 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14995] = _14897
                                    else:
                                        _15038 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_15038] = _14897 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _12042 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_12042]
                        mem[_12042 + 32] = address(s)
                        require 1 < mem[_12042]
                        mem[_12042 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_12042 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_12042 + 100] = u
                            mem[_12042 + 132] = 64
                            mem[_12042 + 164] = mem[_12042]
                            s = 0
                            while s < 32 * mem[_12042]:
                                mem[s + _12042 + 196] = mem[s + _12042 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_12042 + 164 len (32 * mem[_12042]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_12042 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _12042 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14905 = mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_12042 + mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_12042 + mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_12042 + ceil32(return_data.size) + 96] = mem[_12042 + mem[_12042 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _14932 = mem[_12042 + _14905 + 96]
                            s = 0
                            while s < 32 * _14932:
                                mem[s + _12042 + ceil32(return_data.size) + 128] = mem[s + _12042 + _14905 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14932) + _12042 + ceil32(return_data.size) + 128
                            require 1 < mem[_12042 + ceil32(return_data.size) + 96]
                            _17591 = mem[_12042 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17603 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17603] = _17591
                            else:
                                _17619 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17619] = _17591 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_12042 + 100] = uint16(t) * u / 10000
                            mem[_12042 + 132] = 64
                            mem[_12042 + 164] = mem[_12042]
                            s = 0
                            while s < 32 * mem[_12042]:
                                mem[s + _12042 + 196] = mem[s + _12042 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_12042 + 164 len (32 * mem[_12042]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_12042 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _12042 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14907 = mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_12042 + mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_12042 + mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_12042 + ceil32(return_data.size) + 96] = mem[_12042 + mem[_12042 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _14933 = mem[_12042 + _14907 + 96]
                            s = 0
                            while s < 32 * _14933:
                                mem[s + _12042 + ceil32(return_data.size) + 128] = mem[s + _12042 + _14907 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14933) + _12042 + ceil32(return_data.size) + 128
                            require 1 < mem[_12042 + ceil32(return_data.size) + 96]
                            _17592 = mem[_12042 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17606 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17606] = _17592
                            else:
                                _17623 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17623] = _17592 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = cd[((160 * idx) + cd[68] + 164)]
            u = mem[mem[(32 * idx) + 128]]
            continue 
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = cd[4]
        while idx < ('cd', 68).length:
            require idx < mem[96]
            _14856 = mem[mem[(32 * idx) + 128]]
            require idx < ('cd', 68).length
            require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
            _14909 = mem[64]
            require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
            mem[64] = mem[64] + 160
            require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
            mem[_14909] = cd[((160 * idx) + cd[68] + 36)]
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            mem[_14909 + 32] = cd[((160 * idx) + cd[68] + 68)]
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            mem[_14909 + 64] = cd[((160 * idx) + cd[68] + 100)]
            require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
            mem[_14909 + 96] = cd[((160 * idx) + cd[68] + 132)]
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            mem[_14909 + 128] = cd[((160 * idx) + cd[68] + 164)]
            if not uint16(cd[((160 * idx) + cd[68] + 100)]):
                mem[mem[64]] = 0xa58d57400000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                mem[mem[64] + 36] = t
                mem[mem[64] + 68] = _14856
                mem[mem[64] + 100] = address(s)
                mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                mem[mem[64] + 196] = bool(cd[36])
                mem[mem[64] + 228] = uint16(cd[((160 * idx) + cd[68] + 132)])
                require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0xa58d574 with:
                     gas gas_remaining wei
                    args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _14856, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36]), uint16(cd[((160 * idx) + cd[68] + 132)])
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                if 3 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                    mem[mem[64] + 36] = t
                    mem[mem[64] + 68] = address(s)
                    mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 164] = bool(cd[36])
                    require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                    delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                         gas gas_remaining wei
                        args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    if 6 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                        mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                        mem[mem[64] + 36] = t
                        mem[mem[64] + 68] = address(s)
                        mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                        mem[mem[64] + 164] = bool(cd[36])
                        require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                        delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                             gas gas_remaining wei
                            args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if 7 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                            mem[mem[64]] = 0x589b898d00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = t
                            mem[mem[64] + 36] = _14856
                            mem[mem[64] + 68] = address(s)
                            mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                            require ext_code.size(0x9229151ce11bf180b630bda0fdc567304adb2801)
                            delegate 0x9229151ce11bf180b630bda0fdc567304adb2801.0x589b898d with:
                                 gas gas_remaining wei
                                args t, _14856, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)])
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if 26 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                mem[mem[64]] = 0xd9fd7500000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = t
                                mem[mem[64] + 36] = address(s)
                                mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 68)])
                                mem[mem[64] + 100] = bool(cd[36])
                                require ext_code.size(0xf909b8931aff96c81f6c1380b6814960145b03fc)
                                delegate 0xf909b8931aff96c81f6c1380b6814960145b03fc.0xd9fd75 with:
                                     gas gas_remaining wei
                                    args t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), bool(cd[36])
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                if 32 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                                    mem[mem[64]] = 0x35d92d6900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                                    mem[mem[64] + 36] = t
                                    mem[mem[64] + 68] = _14856
                                    mem[mem[64] + 100] = address(s)
                                    mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                                    mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                                    mem[mem[64] + 196] = bool(cd[36])
                                    require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                                    delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0x35d92d69 with:
                                         gas gas_remaining wei
                                        args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _14856, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = mem[mem[(32 * idx) + 128]]
            continue 
}



}

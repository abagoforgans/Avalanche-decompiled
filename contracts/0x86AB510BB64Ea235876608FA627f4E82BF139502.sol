contract main {




// =====================  Runtime code  =====================


#
#  - sub_1cf65186(?)
#
const DEFAULT_ADMIN_ROLE = 0


mapping of struct roleAdmin;
mapping of uint256 sub_26e4baae;
uint256 sub_8cf086ad;

function getRoleAdmin(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return roleAdmin[arg1].field_256
}

function sub_26e4baae(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_26e4baae[arg1]
}

function sub_8cf086ad(?) {
    return sub_8cf086ad
}

function hasRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return bool(roleAdmin[arg1][address(arg2)].field_0)
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function renounceRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg2 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
    if roleAdmin[arg1][address(arg2)].field_0:
        roleAdmin[arg1][address(arg2)].field_0 = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
}

function revokeRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0:
        if roleAdmin[arg1][address(arg2)].field_0:
            roleAdmin[arg1][address(arg2)].field_0 = 0
            emit RoleRevoked(arg1, arg2, msg.sender);
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    s = roleAdmin[arg1].field_256
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if roleAdmin[arg1].field_256 + 16384:
        revert with 0, 'Strings: hex length insufficient'
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], ' is missing role ', mem[288 len 66], 0, 0 >> 928, 0
}

function grantRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0:
        if not roleAdmin[arg1][address(arg2)].field_0:
            roleAdmin[arg1][address(arg2)].field_0 = 1
            emit RoleGranted(arg1, arg2, msg.sender);
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    s = roleAdmin[arg1].field_256
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if roleAdmin[arg1].field_256 + 16384:
        revert with 0, 'Strings: hex length insufficient'
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], ' is missing role ', mem[288 len 66], 0, 0 >> 928, 0
}

function withdrawToken(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not roleAdmin[address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], ' is missing role ', mem[288 len 66], 0, 0 >> 928, 0
    if not arg1:
        call msg.sender with:
           value arg2 wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(arg1)
        call arg1.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_29b42ddf(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    if roleAdmin[address(msg.sender)].field_0:
        idx = 0
        while idx < ('cd', 4).length:
            require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
            if 1 == sub_26e4baae[address(cd[((32 * idx) + cd[4] + 36)])]:
                if sub_8cf086ad < 1:
                    revert with 0, 17
                sub_8cf086ad--
            if idx >= ('cd', 4).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
            mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
            mem[32] = 1
            sub_26e4baae[address(cd[((32 * idx) + cd[4] + 36)])] = 0
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], ' is missing role ', mem[288 len 66], 0, 0 >> 928, 0
}

function _fallback() payable {
    mem[64] = 128
    if calldata.size < 4:
        require not calldata.size
    if unknown_0x36568abe(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0x9e281a98(?????) > uint32(call.func_hash) >> 224:
            if uint32(call.func_hash) >> 224 != unknown_0x36568abe(?????):
                if unknown_0x8cf086ad(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_8cf086ad
                require unknown_0x91d14854(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[36] == address(cd[36])
                return bool(roleAdmin[cd[4]][address(cd[36])].field_0)
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[36] == address(cd[36])
            if address(cd[36]) != msg.sender:
                revert with 0, 'AccessControl: can only renounce roles for self'
            if roleAdmin[cd[4]][address(cd[36])].field_0:
                roleAdmin[cd[4]][address(cd[36])].field_0 = 0
                emit RoleRevoked(cd[4], address(cd[36]), msg.sender);
        if unknown_0x9e281a98(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if not roleAdmin[address(msg.sender)].field_0:
                mem[160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[256 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 32, 148, 'AccessControl: account ', mem[192 len 42], ' is missing role ', mem[320 len 66], 0, 0 >> 928, 0
            if not address(cd[4]):
                call msg.sender with:
                   value cd[36] wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                require ext_code.size(address(cd[4]))
                call address(cd[4]).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, cd[36]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if unknown_0xa217fddf(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return 0
        require unknown_0xd547741f(?????) == uint32(call.func_hash) >> 224
        require not msg.value
        require calldata.size - 4 >= 64
        require cd[36] == address(cd[36])
        if roleAdmin[roleAdmin[cd[4]].field_256][address(msg.sender)].field_0:
            if roleAdmin[cd[4]][address(cd[36])].field_0:
                roleAdmin[cd[4]][address(cd[36])].field_0 = 0
                emit RoleRevoked(cd[4], address(cd[36]), msg.sender);
        mem[160 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[256 len 66] = call.data[calldata.size len 66]
        idx = 65
        s = roleAdmin[cd[4]].field_256
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if roleAdmin[cd[4]].field_256 + 16384:
            revert with 0, 'Strings: hex length insufficient'
    else:
        if unknown_0x26e4baae(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0x26e4baae(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                return sub_26e4baae[cd[4]]
            if uint32(call.func_hash) >> 224 != unknown_0x29b42ddf(?????):
                require unknown_0x2f2ff15d(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[36] == address(cd[36])
                if roleAdmin[roleAdmin[cd[4]].field_256][address(msg.sender)].field_0:
                    if not roleAdmin[cd[4]][address(cd[36])].field_0:
                        roleAdmin[cd[4]][address(cd[36])].field_0 = 1
                        emit RoleGranted(cd[4], address(cd[36]), msg.sender);
                mem[160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[256 len 66] = call.data[calldata.size len 66]
                idx = 65
                s = roleAdmin[cd[4]].field_256
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if roleAdmin[cd[4]].field_256 + 16384:
                    revert with 0, 'Strings: hex length insufficient'
            else:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] <= test266151307()
                require cd[4] + 35 < calldata.size
                require ('cd', 4).length <= test266151307()
                require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                if roleAdmin[address(msg.sender)].field_0:
                    idx = 0
                    while idx < ('cd', 4).length:
                        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                        if 1 == sub_26e4baae[address(cd[((32 * idx) + cd[4] + 36)])]:
                            if sub_8cf086ad < 1:
                                revert with 0, 17
                            sub_8cf086ad--
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                        mem[32] = 1
                        sub_26e4baae[address(cd[((32 * idx) + cd[4] + 36)])] = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                mem[160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[256 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
        else:
            if supportsInterface(bytes4 arg1) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == Mask(32, 224, cd[4])
                if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, cd[4]):
                    return True
                return (Mask(32, 224, cd[4]) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
            if uint32(call.func_hash) >> 224 != unknown_0x1cf65186(?????):
                require unknown_0x248a9ca3(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                return roleAdmin[cd[4]].field_256
            require not msg.value
            require calldata.size - 4 >= 256
            require cd[4] == address(cd[4])
            require cd[36] == address(cd[36])
            require cd[68] <= test266151307()
            require cd[68] + 35 < calldata.size
            require ('cd', 68).length <= test266151307()
            require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
            require test266151307() >= cd[100]
            require cd[100] + 35 < calldata.size
            require ('cd', 100).length <= test266151307()
            require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
            require test266151307() >= cd[132]
            require cd[132] + 35 < calldata.size
            require ('cd', 132).length <= test266151307()
            require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
            mem[0] = msg.sender
            mem[32] = sha3(0)
            if roleAdmin[address(msg.sender)].field_0:
                if ('cd', 100).length != ('cd', 68).length:
                    revert with 0, 'OTPL'
                if ('cd', 132).length != ('cd', 100).length:
                    revert with 0, 'FRL'
                idx = 0
                while idx < ('cd', 68).length:
                    require ext_code.size(address(cd[4]))
                    staticcall address(cd[4]).factory() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2764 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2770 = mem[_2764]
                    require mem[_2764] == mem[_2764 + 12 len 20]
                    if idx >= ('cd', 68).length:
                        revert with 0, 50
                    require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                    mem[mem[64] + 4] = address(cd[36])
                    mem[mem[64] + 36] = address(cd[((32 * idx) + cd[68] + 36)])
                    require ext_code.size(address(_2770))
                    staticcall address(_2770).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args address(cd[36]), address(cd[((32 * idx) + cd[68] + 36)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2790 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2791 = mem[_2790]
                    require mem[_2790] == mem[_2790 + 12 len 20]
                    if mem[_2790 + 12 len 20]:
                        if idx >= ('cd', 68).length:
                            revert with 0, 50
                        require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                        mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                        mem[32] = 1
                        if not sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])]:
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                            if idx >= ('cd', 100).length:
                                revert with 0, 50
                            require ext_code.size(address(_2791))
                            staticcall address(_2791).getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2801 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _2802 = mem[_2801]
                            require mem[_2801] == mem[_2801 + 18 len 14]
                            _2803 = mem[_2801 + 32]
                            require mem[_2801 + 32] == mem[_2801 + 50 len 14]
                            require mem[_2801 + 64] == mem[_2801 + 92 len 4]
                            require ext_code.size(address(_2791))
                            staticcall address(_2791).token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2807 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2807] == mem[_2807 + 12 len 20]
                            require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if address(cd[((32 * idx) + cd[68] + 36)]) == mem[_2807 + 12 len 20]:
                                _2813 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2813] == mem[_2813 + 31 len 1]
                                if not mem[_2813 + 31 len 1]:
                                    if Mask(112, 0, _2802) and cd[((32 * idx) + cd[100] + 36)] > -1 / Mask(112, 0, _2802):
                                        revert with 0, 17
                                    if cd[196] <= Mask(112, 0, _2802) * cd[((32 * idx) + cd[100] + 36)]:
                                        if idx >= ('cd', 68).length:
                                            revert with 0, 50
                                        require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                        if idx >= ('cd', 100).length:
                                            revert with 0, 50
                                        if idx >= ('cd', 132).length:
                                            revert with 0, 50
                                        if cd[164] and cd[((32 * idx) + cd[132] + 36)] > -1 / cd[164]:
                                            revert with 0, 17
                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _2821 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _2823 = mem[_2821]
                                        require mem[_2821] == mem[_2821 + 31 len 1]
                                        if not mem[_2821 + 31 len 1]:
                                            if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 1 > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                revert with 0, 17
                                            if not cd[((32 * idx) + cd[100] + 36)]:
                                                revert with 0, 18
                                            if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]:
                                                _2845 = mem[64]
                                                mem[mem[64] + 36] = address(cd[4])
                                                mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                _2846 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_2846 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2846 + 36 len 28]
                                                mem[64] = _2845 + 164
                                                mem[_2845 + 100] = 32
                                                mem[_2845 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _2881 = mem[_2846]
                                                s = 0
                                                while s < _2881:
                                                    mem[s + _2845 + 164] = mem[s + _2846 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_2881) <= _2881:
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2845 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2845 + 168 len _2881 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2845 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2845 + 232] = mem[idx + _2845 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2845 + 232]
                                                        if not mem[96]:
                                                            mem[_2845 + 164] = 2
                                                            mem[64] = _2845 + 260
                                                            mem[_2845 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + 228] = address(cd[36])
                                                            mem[_2845 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + 296] = 0
                                                            mem[_2845 + 328] = 160
                                                            mem[_2845 + 424] = 2
                                                            s = 0
                                                            t = _2845 + 456
                                                            u = _2845 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + 360] = this.address
                                                            mem[_2845 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2845 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15490 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15744 = mem[_15490]
                                                            require mem[_15490] <= test266151307()
                                                            require _15490 + mem[_15490] + 31 < _15490 + return_data.size
                                                            _15914 = mem[_15490 + mem[_15490]]
                                                            if mem[_15490 + mem[_15490]] > test266151307():
                                                                revert with 0, 65
                                                            if _15490 + ceil32(return_data.size) + ceil32(32 * mem[_15490 + mem[_15490]]) + 1 > test266151307() or ceil32(32 * mem[_15490 + mem[_15490]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15490 + ceil32(return_data.size) + ceil32(32 * mem[_15490 + mem[_15490]]) + 1
                                                            mem[_15490 + ceil32(return_data.size)] = _15914
                                                            require return_data.size >= _15744 + (32 * _15914) + 32
                                                            t = _15490 + _15744 + 32
                                                            u = _15490 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15914:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2845 + 164] = 2
                                                            mem[64] = _2845 + 260
                                                            mem[_2845 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + 228] = address(cd[36])
                                                            mem[_2845 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + 296] = 0
                                                            mem[_2845 + 328] = 160
                                                            mem[_2845 + 424] = 2
                                                            s = 0
                                                            t = _2845 + 456
                                                            u = _2845 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + 360] = this.address
                                                            mem[_2845 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2845 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15491 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15745 = mem[_15491]
                                                            require mem[_15491] <= test266151307()
                                                            require _15491 + mem[_15491] + 31 < _15491 + return_data.size
                                                            _15915 = mem[_15491 + mem[_15491]]
                                                            if mem[_15491 + mem[_15491]] > test266151307():
                                                                revert with 0, 65
                                                            if _15491 + ceil32(return_data.size) + ceil32(32 * mem[_15491 + mem[_15491]]) + 1 > test266151307() or ceil32(32 * mem[_15491 + mem[_15491]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15491 + ceil32(return_data.size) + ceil32(32 * mem[_15491 + mem[_15491]]) + 1
                                                            mem[_15491 + ceil32(return_data.size)] = _15915
                                                            require return_data.size >= _15745 + (32 * _15915) + 32
                                                            t = _15491 + _15745 + 32
                                                            u = _15491 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15915:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2845 + 164] = return_data.size
                                                        mem[_2845 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2845 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2845 + ceil32(return_data.size) + 233] = mem[idx + _2845 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2845 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2845 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2845 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2845 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2845 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2845 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2845 + ceil32(return_data.size) + 457
                                                            u = _2845 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2845 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2845 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2845 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15746 = mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2845 + ceil32(return_data.size) + return_data.size + 261
                                                            _15916 = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15746 + (32 * _15916) + 32
                                                            t = _2845 + ceil32(return_data.size) + _15746 + 293
                                                            u = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15916:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2845 + 196] == bool(mem[_2845 + 196])
                                                            if not mem[_2845 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2845 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2845 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2845 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2845 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2845 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2845 + ceil32(return_data.size) + 457
                                                            u = _2845 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2845 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2845 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2845 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15747 = mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2845 + ceil32(return_data.size) + return_data.size + 261
                                                            _15917 = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15747 + (32 * _15917) + 32
                                                            t = _2845 + ceil32(return_data.size) + _15747 + 293
                                                            u = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15917:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[_2881 + _2845 + 164] = 0
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2845 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2845 + 168 len _2881 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2845 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2845 + 232] = mem[idx + _2845 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2845 + 232]
                                                        if not mem[96]:
                                                            mem[_2845 + 164] = 2
                                                            mem[64] = _2845 + 260
                                                            mem[_2845 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + 228] = address(cd[36])
                                                            mem[_2845 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + 296] = 0
                                                            mem[_2845 + 328] = 160
                                                            mem[_2845 + 424] = 2
                                                            s = 0
                                                            t = _2845 + 456
                                                            u = _2845 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + 360] = this.address
                                                            mem[_2845 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2845 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15498 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15748 = mem[_15498]
                                                            require mem[_15498] <= test266151307()
                                                            require _15498 + mem[_15498] + 31 < _15498 + return_data.size
                                                            _15918 = mem[_15498 + mem[_15498]]
                                                            if mem[_15498 + mem[_15498]] > test266151307():
                                                                revert with 0, 65
                                                            if _15498 + ceil32(return_data.size) + ceil32(32 * mem[_15498 + mem[_15498]]) + 1 > test266151307() or ceil32(32 * mem[_15498 + mem[_15498]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15498 + ceil32(return_data.size) + ceil32(32 * mem[_15498 + mem[_15498]]) + 1
                                                            mem[_15498 + ceil32(return_data.size)] = _15918
                                                            require return_data.size >= _15748 + (32 * _15918) + 32
                                                            t = _15498 + _15748 + 32
                                                            u = _15498 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15918:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2845 + 164] = 2
                                                            mem[64] = _2845 + 260
                                                            mem[_2845 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + 228] = address(cd[36])
                                                            mem[_2845 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + 296] = 0
                                                            mem[_2845 + 328] = 160
                                                            mem[_2845 + 424] = 2
                                                            s = 0
                                                            t = _2845 + 456
                                                            u = _2845 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + 360] = this.address
                                                            mem[_2845 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2845 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15499 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15749 = mem[_15499]
                                                            require mem[_15499] <= test266151307()
                                                            require _15499 + mem[_15499] + 31 < _15499 + return_data.size
                                                            _15919 = mem[_15499 + mem[_15499]]
                                                            if mem[_15499 + mem[_15499]] > test266151307():
                                                                revert with 0, 65
                                                            if _15499 + ceil32(return_data.size) + ceil32(32 * mem[_15499 + mem[_15499]]) + 1 > test266151307() or ceil32(32 * mem[_15499 + mem[_15499]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15499 + ceil32(return_data.size) + ceil32(32 * mem[_15499 + mem[_15499]]) + 1
                                                            mem[_15499 + ceil32(return_data.size)] = _15919
                                                            require return_data.size >= _15749 + (32 * _15919) + 32
                                                            t = _15499 + _15749 + 32
                                                            u = _15499 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15919:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2845 + 164] = return_data.size
                                                        mem[_2845 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2845 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2845 + ceil32(return_data.size) + 233] = mem[idx + _2845 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2845 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2845 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2845 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2845 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2845 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2845 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2845 + ceil32(return_data.size) + 457
                                                            u = _2845 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2845 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2845 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2845 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15750 = mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2845 + ceil32(return_data.size) + return_data.size + 261
                                                            _15920 = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15750 + (32 * _15920) + 32
                                                            t = _2845 + ceil32(return_data.size) + _15750 + 293
                                                            u = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15920:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2845 + 196] == bool(mem[_2845 + 196])
                                                            if not mem[_2845 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2845 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2845 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2845 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2845 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2845 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2845 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2845 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2845 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2845 + ceil32(return_data.size) + 457
                                                            u = _2845 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2845 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2845 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2845 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2845 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15751 = mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2845 + ceil32(return_data.size) + return_data.size + 261
                                                            _15921 = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2845 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2845 + ceil32(return_data.size) + mem[_2845 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15751 + (32 * _15921) + 32
                                                            t = _2845 + ceil32(return_data.size) + _15751 + 293
                                                            u = _2845 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15921:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                            else:
                                                mem[mem[64] + 4] = this.address
                                                mem[mem[64] + 36] = address(cd[4])
                                                require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                        gas gas_remaining wei
                                                       args this.address, address(cd[4])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2853 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if mem[_2853]:
                                                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                _2895 = mem[64]
                                                mem[mem[64] + 36] = address(cd[4])
                                                mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                _2896 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_2896 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2896 + 36 len 28]
                                                mem[64] = _2895 + 164
                                                mem[_2895 + 100] = 32
                                                mem[_2895 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _3000 = mem[_2896]
                                                s = 0
                                                while s < _3000:
                                                    mem[s + _2895 + 164] = mem[s + _2896 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_3000) <= _3000:
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2895 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2895 + 168 len _3000 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2895 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2895 + 232] = mem[idx + _2895 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2895 + 232]
                                                        if not mem[96]:
                                                            mem[_2895 + 164] = 2
                                                            mem[64] = _2895 + 260
                                                            mem[_2895 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + 228] = address(cd[36])
                                                            mem[_2895 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + 296] = 0
                                                            mem[_2895 + 328] = 160
                                                            mem[_2895 + 424] = 2
                                                            s = 0
                                                            t = _2895 + 456
                                                            u = _2895 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + 360] = this.address
                                                            mem[_2895 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2895 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15506 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15752 = mem[_15506]
                                                            require mem[_15506] <= test266151307()
                                                            require _15506 + mem[_15506] + 31 < _15506 + return_data.size
                                                            _15922 = mem[_15506 + mem[_15506]]
                                                            if mem[_15506 + mem[_15506]] > test266151307():
                                                                revert with 0, 65
                                                            if _15506 + ceil32(return_data.size) + ceil32(32 * mem[_15506 + mem[_15506]]) + 1 > test266151307() or ceil32(32 * mem[_15506 + mem[_15506]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15506 + ceil32(return_data.size) + ceil32(32 * mem[_15506 + mem[_15506]]) + 1
                                                            mem[_15506 + ceil32(return_data.size)] = _15922
                                                            require return_data.size >= _15752 + (32 * _15922) + 32
                                                            t = _15506 + _15752 + 32
                                                            u = _15506 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15922:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2895 + 164] = 2
                                                            mem[64] = _2895 + 260
                                                            mem[_2895 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + 228] = address(cd[36])
                                                            mem[_2895 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + 296] = 0
                                                            mem[_2895 + 328] = 160
                                                            mem[_2895 + 424] = 2
                                                            s = 0
                                                            t = _2895 + 456
                                                            u = _2895 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + 360] = this.address
                                                            mem[_2895 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2895 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15507 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15753 = mem[_15507]
                                                            require mem[_15507] <= test266151307()
                                                            require _15507 + mem[_15507] + 31 < _15507 + return_data.size
                                                            _15923 = mem[_15507 + mem[_15507]]
                                                            if mem[_15507 + mem[_15507]] > test266151307():
                                                                revert with 0, 65
                                                            if _15507 + ceil32(return_data.size) + ceil32(32 * mem[_15507 + mem[_15507]]) + 1 > test266151307() or ceil32(32 * mem[_15507 + mem[_15507]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15507 + ceil32(return_data.size) + ceil32(32 * mem[_15507 + mem[_15507]]) + 1
                                                            mem[_15507 + ceil32(return_data.size)] = _15923
                                                            require return_data.size >= _15753 + (32 * _15923) + 32
                                                            t = _15507 + _15753 + 32
                                                            u = _15507 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15923:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2895 + 164] = return_data.size
                                                        mem[_2895 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2895 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2895 + ceil32(return_data.size) + 233] = mem[idx + _2895 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2895 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2895 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2895 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2895 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2895 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2895 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2895 + ceil32(return_data.size) + 457
                                                            u = _2895 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2895 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2895 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2895 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15754 = mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2895 + ceil32(return_data.size) + return_data.size + 261
                                                            _15924 = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15754 + (32 * _15924) + 32
                                                            t = _2895 + ceil32(return_data.size) + _15754 + 293
                                                            u = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15924:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2895 + 196] == bool(mem[_2895 + 196])
                                                            if not mem[_2895 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2895 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2895 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2895 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2895 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2895 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2895 + ceil32(return_data.size) + 457
                                                            u = _2895 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2895 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2895 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2895 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15755 = mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2895 + ceil32(return_data.size) + return_data.size + 261
                                                            _15925 = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15755 + (32 * _15925) + 32
                                                            t = _2895 + ceil32(return_data.size) + _15755 + 293
                                                            u = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15925:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[_3000 + _2895 + 164] = 0
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2895 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2895 + 168 len _3000 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2895 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2895 + 232] = mem[idx + _2895 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2895 + 232]
                                                        if not mem[96]:
                                                            mem[_2895 + 164] = 2
                                                            mem[64] = _2895 + 260
                                                            mem[_2895 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + 228] = address(cd[36])
                                                            mem[_2895 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + 296] = 0
                                                            mem[_2895 + 328] = 160
                                                            mem[_2895 + 424] = 2
                                                            s = 0
                                                            t = _2895 + 456
                                                            u = _2895 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + 360] = this.address
                                                            mem[_2895 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2895 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15514 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15756 = mem[_15514]
                                                            require mem[_15514] <= test266151307()
                                                            require _15514 + mem[_15514] + 31 < _15514 + return_data.size
                                                            _15926 = mem[_15514 + mem[_15514]]
                                                            if mem[_15514 + mem[_15514]] > test266151307():
                                                                revert with 0, 65
                                                            if _15514 + ceil32(return_data.size) + ceil32(32 * mem[_15514 + mem[_15514]]) + 1 > test266151307() or ceil32(32 * mem[_15514 + mem[_15514]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15514 + ceil32(return_data.size) + ceil32(32 * mem[_15514 + mem[_15514]]) + 1
                                                            mem[_15514 + ceil32(return_data.size)] = _15926
                                                            require return_data.size >= _15756 + (32 * _15926) + 32
                                                            t = _15514 + _15756 + 32
                                                            u = _15514 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15926:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2895 + 164] = 2
                                                            mem[64] = _2895 + 260
                                                            mem[_2895 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + 228] = address(cd[36])
                                                            mem[_2895 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + 296] = 0
                                                            mem[_2895 + 328] = 160
                                                            mem[_2895 + 424] = 2
                                                            s = 0
                                                            t = _2895 + 456
                                                            u = _2895 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + 360] = this.address
                                                            mem[_2895 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2895 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15515 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15757 = mem[_15515]
                                                            require mem[_15515] <= test266151307()
                                                            require _15515 + mem[_15515] + 31 < _15515 + return_data.size
                                                            _15927 = mem[_15515 + mem[_15515]]
                                                            if mem[_15515 + mem[_15515]] > test266151307():
                                                                revert with 0, 65
                                                            if _15515 + ceil32(return_data.size) + ceil32(32 * mem[_15515 + mem[_15515]]) + 1 > test266151307() or ceil32(32 * mem[_15515 + mem[_15515]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15515 + ceil32(return_data.size) + ceil32(32 * mem[_15515 + mem[_15515]]) + 1
                                                            mem[_15515 + ceil32(return_data.size)] = _15927
                                                            require return_data.size >= _15757 + (32 * _15927) + 32
                                                            t = _15515 + _15757 + 32
                                                            u = _15515 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _15927:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2895 + 164] = return_data.size
                                                        mem[_2895 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2895 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2895 + ceil32(return_data.size) + 233] = mem[idx + _2895 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2895 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2895 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2895 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2895 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2895 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2895 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2895 + ceil32(return_data.size) + 457
                                                            u = _2895 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2895 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2895 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2895 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15758 = mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2895 + ceil32(return_data.size) + return_data.size + 261
                                                            _15928 = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15758 + (32 * _15928) + 32
                                                            t = _2895 + ceil32(return_data.size) + _15758 + 293
                                                            u = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15928:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2895 + 196] == bool(mem[_2895 + 196])
                                                            if not mem[_2895 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2895 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2895 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2895 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2895 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2895 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2895 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2895 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2895 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2895 + ceil32(return_data.size) + 457
                                                            u = _2895 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2895 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2895 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2895 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2895 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15759 = mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2895 + ceil32(return_data.size) + return_data.size + 261
                                                            _15929 = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2895 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2895 + ceil32(return_data.size) + mem[_2895 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15759 + (32 * _15929) + 32
                                                            t = _2895 + ceil32(return_data.size) + _15759 + 293
                                                            u = _2895 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _15929:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(bool(mem[_2821 + 31 len 1] < 78)) or bool(bool(mem[_2821 + 31 len 1] < 32)):
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 10^mem[_2821 + 31 len 1] > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^mem[_2821 + 31 len 1] / cd[((32 * idx) + cd[100] + 36)]:
                                                    _2877 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                    _2878 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_2878 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2878 + 36 len 28]
                                                    mem[64] = _2877 + 164
                                                    mem[_2877 + 100] = 32
                                                    mem[_2877 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _2969 = mem[_2878]
                                                    s = 0
                                                    while s < _2969:
                                                        mem[s + _2877 + 164] = mem[s + _2878 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_2969) <= _2969:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2877 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2877 + 168 len _2969 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2877 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2877 + 232] = mem[idx + _2877 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2877 + 232]
                                                            if not mem[96]:
                                                                mem[_2877 + 164] = 2
                                                                mem[64] = _2877 + 260
                                                                mem[_2877 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + 228] = address(cd[36])
                                                                mem[_2877 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + 296] = 0
                                                                mem[_2877 + 328] = 160
                                                                mem[_2877 + 424] = 2
                                                                s = 0
                                                                t = _2877 + 456
                                                                u = _2877 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + 360] = this.address
                                                                mem[_2877 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2877 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15458 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15728 = mem[_15458]
                                                                require mem[_15458] <= test266151307()
                                                                require _15458 + mem[_15458] + 31 < _15458 + return_data.size
                                                                _15898 = mem[_15458 + mem[_15458]]
                                                                if mem[_15458 + mem[_15458]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15458 + ceil32(return_data.size) + ceil32(32 * mem[_15458 + mem[_15458]]) + 1 > test266151307() or ceil32(32 * mem[_15458 + mem[_15458]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15458 + ceil32(return_data.size) + ceil32(32 * mem[_15458 + mem[_15458]]) + 1
                                                                mem[_15458 + ceil32(return_data.size)] = _15898
                                                                require return_data.size >= _15728 + (32 * _15898) + 32
                                                                t = _15458 + _15728 + 32
                                                                u = _15458 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15898:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2877 + 164] = 2
                                                                mem[64] = _2877 + 260
                                                                mem[_2877 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + 228] = address(cd[36])
                                                                mem[_2877 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + 296] = 0
                                                                mem[_2877 + 328] = 160
                                                                mem[_2877 + 424] = 2
                                                                s = 0
                                                                t = _2877 + 456
                                                                u = _2877 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + 360] = this.address
                                                                mem[_2877 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2877 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15459 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15729 = mem[_15459]
                                                                require mem[_15459] <= test266151307()
                                                                require _15459 + mem[_15459] + 31 < _15459 + return_data.size
                                                                _15899 = mem[_15459 + mem[_15459]]
                                                                if mem[_15459 + mem[_15459]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15459 + ceil32(return_data.size) + ceil32(32 * mem[_15459 + mem[_15459]]) + 1 > test266151307() or ceil32(32 * mem[_15459 + mem[_15459]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15459 + ceil32(return_data.size) + ceil32(32 * mem[_15459 + mem[_15459]]) + 1
                                                                mem[_15459 + ceil32(return_data.size)] = _15899
                                                                require return_data.size >= _15729 + (32 * _15899) + 32
                                                                t = _15459 + _15729 + 32
                                                                u = _15459 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15899:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2877 + 164] = return_data.size
                                                            mem[_2877 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2877 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2877 + ceil32(return_data.size) + 233] = mem[idx + _2877 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2877 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2877 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2877 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2877 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2877 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2877 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2877 + ceil32(return_data.size) + 457
                                                                u = _2877 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2877 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2877 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2877 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15730 = mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2877 + ceil32(return_data.size) + return_data.size + 261
                                                                _15900 = mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15900
                                                                require return_data.size >= _15730 + (32 * _15900) + 32
                                                                t = _2877 + ceil32(return_data.size) + _15730 + 293
                                                                u = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15900:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2877 + 196] == bool(mem[_2877 + 196])
                                                                if not mem[_2877 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2877 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2877 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2877 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2877 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2877 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2877 + ceil32(return_data.size) + 457
                                                                u = _2877 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2877 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2877 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2877 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15731 = mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2877 + ceil32(return_data.size) + return_data.size + 261
                                                                _15901 = mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15901
                                                                require return_data.size >= _15731 + (32 * _15901) + 32
                                                                t = _2877 + ceil32(return_data.size) + _15731 + 293
                                                                u = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15901:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_2969 + _2877 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2877 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2877 + 168 len _2969 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2877 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2877 + 232] = mem[idx + _2877 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2877 + 232]
                                                            if not mem[96]:
                                                                mem[_2877 + 164] = 2
                                                                mem[64] = _2877 + 260
                                                                mem[_2877 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + 228] = address(cd[36])
                                                                mem[_2877 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + 296] = 0
                                                                mem[_2877 + 328] = 160
                                                                mem[_2877 + 424] = 2
                                                                s = 0
                                                                t = _2877 + 456
                                                                u = _2877 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + 360] = this.address
                                                                mem[_2877 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2877 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15466 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15732 = mem[_15466]
                                                                require mem[_15466] <= test266151307()
                                                                require _15466 + mem[_15466] + 31 < _15466 + return_data.size
                                                                _15902 = mem[_15466 + mem[_15466]]
                                                                if mem[_15466 + mem[_15466]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15466 + ceil32(return_data.size) + ceil32(32 * mem[_15466 + mem[_15466]]) + 1 > test266151307() or ceil32(32 * mem[_15466 + mem[_15466]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15466 + ceil32(return_data.size) + ceil32(32 * mem[_15466 + mem[_15466]]) + 1
                                                                mem[_15466 + ceil32(return_data.size)] = _15902
                                                                require return_data.size >= _15732 + (32 * _15902) + 32
                                                                t = _15466 + _15732 + 32
                                                                u = _15466 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15902:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2877 + 164] = 2
                                                                mem[64] = _2877 + 260
                                                                mem[_2877 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + 228] = address(cd[36])
                                                                mem[_2877 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + 296] = 0
                                                                mem[_2877 + 328] = 160
                                                                mem[_2877 + 424] = 2
                                                                s = 0
                                                                t = _2877 + 456
                                                                u = _2877 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + 360] = this.address
                                                                mem[_2877 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2877 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15467 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15733 = mem[_15467]
                                                                require mem[_15467] <= test266151307()
                                                                require _15467 + mem[_15467] + 31 < _15467 + return_data.size
                                                                _15903 = mem[_15467 + mem[_15467]]
                                                                if mem[_15467 + mem[_15467]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15467 + ceil32(return_data.size) + ceil32(32 * mem[_15467 + mem[_15467]]) + 1 > test266151307() or ceil32(32 * mem[_15467 + mem[_15467]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15467 + ceil32(return_data.size) + ceil32(32 * mem[_15467 + mem[_15467]]) + 1
                                                                mem[_15467 + ceil32(return_data.size)] = _15903
                                                                require return_data.size >= _15733 + (32 * _15903) + 32
                                                                t = _15467 + _15733 + 32
                                                                u = _15467 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15903:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2877 + 164] = return_data.size
                                                            mem[_2877 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2877 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2877 + ceil32(return_data.size) + 233] = mem[idx + _2877 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2877 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2877 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2877 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2877 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2877 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2877 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2877 + ceil32(return_data.size) + 457
                                                                u = _2877 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2877 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2877 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2877 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15734 = mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2877 + ceil32(return_data.size) + return_data.size + 261
                                                                _15904 = mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15904
                                                                require return_data.size >= _15734 + (32 * _15904) + 32
                                                                t = _2877 + ceil32(return_data.size) + _15734 + 293
                                                                u = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15904:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2877 + 196] == bool(mem[_2877 + 196])
                                                                if not mem[_2877 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2877 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2877 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2877 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2877 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2877 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2877 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2877 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2877 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2877 + ceil32(return_data.size) + 457
                                                                u = _2877 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2877 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2877 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2877 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2877 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15735 = mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2877 + ceil32(return_data.size) + return_data.size + 261
                                                                _15905 = mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2877 + ceil32(return_data.size) + mem[_2877 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2877 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15905
                                                                require return_data.size >= _15735 + (32 * _15905) + 32
                                                                t = _2877 + ceil32(return_data.size) + _15735 + 293
                                                                u = _2877 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15905:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _2894 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_2894]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _2993 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                    _2994 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_2994 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2994 + 36 len 28]
                                                    mem[64] = _2993 + 164
                                                    mem[_2993 + 100] = 32
                                                    mem[_2993 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _3158 = mem[_2994]
                                                    s = 0
                                                    while s < _3158:
                                                        mem[s + _2993 + 164] = mem[s + _2994 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_3158) <= _3158:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2993 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2993 + 168 len _3158 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2993 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2993 + 232] = mem[idx + _2993 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2993 + 232]
                                                            if not mem[96]:
                                                                mem[_2993 + 164] = 2
                                                                mem[64] = _2993 + 260
                                                                mem[_2993 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + 228] = address(cd[36])
                                                                mem[_2993 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + 296] = 0
                                                                mem[_2993 + 328] = 160
                                                                mem[_2993 + 424] = 2
                                                                s = 0
                                                                t = _2993 + 456
                                                                u = _2993 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + 360] = this.address
                                                                mem[_2993 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2993 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15474 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15736 = mem[_15474]
                                                                require mem[_15474] <= test266151307()
                                                                require _15474 + mem[_15474] + 31 < _15474 + return_data.size
                                                                _15906 = mem[_15474 + mem[_15474]]
                                                                if mem[_15474 + mem[_15474]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15474 + ceil32(return_data.size) + ceil32(32 * mem[_15474 + mem[_15474]]) + 1 > test266151307() or ceil32(32 * mem[_15474 + mem[_15474]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15474 + ceil32(return_data.size) + ceil32(32 * mem[_15474 + mem[_15474]]) + 1
                                                                mem[_15474 + ceil32(return_data.size)] = _15906
                                                                require return_data.size >= _15736 + (32 * _15906) + 32
                                                                t = _15474 + _15736 + 32
                                                                u = _15474 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15906:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2993 + 164] = 2
                                                                mem[64] = _2993 + 260
                                                                mem[_2993 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + 228] = address(cd[36])
                                                                mem[_2993 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + 296] = 0
                                                                mem[_2993 + 328] = 160
                                                                mem[_2993 + 424] = 2
                                                                s = 0
                                                                t = _2993 + 456
                                                                u = _2993 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + 360] = this.address
                                                                mem[_2993 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2993 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15475 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15737 = mem[_15475]
                                                                require mem[_15475] <= test266151307()
                                                                require _15475 + mem[_15475] + 31 < _15475 + return_data.size
                                                                _15907 = mem[_15475 + mem[_15475]]
                                                                if mem[_15475 + mem[_15475]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15475 + ceil32(return_data.size) + ceil32(32 * mem[_15475 + mem[_15475]]) + 1 > test266151307() or ceil32(32 * mem[_15475 + mem[_15475]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15475 + ceil32(return_data.size) + ceil32(32 * mem[_15475 + mem[_15475]]) + 1
                                                                mem[_15475 + ceil32(return_data.size)] = _15907
                                                                require return_data.size >= _15737 + (32 * _15907) + 32
                                                                t = _15475 + _15737 + 32
                                                                u = _15475 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15907:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2993 + 164] = return_data.size
                                                            mem[_2993 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2993 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2993 + ceil32(return_data.size) + 233] = mem[idx + _2993 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2993 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2993 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2993 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2993 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2993 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2993 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2993 + ceil32(return_data.size) + 457
                                                                u = _2993 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2993 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2993 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2993 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15738 = mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2993 + ceil32(return_data.size) + return_data.size + 261
                                                                _15908 = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15738 + (32 * _15908) + 32
                                                                t = _2993 + ceil32(return_data.size) + _15738 + 293
                                                                u = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15908:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2993 + 196] == bool(mem[_2993 + 196])
                                                                if not mem[_2993 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2993 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2993 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2993 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2993 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2993 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2993 + ceil32(return_data.size) + 457
                                                                u = _2993 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2993 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2993 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2993 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15739 = mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2993 + ceil32(return_data.size) + return_data.size + 261
                                                                _15909 = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15739 + (32 * _15909) + 32
                                                                t = _2993 + ceil32(return_data.size) + _15739 + 293
                                                                u = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15909:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_3158 + _2993 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2993 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2993 + 168 len _3158 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2993 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2993 + 232] = mem[idx + _2993 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2993 + 232]
                                                            if not mem[96]:
                                                                mem[_2993 + 164] = 2
                                                                mem[64] = _2993 + 260
                                                                mem[_2993 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + 228] = address(cd[36])
                                                                mem[_2993 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + 296] = 0
                                                                mem[_2993 + 328] = 160
                                                                mem[_2993 + 424] = 2
                                                                s = 0
                                                                t = _2993 + 456
                                                                u = _2993 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + 360] = this.address
                                                                mem[_2993 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2993 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15482 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15740 = mem[_15482]
                                                                require mem[_15482] <= test266151307()
                                                                require _15482 + mem[_15482] + 31 < _15482 + return_data.size
                                                                _15910 = mem[_15482 + mem[_15482]]
                                                                if mem[_15482 + mem[_15482]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15482 + ceil32(return_data.size) + ceil32(32 * mem[_15482 + mem[_15482]]) + 1 > test266151307() or ceil32(32 * mem[_15482 + mem[_15482]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15482 + ceil32(return_data.size) + ceil32(32 * mem[_15482 + mem[_15482]]) + 1
                                                                mem[_15482 + ceil32(return_data.size)] = _15910
                                                                require return_data.size >= _15740 + (32 * _15910) + 32
                                                                t = _15482 + _15740 + 32
                                                                u = _15482 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15910:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2993 + 164] = 2
                                                                mem[64] = _2993 + 260
                                                                mem[_2993 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + 228] = address(cd[36])
                                                                mem[_2993 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + 296] = 0
                                                                mem[_2993 + 328] = 160
                                                                mem[_2993 + 424] = 2
                                                                s = 0
                                                                t = _2993 + 456
                                                                u = _2993 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + 360] = this.address
                                                                mem[_2993 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2993 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15483 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15741 = mem[_15483]
                                                                require mem[_15483] <= test266151307()
                                                                require _15483 + mem[_15483] + 31 < _15483 + return_data.size
                                                                _15911 = mem[_15483 + mem[_15483]]
                                                                if mem[_15483 + mem[_15483]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15483 + ceil32(return_data.size) + ceil32(32 * mem[_15483 + mem[_15483]]) + 1 > test266151307() or ceil32(32 * mem[_15483 + mem[_15483]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15483 + ceil32(return_data.size) + ceil32(32 * mem[_15483 + mem[_15483]]) + 1
                                                                mem[_15483 + ceil32(return_data.size)] = _15911
                                                                require return_data.size >= _15741 + (32 * _15911) + 32
                                                                t = _15483 + _15741 + 32
                                                                u = _15483 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15911:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2993 + 164] = return_data.size
                                                            mem[_2993 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2993 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2993 + ceil32(return_data.size) + 233] = mem[idx + _2993 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2993 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2993 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2993 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2993 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2993 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2993 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2993 + ceil32(return_data.size) + 457
                                                                u = _2993 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2993 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2993 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2993 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15742 = mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2993 + ceil32(return_data.size) + return_data.size + 261
                                                                _15912 = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15742 + (32 * _15912) + 32
                                                                t = _2993 + ceil32(return_data.size) + _15742 + 293
                                                                u = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15912:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2993 + 196] == bool(mem[_2993 + 196])
                                                                if not mem[_2993 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2993 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2993 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2993 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2993 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2993 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2993 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2993 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2993 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2993 + ceil32(return_data.size) + 457
                                                                u = _2993 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2993 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2993 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2993 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2993 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15743 = mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2993 + ceil32(return_data.size) + return_data.size + 261
                                                                _15913 = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2993 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2993 + ceil32(return_data.size) + mem[_2993 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2823) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15743 + (32 * _15913) + 32
                                                                t = _2993 + ceil32(return_data.size) + _15743 + 293
                                                                u = _2993 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15913:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                            else:
                                                t = 10
                                                u = 1
                                                s = mem[_2821 + 31 len 1]
                                                while s > 1:
                                                    if t > -1 / t:
                                                        revert with 0, 17
                                                    if not bool(s):
                                                        t = t * t
                                                        u = u
                                                        s = uint255(s) * 0.5
                                                        continue 
                                                    t = t * t
                                                    u = t * u
                                                    s = uint255(s) * 0.5
                                                    continue 
                                                if u > -1 / t:
                                                    revert with 0, 17
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and t * u > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]:
                                                    _9545 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                    _9546 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_9546 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_9546 + 36 len 28]
                                                    mem[64] = _9545 + 164
                                                    mem[_9545 + 100] = 32
                                                    mem[_9545 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10215 = mem[_9546]
                                                    s = 0
                                                    while s < _10215:
                                                        mem[s + _9545 + 164] = mem[s + _9546 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_10215) <= _10215:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9545 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_9545 + 168 len _10215 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_9545 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9545 + 232] = mem[idx + _9545 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9545 + 232]
                                                            if not mem[96]:
                                                                mem[_9545 + 164] = 2
                                                                mem[64] = _9545 + 260
                                                                mem[_9545 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + 228] = address(cd[36])
                                                                mem[_9545 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + 296] = 0
                                                                mem[_9545 + 328] = 160
                                                                mem[_9545 + 424] = 2
                                                                s = 0
                                                                t = _9545 + 456
                                                                u = _9545 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9545 + 360] = this.address
                                                                mem[_9545 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9545 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20122 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20380 = mem[_20122]
                                                                require mem[_20122] <= test266151307()
                                                                require _20122 + mem[_20122] + 31 < _20122 + return_data.size
                                                                _20516 = mem[_20122 + mem[_20122]]
                                                                if mem[_20122 + mem[_20122]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20122 + ceil32(return_data.size) + ceil32(32 * mem[_20122 + mem[_20122]]) + 1 > test266151307() or ceil32(32 * mem[_20122 + mem[_20122]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20122 + ceil32(return_data.size) + ceil32(32 * mem[_20122 + mem[_20122]]) + 1
                                                                mem[_20122 + ceil32(return_data.size)] = _20516
                                                                require return_data.size >= _20380 + (32 * _20516) + 32
                                                                t = _20122 + _20380 + 32
                                                                u = _20122 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20516:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9545 + 164] = 2
                                                                mem[64] = _9545 + 260
                                                                mem[_9545 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + 228] = address(cd[36])
                                                                mem[_9545 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + 296] = 0
                                                                mem[_9545 + 328] = 160
                                                                mem[_9545 + 424] = 2
                                                                s = 0
                                                                t = _9545 + 456
                                                                u = _9545 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9545 + 360] = this.address
                                                                mem[_9545 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9545 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20123 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20381 = mem[_20123]
                                                                require mem[_20123] <= test266151307()
                                                                require _20123 + mem[_20123] + 31 < _20123 + return_data.size
                                                                _20517 = mem[_20123 + mem[_20123]]
                                                                if mem[_20123 + mem[_20123]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20123 + ceil32(return_data.size) + ceil32(32 * mem[_20123 + mem[_20123]]) + 1 > test266151307() or ceil32(32 * mem[_20123 + mem[_20123]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20123 + ceil32(return_data.size) + ceil32(32 * mem[_20123 + mem[_20123]]) + 1
                                                                mem[_20123 + ceil32(return_data.size)] = _20517
                                                                require return_data.size >= _20381 + (32 * _20517) + 32
                                                                t = _20123 + _20381 + 32
                                                                u = _20123 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20517:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_9545 + 164] = return_data.size
                                                            mem[_9545 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9545 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9545 + ceil32(return_data.size) + 233] = mem[idx + _9545 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9545 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_9545 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9545 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9545 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9545 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9545 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9545 + ceil32(return_data.size) + 457
                                                                w = _9545 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9545 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9545 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9545 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9545 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20382 = mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9545 + ceil32(return_data.size) + return_data.size + 261
                                                                _20518 = mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20518
                                                                require return_data.size >= _20382 + (32 * _20518) + 32
                                                                t = _9545 + ceil32(return_data.size) + _20382 + 293
                                                                u = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20518:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_9545 + 196] == bool(mem[_9545 + 196])
                                                                if not mem[_9545 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9545 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9545 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9545 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9545 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9545 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9545 + ceil32(return_data.size) + 457
                                                                w = _9545 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9545 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9545 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9545 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9545 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20383 = mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9545 + ceil32(return_data.size) + return_data.size + 261
                                                                _20519 = mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20519
                                                                require return_data.size >= _20383 + (32 * _20519) + 32
                                                                t = _9545 + ceil32(return_data.size) + _20383 + 293
                                                                u = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20519:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_10215 + _9545 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9545 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_9545 + 168 len _10215 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_9545 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9545 + 232] = mem[idx + _9545 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9545 + 232]
                                                            if not mem[96]:
                                                                mem[_9545 + 164] = 2
                                                                mem[64] = _9545 + 260
                                                                mem[_9545 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + 228] = address(cd[36])
                                                                mem[_9545 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + 296] = 0
                                                                mem[_9545 + 328] = 160
                                                                mem[_9545 + 424] = 2
                                                                s = 0
                                                                t = _9545 + 456
                                                                u = _9545 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9545 + 360] = this.address
                                                                mem[_9545 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9545 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20130 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20384 = mem[_20130]
                                                                require mem[_20130] <= test266151307()
                                                                require _20130 + mem[_20130] + 31 < _20130 + return_data.size
                                                                _20520 = mem[_20130 + mem[_20130]]
                                                                if mem[_20130 + mem[_20130]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20130 + ceil32(return_data.size) + ceil32(32 * mem[_20130 + mem[_20130]]) + 1 > test266151307() or ceil32(32 * mem[_20130 + mem[_20130]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20130 + ceil32(return_data.size) + ceil32(32 * mem[_20130 + mem[_20130]]) + 1
                                                                mem[_20130 + ceil32(return_data.size)] = _20520
                                                                require return_data.size >= _20384 + (32 * _20520) + 32
                                                                t = _20130 + _20384 + 32
                                                                u = _20130 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20520:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9545 + 164] = 2
                                                                mem[64] = _9545 + 260
                                                                mem[_9545 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + 228] = address(cd[36])
                                                                mem[_9545 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + 296] = 0
                                                                mem[_9545 + 328] = 160
                                                                mem[_9545 + 424] = 2
                                                                s = 0
                                                                t = _9545 + 456
                                                                u = _9545 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9545 + 360] = this.address
                                                                mem[_9545 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9545 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20131 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20385 = mem[_20131]
                                                                require mem[_20131] <= test266151307()
                                                                require _20131 + mem[_20131] + 31 < _20131 + return_data.size
                                                                _20521 = mem[_20131 + mem[_20131]]
                                                                if mem[_20131 + mem[_20131]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20131 + ceil32(return_data.size) + ceil32(32 * mem[_20131 + mem[_20131]]) + 1 > test266151307() or ceil32(32 * mem[_20131 + mem[_20131]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20131 + ceil32(return_data.size) + ceil32(32 * mem[_20131 + mem[_20131]]) + 1
                                                                mem[_20131 + ceil32(return_data.size)] = _20521
                                                                require return_data.size >= _20385 + (32 * _20521) + 32
                                                                t = _20131 + _20385 + 32
                                                                u = _20131 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20521:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_9545 + 164] = return_data.size
                                                            mem[_9545 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9545 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9545 + ceil32(return_data.size) + 233] = mem[idx + _9545 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9545 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_9545 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9545 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9545 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9545 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9545 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9545 + ceil32(return_data.size) + 457
                                                                w = _9545 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9545 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9545 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9545 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9545 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20386 = mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9545 + ceil32(return_data.size) + return_data.size + 261
                                                                _20522 = mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20522
                                                                require return_data.size >= _20386 + (32 * _20522) + 32
                                                                t = _9545 + ceil32(return_data.size) + _20386 + 293
                                                                u = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20522:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_9545 + 196] == bool(mem[_9545 + 196])
                                                                if not mem[_9545 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9545 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9545 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9545 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9545 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9545 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9545 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9545 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9545 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9545 + ceil32(return_data.size) + 457
                                                                w = _9545 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9545 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9545 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9545 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9545 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20387 = mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9545 + ceil32(return_data.size) + return_data.size + 261
                                                                _20523 = mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9545 + ceil32(return_data.size) + mem[_9545 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9545 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20523
                                                                require return_data.size >= _20387 + (32 * _20523) + 32
                                                                t = _9545 + ceil32(return_data.size) + _20387 + 293
                                                                u = _9545 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20523:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9606 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_9606]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _10342 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                    _10343 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10343 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_10343 + 36 len 28]
                                                    mem[64] = _10342 + 164
                                                    mem[_10342 + 100] = 32
                                                    mem[_10342 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10923 = mem[_10343]
                                                    s = 0
                                                    while s < _10923:
                                                        mem[s + _10342 + 164] = mem[s + _10343 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_10923) <= _10923:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10342 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_10342 + 168 len _10923 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_10342 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10342 + 232] = mem[idx + _10342 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10342 + 232]
                                                            if not mem[96]:
                                                                mem[_10342 + 164] = 2
                                                                mem[64] = _10342 + 260
                                                                mem[_10342 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + 228] = address(cd[36])
                                                                mem[_10342 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + 296] = 0
                                                                mem[_10342 + 328] = 160
                                                                mem[_10342 + 424] = 2
                                                                s = 0
                                                                t = _10342 + 456
                                                                u = _10342 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10342 + 360] = this.address
                                                                mem[_10342 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10342 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20138 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20388 = mem[_20138]
                                                                require mem[_20138] <= test266151307()
                                                                require _20138 + mem[_20138] + 31 < _20138 + return_data.size
                                                                _20524 = mem[_20138 + mem[_20138]]
                                                                if mem[_20138 + mem[_20138]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20138 + ceil32(return_data.size) + ceil32(32 * mem[_20138 + mem[_20138]]) + 1 > test266151307() or ceil32(32 * mem[_20138 + mem[_20138]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20138 + ceil32(return_data.size) + ceil32(32 * mem[_20138 + mem[_20138]]) + 1
                                                                mem[_20138 + ceil32(return_data.size)] = _20524
                                                                require return_data.size >= _20388 + (32 * _20524) + 32
                                                                t = _20138 + _20388 + 32
                                                                u = _20138 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20524:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10342 + 164] = 2
                                                                mem[64] = _10342 + 260
                                                                mem[_10342 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + 228] = address(cd[36])
                                                                mem[_10342 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + 296] = 0
                                                                mem[_10342 + 328] = 160
                                                                mem[_10342 + 424] = 2
                                                                s = 0
                                                                t = _10342 + 456
                                                                u = _10342 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10342 + 360] = this.address
                                                                mem[_10342 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10342 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20139 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20389 = mem[_20139]
                                                                require mem[_20139] <= test266151307()
                                                                require _20139 + mem[_20139] + 31 < _20139 + return_data.size
                                                                _20525 = mem[_20139 + mem[_20139]]
                                                                if mem[_20139 + mem[_20139]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20139 + ceil32(return_data.size) + ceil32(32 * mem[_20139 + mem[_20139]]) + 1 > test266151307() or ceil32(32 * mem[_20139 + mem[_20139]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20139 + ceil32(return_data.size) + ceil32(32 * mem[_20139 + mem[_20139]]) + 1
                                                                mem[_20139 + ceil32(return_data.size)] = _20525
                                                                require return_data.size >= _20389 + (32 * _20525) + 32
                                                                t = _20139 + _20389 + 32
                                                                u = _20139 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20525:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_10342 + 164] = return_data.size
                                                            mem[_10342 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10342 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10342 + ceil32(return_data.size) + 233] = mem[idx + _10342 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10342 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_10342 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10342 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10342 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10342 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10342 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10342 + ceil32(return_data.size) + 457
                                                                w = _10342 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10342 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10342 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10342 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10342 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20390 = mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10342 + ceil32(return_data.size) + return_data.size + 261
                                                                _20526 = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20390 + (32 * _20526) + 32
                                                                t = _10342 + ceil32(return_data.size) + _20390 + 293
                                                                u = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20526:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_10342 + 196] == bool(mem[_10342 + 196])
                                                                if not mem[_10342 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10342 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10342 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10342 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10342 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10342 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10342 + ceil32(return_data.size) + 457
                                                                w = _10342 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10342 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10342 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10342 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10342 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20391 = mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10342 + ceil32(return_data.size) + return_data.size + 261
                                                                _20527 = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20391 + (32 * _20527) + 32
                                                                t = _10342 + ceil32(return_data.size) + _20391 + 293
                                                                u = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20527:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_10923 + _10342 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10342 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_10342 + 168 len _10923 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_10342 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10342 + 232] = mem[idx + _10342 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10342 + 232]
                                                            if not mem[96]:
                                                                mem[_10342 + 164] = 2
                                                                mem[64] = _10342 + 260
                                                                mem[_10342 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + 228] = address(cd[36])
                                                                mem[_10342 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + 296] = 0
                                                                mem[_10342 + 328] = 160
                                                                mem[_10342 + 424] = 2
                                                                s = 0
                                                                t = _10342 + 456
                                                                u = _10342 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10342 + 360] = this.address
                                                                mem[_10342 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10342 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20146 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20392 = mem[_20146]
                                                                require mem[_20146] <= test266151307()
                                                                require _20146 + mem[_20146] + 31 < _20146 + return_data.size
                                                                _20528 = mem[_20146 + mem[_20146]]
                                                                if mem[_20146 + mem[_20146]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20146 + ceil32(return_data.size) + ceil32(32 * mem[_20146 + mem[_20146]]) + 1 > test266151307() or ceil32(32 * mem[_20146 + mem[_20146]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20146 + ceil32(return_data.size) + ceil32(32 * mem[_20146 + mem[_20146]]) + 1
                                                                mem[_20146 + ceil32(return_data.size)] = _20528
                                                                require return_data.size >= _20392 + (32 * _20528) + 32
                                                                t = _20146 + _20392 + 32
                                                                u = _20146 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20528:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10342 + 164] = 2
                                                                mem[64] = _10342 + 260
                                                                mem[_10342 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + 228] = address(cd[36])
                                                                mem[_10342 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + 296] = 0
                                                                mem[_10342 + 328] = 160
                                                                mem[_10342 + 424] = 2
                                                                s = 0
                                                                t = _10342 + 456
                                                                u = _10342 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10342 + 360] = this.address
                                                                mem[_10342 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10342 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20147 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20393 = mem[_20147]
                                                                require mem[_20147] <= test266151307()
                                                                require _20147 + mem[_20147] + 31 < _20147 + return_data.size
                                                                _20529 = mem[_20147 + mem[_20147]]
                                                                if mem[_20147 + mem[_20147]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20147 + ceil32(return_data.size) + ceil32(32 * mem[_20147 + mem[_20147]]) + 1 > test266151307() or ceil32(32 * mem[_20147 + mem[_20147]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20147 + ceil32(return_data.size) + ceil32(32 * mem[_20147 + mem[_20147]]) + 1
                                                                mem[_20147 + ceil32(return_data.size)] = _20529
                                                                require return_data.size >= _20393 + (32 * _20529) + 32
                                                                t = _20147 + _20393 + 32
                                                                u = _20147 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20529:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_10342 + 164] = return_data.size
                                                            mem[_10342 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10342 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10342 + ceil32(return_data.size) + 233] = mem[idx + _10342 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10342 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_10342 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10342 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10342 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10342 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10342 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10342 + ceil32(return_data.size) + 457
                                                                w = _10342 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10342 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10342 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10342 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10342 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20394 = mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10342 + ceil32(return_data.size) + return_data.size + 261
                                                                _20530 = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20394 + (32 * _20530) + 32
                                                                t = _10342 + ceil32(return_data.size) + _20394 + 293
                                                                u = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20530:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_10342 + 196] == bool(mem[_10342 + 196])
                                                                if not mem[_10342 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10342 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10342 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10342 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10342 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10342 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10342 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10342 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10342 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10342 + ceil32(return_data.size) + 457
                                                                w = _10342 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10342 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10342 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10342 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10342 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20395 = mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10342 + ceil32(return_data.size) + return_data.size + 261
                                                                _20531 = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10342 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10342 + ceil32(return_data.size) + mem[_10342 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20395 + (32 * _20531) + 32
                                                                t = _10342 + ceil32(return_data.size) + _20395 + 293
                                                                u = _10342 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20531:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                        if idx >= ('cd', 68).length:
                                            revert with 0, 50
                                        require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                        mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                                        mem[32] = 1
                                        sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])] = 1
                                        if sub_8cf086ad > -2:
                                            revert with 0, 17
                                        sub_8cf086ad++
                                else:
                                    if bool(bool(mem[_2813 + 31 len 1] < 78)) or bool(bool(mem[_2813 + 31 len 1] < 32)):
                                        if Mask(112, 0, _2802) and cd[((32 * idx) + cd[100] + 36)] > -1 / Mask(112, 0, _2802):
                                            revert with 0, 17
                                        if not 10^mem[_2813 + 31 len 1]:
                                            revert with 0, 18
                                        if cd[196] <= Mask(112, 0, _2802) * cd[((32 * idx) + cd[100] + 36)] / 10^mem[_2813 + 31 len 1]:
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            if idx >= ('cd', 100).length:
                                                revert with 0, 50
                                            if idx >= ('cd', 132).length:
                                                revert with 0, 50
                                            if cd[164] and cd[((32 * idx) + cd[132] + 36)] > -1 / cd[164]:
                                                revert with 0, 17
                                            require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                            staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2829 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _2833 = mem[_2829]
                                            require mem[_2829] == mem[_2829 + 31 len 1]
                                            if not mem[_2829 + 31 len 1]:
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 1 > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]:
                                                    _2873 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _2874 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_2874 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2874 + 36 len 28]
                                                    mem[64] = _2873 + 164
                                                    mem[_2873 + 100] = 32
                                                    mem[_2873 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _2966 = mem[_2874]
                                                    s = 0
                                                    while s < _2966:
                                                        mem[s + _2873 + 164] = mem[s + _2874 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_2966) <= _2966:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2873 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2873 + 168 len _2966 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2873 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2873 + 232] = mem[idx + _2873 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2873 + 232]
                                                            if not mem[96]:
                                                                mem[_2873 + 164] = 2
                                                                mem[64] = _2873 + 260
                                                                mem[_2873 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + 228] = address(cd[36])
                                                                mem[_2873 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + 296] = 0
                                                                mem[_2873 + 328] = 160
                                                                mem[_2873 + 424] = 2
                                                                s = 0
                                                                t = _2873 + 456
                                                                u = _2873 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + 360] = this.address
                                                                mem[_2873 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2873 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15422 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15712 = mem[_15422]
                                                                require mem[_15422] <= test266151307()
                                                                require _15422 + mem[_15422] + 31 < _15422 + return_data.size
                                                                _15874 = mem[_15422 + mem[_15422]]
                                                                if mem[_15422 + mem[_15422]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15422 + ceil32(return_data.size) + ceil32(32 * mem[_15422 + mem[_15422]]) + 1 > test266151307() or ceil32(32 * mem[_15422 + mem[_15422]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15422 + ceil32(return_data.size) + ceil32(32 * mem[_15422 + mem[_15422]]) + 1
                                                                mem[_15422 + ceil32(return_data.size)] = _15874
                                                                require return_data.size >= _15712 + (32 * _15874) + 32
                                                                t = _15422 + _15712 + 32
                                                                u = _15422 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15874:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2873 + 164] = 2
                                                                mem[64] = _2873 + 260
                                                                mem[_2873 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + 228] = address(cd[36])
                                                                mem[_2873 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + 296] = 0
                                                                mem[_2873 + 328] = 160
                                                                mem[_2873 + 424] = 2
                                                                s = 0
                                                                t = _2873 + 456
                                                                u = _2873 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + 360] = this.address
                                                                mem[_2873 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2873 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15423 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15713 = mem[_15423]
                                                                require mem[_15423] <= test266151307()
                                                                require _15423 + mem[_15423] + 31 < _15423 + return_data.size
                                                                _15875 = mem[_15423 + mem[_15423]]
                                                                if mem[_15423 + mem[_15423]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15423 + ceil32(return_data.size) + ceil32(32 * mem[_15423 + mem[_15423]]) + 1 > test266151307() or ceil32(32 * mem[_15423 + mem[_15423]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15423 + ceil32(return_data.size) + ceil32(32 * mem[_15423 + mem[_15423]]) + 1
                                                                mem[_15423 + ceil32(return_data.size)] = _15875
                                                                require return_data.size >= _15713 + (32 * _15875) + 32
                                                                t = _15423 + _15713 + 32
                                                                u = _15423 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15875:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2873 + 164] = return_data.size
                                                            mem[_2873 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2873 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2873 + ceil32(return_data.size) + 233] = mem[idx + _2873 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2873 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2873 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2873 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2873 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2873 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2873 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2873 + ceil32(return_data.size) + 457
                                                                u = _2873 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2873 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2873 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2873 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15714 = mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2873 + ceil32(return_data.size) + return_data.size + 261
                                                                _15876 = mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15876
                                                                require return_data.size >= _15714 + (32 * _15876) + 32
                                                                t = _2873 + ceil32(return_data.size) + _15714 + 293
                                                                u = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15876:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2873 + 196] == bool(mem[_2873 + 196])
                                                                if not mem[_2873 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2873 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2873 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2873 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2873 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2873 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2873 + ceil32(return_data.size) + 457
                                                                u = _2873 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2873 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2873 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2873 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15715 = mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2873 + ceil32(return_data.size) + return_data.size + 261
                                                                _15877 = mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15877
                                                                require return_data.size >= _15715 + (32 * _15877) + 32
                                                                t = _2873 + ceil32(return_data.size) + _15715 + 293
                                                                u = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15877:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_2966 + _2873 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2873 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2873 + 168 len _2966 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2873 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2873 + 232] = mem[idx + _2873 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2873 + 232]
                                                            if not mem[96]:
                                                                mem[_2873 + 164] = 2
                                                                mem[64] = _2873 + 260
                                                                mem[_2873 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + 228] = address(cd[36])
                                                                mem[_2873 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + 296] = 0
                                                                mem[_2873 + 328] = 160
                                                                mem[_2873 + 424] = 2
                                                                s = 0
                                                                t = _2873 + 456
                                                                u = _2873 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + 360] = this.address
                                                                mem[_2873 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2873 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15430 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15716 = mem[_15430]
                                                                require mem[_15430] <= test266151307()
                                                                require _15430 + mem[_15430] + 31 < _15430 + return_data.size
                                                                _15878 = mem[_15430 + mem[_15430]]
                                                                if mem[_15430 + mem[_15430]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15430 + ceil32(return_data.size) + ceil32(32 * mem[_15430 + mem[_15430]]) + 1 > test266151307() or ceil32(32 * mem[_15430 + mem[_15430]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15430 + ceil32(return_data.size) + ceil32(32 * mem[_15430 + mem[_15430]]) + 1
                                                                mem[_15430 + ceil32(return_data.size)] = _15878
                                                                require return_data.size >= _15716 + (32 * _15878) + 32
                                                                t = _15430 + _15716 + 32
                                                                u = _15430 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15878:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2873 + 164] = 2
                                                                mem[64] = _2873 + 260
                                                                mem[_2873 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + 228] = address(cd[36])
                                                                mem[_2873 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + 296] = 0
                                                                mem[_2873 + 328] = 160
                                                                mem[_2873 + 424] = 2
                                                                s = 0
                                                                t = _2873 + 456
                                                                u = _2873 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + 360] = this.address
                                                                mem[_2873 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2873 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15431 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15717 = mem[_15431]
                                                                require mem[_15431] <= test266151307()
                                                                require _15431 + mem[_15431] + 31 < _15431 + return_data.size
                                                                _15879 = mem[_15431 + mem[_15431]]
                                                                if mem[_15431 + mem[_15431]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15431 + ceil32(return_data.size) + ceil32(32 * mem[_15431 + mem[_15431]]) + 1 > test266151307() or ceil32(32 * mem[_15431 + mem[_15431]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15431 + ceil32(return_data.size) + ceil32(32 * mem[_15431 + mem[_15431]]) + 1
                                                                mem[_15431 + ceil32(return_data.size)] = _15879
                                                                require return_data.size >= _15717 + (32 * _15879) + 32
                                                                t = _15431 + _15717 + 32
                                                                u = _15431 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15879:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2873 + 164] = return_data.size
                                                            mem[_2873 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2873 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2873 + ceil32(return_data.size) + 233] = mem[idx + _2873 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2873 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2873 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2873 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2873 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2873 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2873 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2873 + ceil32(return_data.size) + 457
                                                                u = _2873 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2873 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2873 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2873 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15718 = mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2873 + ceil32(return_data.size) + return_data.size + 261
                                                                _15880 = mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15880
                                                                require return_data.size >= _15718 + (32 * _15880) + 32
                                                                t = _2873 + ceil32(return_data.size) + _15718 + 293
                                                                u = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15880:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2873 + 196] == bool(mem[_2873 + 196])
                                                                if not mem[_2873 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2873 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2873 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2873 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2873 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2873 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2873 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2873 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2873 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2873 + ceil32(return_data.size) + 457
                                                                u = _2873 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2873 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2873 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2873 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2873 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15719 = mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2873 + ceil32(return_data.size) + return_data.size + 261
                                                                _15881 = mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2873 + ceil32(return_data.size) + mem[_2873 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2873 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15881
                                                                require return_data.size >= _15719 + (32 * _15881) + 32
                                                                t = _2873 + ceil32(return_data.size) + _15719 + 293
                                                                u = _2873 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15881:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _2893 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_2893]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _2988 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _2989 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_2989 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2989 + 36 len 28]
                                                    mem[64] = _2988 + 164
                                                    mem[_2988 + 100] = 32
                                                    mem[_2988 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _3153 = mem[_2989]
                                                    s = 0
                                                    while s < _3153:
                                                        mem[s + _2988 + 164] = mem[s + _2989 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_3153) <= _3153:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2988 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2988 + 168 len _3153 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2988 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2988 + 232] = mem[idx + _2988 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2988 + 232]
                                                            if not mem[96]:
                                                                mem[_2988 + 164] = 2
                                                                mem[64] = _2988 + 260
                                                                mem[_2988 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + 228] = address(cd[36])
                                                                mem[_2988 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + 296] = 0
                                                                mem[_2988 + 328] = 160
                                                                mem[_2988 + 424] = 2
                                                                s = 0
                                                                t = _2988 + 456
                                                                u = _2988 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + 360] = this.address
                                                                mem[_2988 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2988 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15438 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15720 = mem[_15438]
                                                                require mem[_15438] <= test266151307()
                                                                require _15438 + mem[_15438] + 31 < _15438 + return_data.size
                                                                _15882 = mem[_15438 + mem[_15438]]
                                                                if mem[_15438 + mem[_15438]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15438 + ceil32(return_data.size) + ceil32(32 * mem[_15438 + mem[_15438]]) + 1 > test266151307() or ceil32(32 * mem[_15438 + mem[_15438]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15438 + ceil32(return_data.size) + ceil32(32 * mem[_15438 + mem[_15438]]) + 1
                                                                mem[_15438 + ceil32(return_data.size)] = _15882
                                                                require return_data.size >= _15720 + (32 * _15882) + 32
                                                                t = _15438 + _15720 + 32
                                                                u = _15438 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15882:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2988 + 164] = 2
                                                                mem[64] = _2988 + 260
                                                                mem[_2988 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + 228] = address(cd[36])
                                                                mem[_2988 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + 296] = 0
                                                                mem[_2988 + 328] = 160
                                                                mem[_2988 + 424] = 2
                                                                s = 0
                                                                t = _2988 + 456
                                                                u = _2988 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + 360] = this.address
                                                                mem[_2988 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2988 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15439 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15721 = mem[_15439]
                                                                require mem[_15439] <= test266151307()
                                                                require _15439 + mem[_15439] + 31 < _15439 + return_data.size
                                                                _15883 = mem[_15439 + mem[_15439]]
                                                                if mem[_15439 + mem[_15439]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15439 + ceil32(return_data.size) + ceil32(32 * mem[_15439 + mem[_15439]]) + 1 > test266151307() or ceil32(32 * mem[_15439 + mem[_15439]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15439 + ceil32(return_data.size) + ceil32(32 * mem[_15439 + mem[_15439]]) + 1
                                                                mem[_15439 + ceil32(return_data.size)] = _15883
                                                                require return_data.size >= _15721 + (32 * _15883) + 32
                                                                t = _15439 + _15721 + 32
                                                                u = _15439 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15883:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2988 + 164] = return_data.size
                                                            mem[_2988 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2988 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2988 + ceil32(return_data.size) + 233] = mem[idx + _2988 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2988 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2988 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2988 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2988 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2988 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2988 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2988 + ceil32(return_data.size) + 457
                                                                u = _2988 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2988 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2988 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2988 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15722 = mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2988 + ceil32(return_data.size) + return_data.size + 261
                                                                _15884 = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15722 + (32 * _15884) + 32
                                                                t = _2988 + ceil32(return_data.size) + _15722 + 293
                                                                u = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15884:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2988 + 196] == bool(mem[_2988 + 196])
                                                                if not mem[_2988 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2988 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2988 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2988 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2988 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2988 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2988 + ceil32(return_data.size) + 457
                                                                u = _2988 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2988 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2988 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2988 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15723 = mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2988 + ceil32(return_data.size) + return_data.size + 261
                                                                _15885 = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15723 + (32 * _15885) + 32
                                                                t = _2988 + ceil32(return_data.size) + _15723 + 293
                                                                u = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15885:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_3153 + _2988 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2988 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2988 + 168 len _3153 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2988 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2988 + 232] = mem[idx + _2988 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2988 + 232]
                                                            if not mem[96]:
                                                                mem[_2988 + 164] = 2
                                                                mem[64] = _2988 + 260
                                                                mem[_2988 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + 228] = address(cd[36])
                                                                mem[_2988 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + 296] = 0
                                                                mem[_2988 + 328] = 160
                                                                mem[_2988 + 424] = 2
                                                                s = 0
                                                                t = _2988 + 456
                                                                u = _2988 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + 360] = this.address
                                                                mem[_2988 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2988 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15446 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15724 = mem[_15446]
                                                                require mem[_15446] <= test266151307()
                                                                require _15446 + mem[_15446] + 31 < _15446 + return_data.size
                                                                _15886 = mem[_15446 + mem[_15446]]
                                                                if mem[_15446 + mem[_15446]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15446 + ceil32(return_data.size) + ceil32(32 * mem[_15446 + mem[_15446]]) + 1 > test266151307() or ceil32(32 * mem[_15446 + mem[_15446]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15446 + ceil32(return_data.size) + ceil32(32 * mem[_15446 + mem[_15446]]) + 1
                                                                mem[_15446 + ceil32(return_data.size)] = _15886
                                                                require return_data.size >= _15724 + (32 * _15886) + 32
                                                                t = _15446 + _15724 + 32
                                                                u = _15446 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15886:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2988 + 164] = 2
                                                                mem[64] = _2988 + 260
                                                                mem[_2988 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + 228] = address(cd[36])
                                                                mem[_2988 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + 296] = 0
                                                                mem[_2988 + 328] = 160
                                                                mem[_2988 + 424] = 2
                                                                s = 0
                                                                t = _2988 + 456
                                                                u = _2988 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + 360] = this.address
                                                                mem[_2988 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2988 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15447 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15725 = mem[_15447]
                                                                require mem[_15447] <= test266151307()
                                                                require _15447 + mem[_15447] + 31 < _15447 + return_data.size
                                                                _15887 = mem[_15447 + mem[_15447]]
                                                                if mem[_15447 + mem[_15447]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15447 + ceil32(return_data.size) + ceil32(32 * mem[_15447 + mem[_15447]]) + 1 > test266151307() or ceil32(32 * mem[_15447 + mem[_15447]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15447 + ceil32(return_data.size) + ceil32(32 * mem[_15447 + mem[_15447]]) + 1
                                                                mem[_15447 + ceil32(return_data.size)] = _15887
                                                                require return_data.size >= _15725 + (32 * _15887) + 32
                                                                t = _15447 + _15725 + 32
                                                                u = _15447 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15887:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2988 + 164] = return_data.size
                                                            mem[_2988 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2988 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2988 + ceil32(return_data.size) + 233] = mem[idx + _2988 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2988 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2988 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2988 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2988 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2988 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2988 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2988 + ceil32(return_data.size) + 457
                                                                u = _2988 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2988 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2988 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2988 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15726 = mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2988 + ceil32(return_data.size) + return_data.size + 261
                                                                _15888 = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15726 + (32 * _15888) + 32
                                                                t = _2988 + ceil32(return_data.size) + _15726 + 293
                                                                u = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15888:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2988 + 196] == bool(mem[_2988 + 196])
                                                                if not mem[_2988 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2988 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2988 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2988 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2988 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2988 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2988 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2988 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2988 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2988 + ceil32(return_data.size) + 457
                                                                u = _2988 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2988 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2988 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2988 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2988 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15727 = mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2988 + ceil32(return_data.size) + return_data.size + 261
                                                                _15889 = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2988 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2988 + ceil32(return_data.size) + mem[_2988 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _15727 + (32 * _15889) + 32
                                                                t = _2988 + ceil32(return_data.size) + _15727 + 293
                                                                u = _2988 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15889:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                            else:
                                                if bool(bool(mem[_2829 + 31 len 1] < 78)) or bool(bool(mem[_2829 + 31 len 1] < 32)):
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 10^mem[_2829 + 31 len 1] > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^mem[_2829 + 31 len 1] / cd[((32 * idx) + cd[100] + 36)]:
                                                        _2962 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                        _2963 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_2963 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2963 + 36 len 28]
                                                        mem[64] = _2962 + 164
                                                        mem[_2962 + 100] = 32
                                                        mem[_2962 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _3104 = mem[_2963]
                                                        s = 0
                                                        while s < _3104:
                                                            mem[s + _2962 + 164] = mem[s + _2963 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_3104) <= _3104:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2962 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_2962 + 168 len _3104 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_2962 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2962 + 232] = mem[idx + _2962 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2962 + 232]
                                                                if not mem[96]:
                                                                    mem[_2962 + 164] = 2
                                                                    mem[64] = _2962 + 260
                                                                    mem[_2962 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + 228] = address(cd[36])
                                                                    mem[_2962 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + 296] = 0
                                                                    mem[_2962 + 328] = 160
                                                                    mem[_2962 + 424] = 2
                                                                    s = 0
                                                                    t = _2962 + 456
                                                                    u = _2962 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + 360] = this.address
                                                                    mem[_2962 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2962 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15390 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15696 = mem[_15390]
                                                                    require mem[_15390] <= test266151307()
                                                                    require _15390 + mem[_15390] + 31 < _15390 + return_data.size
                                                                    _15858 = mem[_15390 + mem[_15390]]
                                                                    if mem[_15390 + mem[_15390]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15390 + ceil32(return_data.size) + ceil32(32 * mem[_15390 + mem[_15390]]) + 1 > test266151307() or ceil32(32 * mem[_15390 + mem[_15390]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15390 + ceil32(return_data.size) + ceil32(32 * mem[_15390 + mem[_15390]]) + 1
                                                                    mem[_15390 + ceil32(return_data.size)] = _15858
                                                                    require return_data.size >= _15696 + (32 * _15858) + 32
                                                                    t = _15390 + _15696 + 32
                                                                    u = _15390 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15858:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2962 + 164] = 2
                                                                    mem[64] = _2962 + 260
                                                                    mem[_2962 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + 228] = address(cd[36])
                                                                    mem[_2962 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + 296] = 0
                                                                    mem[_2962 + 328] = 160
                                                                    mem[_2962 + 424] = 2
                                                                    s = 0
                                                                    t = _2962 + 456
                                                                    u = _2962 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + 360] = this.address
                                                                    mem[_2962 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2962 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15391 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15697 = mem[_15391]
                                                                    require mem[_15391] <= test266151307()
                                                                    require _15391 + mem[_15391] + 31 < _15391 + return_data.size
                                                                    _15859 = mem[_15391 + mem[_15391]]
                                                                    if mem[_15391 + mem[_15391]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15391 + ceil32(return_data.size) + ceil32(32 * mem[_15391 + mem[_15391]]) + 1 > test266151307() or ceil32(32 * mem[_15391 + mem[_15391]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15391 + ceil32(return_data.size) + ceil32(32 * mem[_15391 + mem[_15391]]) + 1
                                                                    mem[_15391 + ceil32(return_data.size)] = _15859
                                                                    require return_data.size >= _15697 + (32 * _15859) + 32
                                                                    t = _15391 + _15697 + 32
                                                                    u = _15391 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15859:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_2962 + 164] = return_data.size
                                                                mem[_2962 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2962 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2962 + ceil32(return_data.size) + 233] = mem[idx + _2962 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2962 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_2962 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2962 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2962 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2962 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2962 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2962 + ceil32(return_data.size) + 457
                                                                    u = _2962 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2962 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2962 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2962 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15698 = mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2962 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15860 = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _15698 + (32 * _15860) + 32
                                                                    t = _2962 + ceil32(return_data.size) + _15698 + 293
                                                                    u = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15860:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_2962 + 196] == bool(mem[_2962 + 196])
                                                                    if not mem[_2962 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2962 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2962 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2962 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2962 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2962 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2962 + ceil32(return_data.size) + 457
                                                                    u = _2962 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2962 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2962 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2962 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15699 = mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2962 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15861 = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _15699 + (32 * _15861) + 32
                                                                    t = _2962 + ceil32(return_data.size) + _15699 + 293
                                                                    u = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15861:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_3104 + _2962 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2962 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_2962 + 168 len _3104 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_2962 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2962 + 232] = mem[idx + _2962 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2962 + 232]
                                                                if not mem[96]:
                                                                    mem[_2962 + 164] = 2
                                                                    mem[64] = _2962 + 260
                                                                    mem[_2962 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + 228] = address(cd[36])
                                                                    mem[_2962 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + 296] = 0
                                                                    mem[_2962 + 328] = 160
                                                                    mem[_2962 + 424] = 2
                                                                    s = 0
                                                                    t = _2962 + 456
                                                                    u = _2962 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + 360] = this.address
                                                                    mem[_2962 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2962 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15398 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15700 = mem[_15398]
                                                                    require mem[_15398] <= test266151307()
                                                                    require _15398 + mem[_15398] + 31 < _15398 + return_data.size
                                                                    _15862 = mem[_15398 + mem[_15398]]
                                                                    if mem[_15398 + mem[_15398]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15398 + ceil32(return_data.size) + ceil32(32 * mem[_15398 + mem[_15398]]) + 1 > test266151307() or ceil32(32 * mem[_15398 + mem[_15398]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15398 + ceil32(return_data.size) + ceil32(32 * mem[_15398 + mem[_15398]]) + 1
                                                                    mem[_15398 + ceil32(return_data.size)] = _15862
                                                                    require return_data.size >= _15700 + (32 * _15862) + 32
                                                                    t = _15398 + _15700 + 32
                                                                    u = _15398 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15862:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2962 + 164] = 2
                                                                    mem[64] = _2962 + 260
                                                                    mem[_2962 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + 228] = address(cd[36])
                                                                    mem[_2962 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + 296] = 0
                                                                    mem[_2962 + 328] = 160
                                                                    mem[_2962 + 424] = 2
                                                                    s = 0
                                                                    t = _2962 + 456
                                                                    u = _2962 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + 360] = this.address
                                                                    mem[_2962 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2962 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15399 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15701 = mem[_15399]
                                                                    require mem[_15399] <= test266151307()
                                                                    require _15399 + mem[_15399] + 31 < _15399 + return_data.size
                                                                    _15863 = mem[_15399 + mem[_15399]]
                                                                    if mem[_15399 + mem[_15399]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15399 + ceil32(return_data.size) + ceil32(32 * mem[_15399 + mem[_15399]]) + 1 > test266151307() or ceil32(32 * mem[_15399 + mem[_15399]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15399 + ceil32(return_data.size) + ceil32(32 * mem[_15399 + mem[_15399]]) + 1
                                                                    mem[_15399 + ceil32(return_data.size)] = _15863
                                                                    require return_data.size >= _15701 + (32 * _15863) + 32
                                                                    t = _15399 + _15701 + 32
                                                                    u = _15399 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15863:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_2962 + 164] = return_data.size
                                                                mem[_2962 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2962 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2962 + ceil32(return_data.size) + 233] = mem[idx + _2962 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2962 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_2962 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2962 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2962 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2962 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2962 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2962 + ceil32(return_data.size) + 457
                                                                    u = _2962 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2962 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2962 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2962 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15702 = mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2962 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15864 = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _15702 + (32 * _15864) + 32
                                                                    t = _2962 + ceil32(return_data.size) + _15702 + 293
                                                                    u = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15864:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_2962 + 196] == bool(mem[_2962 + 196])
                                                                    if not mem[_2962 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2962 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2962 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2962 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2962 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2962 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2962 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2962 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2962 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2962 + ceil32(return_data.size) + 457
                                                                    u = _2962 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2962 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2962 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2962 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2962 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15703 = mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2962 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15865 = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2962 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2962 + ceil32(return_data.size) + mem[_2962 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _15703 + (32 * _15865) + 32
                                                                    t = _2962 + ceil32(return_data.size) + _15703 + 293
                                                                    u = _2962 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15865:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _2987 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_2987]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _3146 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                        _3147 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_3147 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_3147 + 36 len 28]
                                                        mem[64] = _3146 + 164
                                                        mem[_3146 + 100] = 32
                                                        mem[_3146 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _3377 = mem[_3147]
                                                        s = 0
                                                        while s < _3377:
                                                            mem[s + _3146 + 164] = mem[s + _3147 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_3377) <= _3377:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3146 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_3146 + 168 len _3377 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_3146 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3146 + 232] = mem[idx + _3146 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3146 + 232]
                                                                if not mem[96]:
                                                                    mem[_3146 + 164] = 2
                                                                    mem[64] = _3146 + 260
                                                                    mem[_3146 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + 228] = address(cd[36])
                                                                    mem[_3146 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + 296] = 0
                                                                    mem[_3146 + 328] = 160
                                                                    mem[_3146 + 424] = 2
                                                                    s = 0
                                                                    t = _3146 + 456
                                                                    u = _3146 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + 360] = this.address
                                                                    mem[_3146 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3146 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15406 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15704 = mem[_15406]
                                                                    require mem[_15406] <= test266151307()
                                                                    require _15406 + mem[_15406] + 31 < _15406 + return_data.size
                                                                    _15866 = mem[_15406 + mem[_15406]]
                                                                    if mem[_15406 + mem[_15406]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15406 + ceil32(return_data.size) + ceil32(32 * mem[_15406 + mem[_15406]]) + 1 > test266151307() or ceil32(32 * mem[_15406 + mem[_15406]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15406 + ceil32(return_data.size) + ceil32(32 * mem[_15406 + mem[_15406]]) + 1
                                                                    mem[_15406 + ceil32(return_data.size)] = _15866
                                                                    require return_data.size >= _15704 + (32 * _15866) + 32
                                                                    t = _15406 + _15704 + 32
                                                                    u = _15406 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15866:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3146 + 164] = 2
                                                                    mem[64] = _3146 + 260
                                                                    mem[_3146 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + 228] = address(cd[36])
                                                                    mem[_3146 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + 296] = 0
                                                                    mem[_3146 + 328] = 160
                                                                    mem[_3146 + 424] = 2
                                                                    s = 0
                                                                    t = _3146 + 456
                                                                    u = _3146 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + 360] = this.address
                                                                    mem[_3146 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3146 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15407 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15705 = mem[_15407]
                                                                    require mem[_15407] <= test266151307()
                                                                    require _15407 + mem[_15407] + 31 < _15407 + return_data.size
                                                                    _15867 = mem[_15407 + mem[_15407]]
                                                                    if mem[_15407 + mem[_15407]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15407 + ceil32(return_data.size) + ceil32(32 * mem[_15407 + mem[_15407]]) + 1 > test266151307() or ceil32(32 * mem[_15407 + mem[_15407]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15407 + ceil32(return_data.size) + ceil32(32 * mem[_15407 + mem[_15407]]) + 1
                                                                    mem[_15407 + ceil32(return_data.size)] = _15867
                                                                    require return_data.size >= _15705 + (32 * _15867) + 32
                                                                    t = _15407 + _15705 + 32
                                                                    u = _15407 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15867:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_3146 + 164] = return_data.size
                                                                mem[_3146 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3146 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3146 + ceil32(return_data.size) + 233] = mem[idx + _3146 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3146 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_3146 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3146 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3146 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3146 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3146 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3146 + ceil32(return_data.size) + 457
                                                                    u = _3146 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3146 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3146 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3146 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15706 = mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3146 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15868 = mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15868
                                                                    require return_data.size >= _15706 + (32 * _15868) + 32
                                                                    t = _3146 + ceil32(return_data.size) + _15706 + 293
                                                                    u = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15868:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_3146 + 196] == bool(mem[_3146 + 196])
                                                                    if not mem[_3146 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3146 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3146 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3146 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3146 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3146 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3146 + ceil32(return_data.size) + 457
                                                                    u = _3146 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3146 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3146 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3146 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15707 = mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3146 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15869 = mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15869
                                                                    require return_data.size >= _15707 + (32 * _15869) + 32
                                                                    t = _3146 + ceil32(return_data.size) + _15707 + 293
                                                                    u = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15869:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_3377 + _3146 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3146 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_3146 + 168 len _3377 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_3146 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3146 + 232] = mem[idx + _3146 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3146 + 232]
                                                                if not mem[96]:
                                                                    mem[_3146 + 164] = 2
                                                                    mem[64] = _3146 + 260
                                                                    mem[_3146 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + 228] = address(cd[36])
                                                                    mem[_3146 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + 296] = 0
                                                                    mem[_3146 + 328] = 160
                                                                    mem[_3146 + 424] = 2
                                                                    s = 0
                                                                    t = _3146 + 456
                                                                    u = _3146 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + 360] = this.address
                                                                    mem[_3146 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3146 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15414 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15708 = mem[_15414]
                                                                    require mem[_15414] <= test266151307()
                                                                    require _15414 + mem[_15414] + 31 < _15414 + return_data.size
                                                                    _15870 = mem[_15414 + mem[_15414]]
                                                                    if mem[_15414 + mem[_15414]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15414 + ceil32(return_data.size) + ceil32(32 * mem[_15414 + mem[_15414]]) + 1 > test266151307() or ceil32(32 * mem[_15414 + mem[_15414]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15414 + ceil32(return_data.size) + ceil32(32 * mem[_15414 + mem[_15414]]) + 1
                                                                    mem[_15414 + ceil32(return_data.size)] = _15870
                                                                    require return_data.size >= _15708 + (32 * _15870) + 32
                                                                    t = _15414 + _15708 + 32
                                                                    u = _15414 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15870:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3146 + 164] = 2
                                                                    mem[64] = _3146 + 260
                                                                    mem[_3146 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + 228] = address(cd[36])
                                                                    mem[_3146 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + 296] = 0
                                                                    mem[_3146 + 328] = 160
                                                                    mem[_3146 + 424] = 2
                                                                    s = 0
                                                                    t = _3146 + 456
                                                                    u = _3146 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + 360] = this.address
                                                                    mem[_3146 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3146 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15415 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15709 = mem[_15415]
                                                                    require mem[_15415] <= test266151307()
                                                                    require _15415 + mem[_15415] + 31 < _15415 + return_data.size
                                                                    _15871 = mem[_15415 + mem[_15415]]
                                                                    if mem[_15415 + mem[_15415]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15415 + ceil32(return_data.size) + ceil32(32 * mem[_15415 + mem[_15415]]) + 1 > test266151307() or ceil32(32 * mem[_15415 + mem[_15415]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15415 + ceil32(return_data.size) + ceil32(32 * mem[_15415 + mem[_15415]]) + 1
                                                                    mem[_15415 + ceil32(return_data.size)] = _15871
                                                                    require return_data.size >= _15709 + (32 * _15871) + 32
                                                                    t = _15415 + _15709 + 32
                                                                    u = _15415 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15871:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_3146 + 164] = return_data.size
                                                                mem[_3146 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3146 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3146 + ceil32(return_data.size) + 233] = mem[idx + _3146 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3146 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_3146 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3146 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3146 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3146 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3146 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3146 + ceil32(return_data.size) + 457
                                                                    u = _3146 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3146 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3146 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3146 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15710 = mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3146 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15872 = mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15872
                                                                    require return_data.size >= _15710 + (32 * _15872) + 32
                                                                    t = _3146 + ceil32(return_data.size) + _15710 + 293
                                                                    u = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15872:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_3146 + 196] == bool(mem[_3146 + 196])
                                                                    if not mem[_3146 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3146 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3146 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3146 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3146 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3146 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3146 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3146 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3146 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3146 + ceil32(return_data.size) + 457
                                                                    u = _3146 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3146 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3146 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3146 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3146 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15711 = mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3146 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15873 = mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3146 + ceil32(return_data.size) + mem[_3146 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2833) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3146 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15873
                                                                    require return_data.size >= _15711 + (32 * _15873) + 32
                                                                    t = _3146 + ceil32(return_data.size) + _15711 + 293
                                                                    u = _3146 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15873:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                else:
                                                    t = 10
                                                    u = 1
                                                    s = mem[_2829 + 31 len 1]
                                                    while s > 1:
                                                        if t > -1 / t:
                                                            revert with 0, 17
                                                        if not bool(s):
                                                            t = t * t
                                                            u = u
                                                            s = uint255(s) * 0.5
                                                            continue 
                                                        t = t * t
                                                        u = t * u
                                                        s = uint255(s) * 0.5
                                                        continue 
                                                    if u > -1 / t:
                                                        revert with 0, 17
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and t * u > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]:
                                                        _9541 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _9542 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_9542 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_9542 + 36 len 28]
                                                        mem[64] = _9541 + 164
                                                        mem[_9541 + 100] = 32
                                                        mem[_9541 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _10197 = mem[_9542]
                                                        s = 0
                                                        while s < _10197:
                                                            mem[s + _9541 + 164] = mem[s + _9542 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_10197) <= _10197:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9541 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_9541 + 168 len _10197 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_9541 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9541 + 232] = mem[idx + _9541 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9541 + 232]
                                                                if not mem[96]:
                                                                    mem[_9541 + 164] = 2
                                                                    mem[64] = _9541 + 260
                                                                    mem[_9541 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + 228] = address(cd[36])
                                                                    mem[_9541 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + 296] = 0
                                                                    mem[_9541 + 328] = 160
                                                                    mem[_9541 + 424] = 2
                                                                    s = 0
                                                                    t = _9541 + 456
                                                                    u = _9541 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9541 + 360] = this.address
                                                                    mem[_9541 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9541 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20090 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20364 = mem[_20090]
                                                                    require mem[_20090] <= test266151307()
                                                                    require _20090 + mem[_20090] + 31 < _20090 + return_data.size
                                                                    _20500 = mem[_20090 + mem[_20090]]
                                                                    if mem[_20090 + mem[_20090]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20090 + ceil32(return_data.size) + ceil32(32 * mem[_20090 + mem[_20090]]) + 1 > test266151307() or ceil32(32 * mem[_20090 + mem[_20090]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20090 + ceil32(return_data.size) + ceil32(32 * mem[_20090 + mem[_20090]]) + 1
                                                                    mem[_20090 + ceil32(return_data.size)] = _20500
                                                                    require return_data.size >= _20364 + (32 * _20500) + 32
                                                                    t = _20090 + _20364 + 32
                                                                    u = _20090 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20500:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9541 + 164] = 2
                                                                    mem[64] = _9541 + 260
                                                                    mem[_9541 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + 228] = address(cd[36])
                                                                    mem[_9541 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + 296] = 0
                                                                    mem[_9541 + 328] = 160
                                                                    mem[_9541 + 424] = 2
                                                                    s = 0
                                                                    t = _9541 + 456
                                                                    u = _9541 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9541 + 360] = this.address
                                                                    mem[_9541 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9541 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20091 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20365 = mem[_20091]
                                                                    require mem[_20091] <= test266151307()
                                                                    require _20091 + mem[_20091] + 31 < _20091 + return_data.size
                                                                    _20501 = mem[_20091 + mem[_20091]]
                                                                    if mem[_20091 + mem[_20091]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20091 + ceil32(return_data.size) + ceil32(32 * mem[_20091 + mem[_20091]]) + 1 > test266151307() or ceil32(32 * mem[_20091 + mem[_20091]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20091 + ceil32(return_data.size) + ceil32(32 * mem[_20091 + mem[_20091]]) + 1
                                                                    mem[_20091 + ceil32(return_data.size)] = _20501
                                                                    require return_data.size >= _20365 + (32 * _20501) + 32
                                                                    t = _20091 + _20365 + 32
                                                                    u = _20091 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20501:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_9541 + 164] = return_data.size
                                                                mem[_9541 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9541 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9541 + ceil32(return_data.size) + 233] = mem[idx + _9541 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9541 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_9541 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9541 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9541 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9541 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9541 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9541 + ceil32(return_data.size) + 457
                                                                    w = _9541 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9541 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9541 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9541 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9541 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20366 = mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9541 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20502 = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20366 + (32 * _20502) + 32
                                                                    t = _9541 + ceil32(return_data.size) + _20366 + 293
                                                                    u = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20502:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_9541 + 196] == bool(mem[_9541 + 196])
                                                                    if not mem[_9541 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9541 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9541 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9541 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9541 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9541 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9541 + ceil32(return_data.size) + 457
                                                                    w = _9541 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9541 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9541 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9541 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9541 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20367 = mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9541 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20503 = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20367 + (32 * _20503) + 32
                                                                    t = _9541 + ceil32(return_data.size) + _20367 + 293
                                                                    u = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20503:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_10197 + _9541 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9541 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_9541 + 168 len _10197 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_9541 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9541 + 232] = mem[idx + _9541 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9541 + 232]
                                                                if not mem[96]:
                                                                    mem[_9541 + 164] = 2
                                                                    mem[64] = _9541 + 260
                                                                    mem[_9541 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + 228] = address(cd[36])
                                                                    mem[_9541 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + 296] = 0
                                                                    mem[_9541 + 328] = 160
                                                                    mem[_9541 + 424] = 2
                                                                    s = 0
                                                                    t = _9541 + 456
                                                                    u = _9541 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9541 + 360] = this.address
                                                                    mem[_9541 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9541 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20098 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20368 = mem[_20098]
                                                                    require mem[_20098] <= test266151307()
                                                                    require _20098 + mem[_20098] + 31 < _20098 + return_data.size
                                                                    _20504 = mem[_20098 + mem[_20098]]
                                                                    if mem[_20098 + mem[_20098]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20098 + ceil32(return_data.size) + ceil32(32 * mem[_20098 + mem[_20098]]) + 1 > test266151307() or ceil32(32 * mem[_20098 + mem[_20098]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20098 + ceil32(return_data.size) + ceil32(32 * mem[_20098 + mem[_20098]]) + 1
                                                                    mem[_20098 + ceil32(return_data.size)] = _20504
                                                                    require return_data.size >= _20368 + (32 * _20504) + 32
                                                                    t = _20098 + _20368 + 32
                                                                    u = _20098 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20504:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9541 + 164] = 2
                                                                    mem[64] = _9541 + 260
                                                                    mem[_9541 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + 228] = address(cd[36])
                                                                    mem[_9541 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + 296] = 0
                                                                    mem[_9541 + 328] = 160
                                                                    mem[_9541 + 424] = 2
                                                                    s = 0
                                                                    t = _9541 + 456
                                                                    u = _9541 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9541 + 360] = this.address
                                                                    mem[_9541 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9541 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20099 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20369 = mem[_20099]
                                                                    require mem[_20099] <= test266151307()
                                                                    require _20099 + mem[_20099] + 31 < _20099 + return_data.size
                                                                    _20505 = mem[_20099 + mem[_20099]]
                                                                    if mem[_20099 + mem[_20099]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20099 + ceil32(return_data.size) + ceil32(32 * mem[_20099 + mem[_20099]]) + 1 > test266151307() or ceil32(32 * mem[_20099 + mem[_20099]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20099 + ceil32(return_data.size) + ceil32(32 * mem[_20099 + mem[_20099]]) + 1
                                                                    mem[_20099 + ceil32(return_data.size)] = _20505
                                                                    require return_data.size >= _20369 + (32 * _20505) + 32
                                                                    t = _20099 + _20369 + 32
                                                                    u = _20099 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20505:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_9541 + 164] = return_data.size
                                                                mem[_9541 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9541 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9541 + ceil32(return_data.size) + 233] = mem[idx + _9541 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9541 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_9541 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9541 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9541 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9541 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9541 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9541 + ceil32(return_data.size) + 457
                                                                    w = _9541 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9541 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9541 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9541 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9541 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20370 = mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9541 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20506 = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20370 + (32 * _20506) + 32
                                                                    t = _9541 + ceil32(return_data.size) + _20370 + 293
                                                                    u = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20506:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_9541 + 196] == bool(mem[_9541 + 196])
                                                                    if not mem[_9541 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9541 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9541 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9541 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9541 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9541 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9541 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9541 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9541 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9541 + ceil32(return_data.size) + 457
                                                                    w = _9541 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9541 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9541 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9541 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9541 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20371 = mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9541 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20507 = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9541 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9541 + ceil32(return_data.size) + mem[_9541 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20371 + (32 * _20507) + 32
                                                                    t = _9541 + ceil32(return_data.size) + _20371 + 293
                                                                    u = _9541 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20507:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9557 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_9557]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _10289 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _10290 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_10290 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_10290 + 36 len 28]
                                                        mem[64] = _10289 + 164
                                                        mem[_10289 + 100] = 32
                                                        mem[_10289 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _10887 = mem[_10290]
                                                        s = 0
                                                        while s < _10887:
                                                            mem[s + _10289 + 164] = mem[s + _10290 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_10887) <= _10887:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10289 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_10289 + 168 len _10887 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_10289 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10289 + 232] = mem[idx + _10289 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10289 + 232]
                                                                if not mem[96]:
                                                                    mem[_10289 + 164] = 2
                                                                    mem[64] = _10289 + 260
                                                                    mem[_10289 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + 228] = address(cd[36])
                                                                    mem[_10289 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + 296] = 0
                                                                    mem[_10289 + 328] = 160
                                                                    mem[_10289 + 424] = 2
                                                                    s = 0
                                                                    t = _10289 + 456
                                                                    u = _10289 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10289 + 360] = this.address
                                                                    mem[_10289 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10289 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20106 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20372 = mem[_20106]
                                                                    require mem[_20106] <= test266151307()
                                                                    require _20106 + mem[_20106] + 31 < _20106 + return_data.size
                                                                    _20508 = mem[_20106 + mem[_20106]]
                                                                    if mem[_20106 + mem[_20106]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20106 + ceil32(return_data.size) + ceil32(32 * mem[_20106 + mem[_20106]]) + 1 > test266151307() or ceil32(32 * mem[_20106 + mem[_20106]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20106 + ceil32(return_data.size) + ceil32(32 * mem[_20106 + mem[_20106]]) + 1
                                                                    mem[_20106 + ceil32(return_data.size)] = _20508
                                                                    require return_data.size >= _20372 + (32 * _20508) + 32
                                                                    t = _20106 + _20372 + 32
                                                                    u = _20106 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20508:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10289 + 164] = 2
                                                                    mem[64] = _10289 + 260
                                                                    mem[_10289 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + 228] = address(cd[36])
                                                                    mem[_10289 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + 296] = 0
                                                                    mem[_10289 + 328] = 160
                                                                    mem[_10289 + 424] = 2
                                                                    s = 0
                                                                    t = _10289 + 456
                                                                    u = _10289 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10289 + 360] = this.address
                                                                    mem[_10289 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10289 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20107 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20373 = mem[_20107]
                                                                    require mem[_20107] <= test266151307()
                                                                    require _20107 + mem[_20107] + 31 < _20107 + return_data.size
                                                                    _20509 = mem[_20107 + mem[_20107]]
                                                                    if mem[_20107 + mem[_20107]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20107 + ceil32(return_data.size) + ceil32(32 * mem[_20107 + mem[_20107]]) + 1 > test266151307() or ceil32(32 * mem[_20107 + mem[_20107]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20107 + ceil32(return_data.size) + ceil32(32 * mem[_20107 + mem[_20107]]) + 1
                                                                    mem[_20107 + ceil32(return_data.size)] = _20509
                                                                    require return_data.size >= _20373 + (32 * _20509) + 32
                                                                    t = _20107 + _20373 + 32
                                                                    u = _20107 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20509:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_10289 + 164] = return_data.size
                                                                mem[_10289 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10289 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10289 + ceil32(return_data.size) + 233] = mem[idx + _10289 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10289 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_10289 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10289 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10289 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10289 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10289 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10289 + ceil32(return_data.size) + 457
                                                                    w = _10289 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10289 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10289 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10289 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10289 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20374 = mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10289 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20510 = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20374 + (32 * _20510) + 32
                                                                    t = _10289 + ceil32(return_data.size) + _20374 + 293
                                                                    u = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20510:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_10289 + 196] == bool(mem[_10289 + 196])
                                                                    if not mem[_10289 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10289 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10289 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10289 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10289 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10289 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10289 + ceil32(return_data.size) + 457
                                                                    w = _10289 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10289 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10289 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10289 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10289 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20375 = mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10289 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20511 = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20375 + (32 * _20511) + 32
                                                                    t = _10289 + ceil32(return_data.size) + _20375 + 293
                                                                    u = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20511:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_10887 + _10289 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10289 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_10289 + 168 len _10887 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_10289 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10289 + 232] = mem[idx + _10289 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10289 + 232]
                                                                if not mem[96]:
                                                                    mem[_10289 + 164] = 2
                                                                    mem[64] = _10289 + 260
                                                                    mem[_10289 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + 228] = address(cd[36])
                                                                    mem[_10289 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + 296] = 0
                                                                    mem[_10289 + 328] = 160
                                                                    mem[_10289 + 424] = 2
                                                                    s = 0
                                                                    t = _10289 + 456
                                                                    u = _10289 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10289 + 360] = this.address
                                                                    mem[_10289 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10289 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20114 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20376 = mem[_20114]
                                                                    require mem[_20114] <= test266151307()
                                                                    require _20114 + mem[_20114] + 31 < _20114 + return_data.size
                                                                    _20512 = mem[_20114 + mem[_20114]]
                                                                    if mem[_20114 + mem[_20114]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20114 + ceil32(return_data.size) + ceil32(32 * mem[_20114 + mem[_20114]]) + 1 > test266151307() or ceil32(32 * mem[_20114 + mem[_20114]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20114 + ceil32(return_data.size) + ceil32(32 * mem[_20114 + mem[_20114]]) + 1
                                                                    mem[_20114 + ceil32(return_data.size)] = _20512
                                                                    require return_data.size >= _20376 + (32 * _20512) + 32
                                                                    t = _20114 + _20376 + 32
                                                                    u = _20114 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20512:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10289 + 164] = 2
                                                                    mem[64] = _10289 + 260
                                                                    mem[_10289 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + 228] = address(cd[36])
                                                                    mem[_10289 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + 296] = 0
                                                                    mem[_10289 + 328] = 160
                                                                    mem[_10289 + 424] = 2
                                                                    s = 0
                                                                    t = _10289 + 456
                                                                    u = _10289 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10289 + 360] = this.address
                                                                    mem[_10289 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10289 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20115 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20377 = mem[_20115]
                                                                    require mem[_20115] <= test266151307()
                                                                    require _20115 + mem[_20115] + 31 < _20115 + return_data.size
                                                                    _20513 = mem[_20115 + mem[_20115]]
                                                                    if mem[_20115 + mem[_20115]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20115 + ceil32(return_data.size) + ceil32(32 * mem[_20115 + mem[_20115]]) + 1 > test266151307() or ceil32(32 * mem[_20115 + mem[_20115]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20115 + ceil32(return_data.size) + ceil32(32 * mem[_20115 + mem[_20115]]) + 1
                                                                    mem[_20115 + ceil32(return_data.size)] = _20513
                                                                    require return_data.size >= _20377 + (32 * _20513) + 32
                                                                    t = _20115 + _20377 + 32
                                                                    u = _20115 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20513:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_10289 + 164] = return_data.size
                                                                mem[_10289 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10289 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10289 + ceil32(return_data.size) + 233] = mem[idx + _10289 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10289 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_10289 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10289 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10289 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10289 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10289 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10289 + ceil32(return_data.size) + 457
                                                                    w = _10289 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10289 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10289 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10289 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10289 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20378 = mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10289 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20514 = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20378 + (32 * _20514) + 32
                                                                    t = _10289 + ceil32(return_data.size) + _20378 + 293
                                                                    u = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20514:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_10289 + 196] == bool(mem[_10289 + 196])
                                                                    if not mem[_10289 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10289 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10289 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10289 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10289 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10289 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10289 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10289 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10289 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10289 + ceil32(return_data.size) + 457
                                                                    w = _10289 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10289 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10289 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10289 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10289 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20379 = mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10289 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20515 = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10289 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10289 + ceil32(return_data.size) + mem[_10289 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20379 + (32 * _20515) + 32
                                                                    t = _10289 + ceil32(return_data.size) + _20379 + 293
                                                                    u = _10289 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20515:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[32] = 1
                                            sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])] = 1
                                            if sub_8cf086ad > -2:
                                                revert with 0, 17
                                            sub_8cf086ad++
                                    else:
                                        t = 10
                                        u = 1
                                        s = mem[_2813 + 31 len 1]
                                        while s > 1:
                                            if t > -1 / t:
                                                revert with 0, 17
                                            if not bool(s):
                                                t = t * t
                                                u = u
                                                s = uint255(s) * 0.5
                                                continue 
                                            t = t * t
                                            u = t * u
                                            s = uint255(s) * 0.5
                                            continue 
                                        if u > -1 / t:
                                            revert with 0, 17
                                        if Mask(112, 0, _2802) and cd[((32 * idx) + cd[100] + 36)] > -1 / Mask(112, 0, _2802):
                                            revert with 0, 17
                                        if not t * u:
                                            revert with 0, 18
                                        if cd[196] <= Mask(112, 0, _2802) * cd[((32 * idx) + cd[100] + 36)] / t * u:
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            if idx >= ('cd', 100).length:
                                                revert with 0, 50
                                            if idx >= ('cd', 132).length:
                                                revert with 0, 50
                                            if cd[164] and cd[((32 * idx) + cd[132] + 36)] > -1 / cd[164]:
                                                revert with 0, 17
                                            require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                            staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _11413 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _11575 = mem[_11413]
                                            require mem[_11413] == mem[_11413 + 31 len 1]
                                            if not mem[_11413 + 31 len 1]:
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 1 > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]:
                                                    _12589 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _12590 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_12590 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12590 + 36 len 28]
                                                    mem[64] = _12589 + 164
                                                    mem[_12589 + 100] = 32
                                                    mem[_12589 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _12793 = mem[_12590]
                                                    s = 0
                                                    while s < _12793:
                                                        mem[s + _12589 + 164] = mem[s + _12590 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_12793) <= _12793:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12589 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12589 + 168 len _12793 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12589 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12589 + 232] = mem[idx + _12589 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12589 + 232]
                                                            if not mem[96]:
                                                                mem[_12589 + 164] = 2
                                                                mem[64] = _12589 + 260
                                                                mem[_12589 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + 228] = address(cd[36])
                                                                mem[_12589 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + 296] = 0
                                                                mem[_12589 + 328] = 160
                                                                mem[_12589 + 424] = 2
                                                                s = 0
                                                                t = _12589 + 456
                                                                u = _12589 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + 360] = this.address
                                                                mem[_12589 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12589 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20058 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20348 = mem[_20058]
                                                                require mem[_20058] <= test266151307()
                                                                require _20058 + mem[_20058] + 31 < _20058 + return_data.size
                                                                _20484 = mem[_20058 + mem[_20058]]
                                                                if mem[_20058 + mem[_20058]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20058 + ceil32(return_data.size) + ceil32(32 * mem[_20058 + mem[_20058]]) + 1 > test266151307() or ceil32(32 * mem[_20058 + mem[_20058]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20058 + ceil32(return_data.size) + ceil32(32 * mem[_20058 + mem[_20058]]) + 1
                                                                mem[_20058 + ceil32(return_data.size)] = _20484
                                                                require return_data.size >= _20348 + (32 * _20484) + 32
                                                                t = _20058 + _20348 + 32
                                                                u = _20058 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20484:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12589 + 164] = 2
                                                                mem[64] = _12589 + 260
                                                                mem[_12589 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + 228] = address(cd[36])
                                                                mem[_12589 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + 296] = 0
                                                                mem[_12589 + 328] = 160
                                                                mem[_12589 + 424] = 2
                                                                s = 0
                                                                t = _12589 + 456
                                                                u = _12589 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + 360] = this.address
                                                                mem[_12589 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12589 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20059 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20349 = mem[_20059]
                                                                require mem[_20059] <= test266151307()
                                                                require _20059 + mem[_20059] + 31 < _20059 + return_data.size
                                                                _20485 = mem[_20059 + mem[_20059]]
                                                                if mem[_20059 + mem[_20059]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20059 + ceil32(return_data.size) + ceil32(32 * mem[_20059 + mem[_20059]]) + 1 > test266151307() or ceil32(32 * mem[_20059 + mem[_20059]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20059 + ceil32(return_data.size) + ceil32(32 * mem[_20059 + mem[_20059]]) + 1
                                                                mem[_20059 + ceil32(return_data.size)] = _20485
                                                                require return_data.size >= _20349 + (32 * _20485) + 32
                                                                t = _20059 + _20349 + 32
                                                                u = _20059 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20485:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12589 + 164] = return_data.size
                                                            mem[_12589 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12589 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12589 + ceil32(return_data.size) + 233] = mem[idx + _12589 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12589 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12589 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12589 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12589 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12589 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12589 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12589 + ceil32(return_data.size) + 457
                                                                u = _12589 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12589 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12589 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12589 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20350 = mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12589 + ceil32(return_data.size) + return_data.size + 261
                                                                _20486 = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20350 + (32 * _20486) + 32
                                                                t = _12589 + ceil32(return_data.size) + _20350 + 293
                                                                u = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20486:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12589 + 196] == bool(mem[_12589 + 196])
                                                                if not mem[_12589 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12589 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12589 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12589 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12589 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12589 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12589 + ceil32(return_data.size) + 457
                                                                u = _12589 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12589 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12589 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12589 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20351 = mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12589 + ceil32(return_data.size) + return_data.size + 261
                                                                _20487 = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20351 + (32 * _20487) + 32
                                                                t = _12589 + ceil32(return_data.size) + _20351 + 293
                                                                u = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20487:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_12793 + _12589 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12589 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12589 + 168 len _12793 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12589 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12589 + 232] = mem[idx + _12589 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12589 + 232]
                                                            if not mem[96]:
                                                                mem[_12589 + 164] = 2
                                                                mem[64] = _12589 + 260
                                                                mem[_12589 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + 228] = address(cd[36])
                                                                mem[_12589 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + 296] = 0
                                                                mem[_12589 + 328] = 160
                                                                mem[_12589 + 424] = 2
                                                                s = 0
                                                                t = _12589 + 456
                                                                u = _12589 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + 360] = this.address
                                                                mem[_12589 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12589 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20066 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20352 = mem[_20066]
                                                                require mem[_20066] <= test266151307()
                                                                require _20066 + mem[_20066] + 31 < _20066 + return_data.size
                                                                _20488 = mem[_20066 + mem[_20066]]
                                                                if mem[_20066 + mem[_20066]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20066 + ceil32(return_data.size) + ceil32(32 * mem[_20066 + mem[_20066]]) + 1 > test266151307() or ceil32(32 * mem[_20066 + mem[_20066]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20066 + ceil32(return_data.size) + ceil32(32 * mem[_20066 + mem[_20066]]) + 1
                                                                mem[_20066 + ceil32(return_data.size)] = _20488
                                                                require return_data.size >= _20352 + (32 * _20488) + 32
                                                                t = _20066 + _20352 + 32
                                                                u = _20066 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20488:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12589 + 164] = 2
                                                                mem[64] = _12589 + 260
                                                                mem[_12589 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + 228] = address(cd[36])
                                                                mem[_12589 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + 296] = 0
                                                                mem[_12589 + 328] = 160
                                                                mem[_12589 + 424] = 2
                                                                s = 0
                                                                t = _12589 + 456
                                                                u = _12589 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + 360] = this.address
                                                                mem[_12589 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12589 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20067 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20353 = mem[_20067]
                                                                require mem[_20067] <= test266151307()
                                                                require _20067 + mem[_20067] + 31 < _20067 + return_data.size
                                                                _20489 = mem[_20067 + mem[_20067]]
                                                                if mem[_20067 + mem[_20067]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20067 + ceil32(return_data.size) + ceil32(32 * mem[_20067 + mem[_20067]]) + 1 > test266151307() or ceil32(32 * mem[_20067 + mem[_20067]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20067 + ceil32(return_data.size) + ceil32(32 * mem[_20067 + mem[_20067]]) + 1
                                                                mem[_20067 + ceil32(return_data.size)] = _20489
                                                                require return_data.size >= _20353 + (32 * _20489) + 32
                                                                t = _20067 + _20353 + 32
                                                                u = _20067 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20489:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12589 + 164] = return_data.size
                                                            mem[_12589 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12589 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12589 + ceil32(return_data.size) + 233] = mem[idx + _12589 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12589 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12589 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12589 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12589 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12589 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12589 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12589 + ceil32(return_data.size) + 457
                                                                u = _12589 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12589 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12589 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12589 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20354 = mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12589 + ceil32(return_data.size) + return_data.size + 261
                                                                _20490 = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20354 + (32 * _20490) + 32
                                                                t = _12589 + ceil32(return_data.size) + _20354 + 293
                                                                u = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20490:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12589 + 196] == bool(mem[_12589 + 196])
                                                                if not mem[_12589 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12589 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12589 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12589 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12589 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12589 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12589 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12589 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12589 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12589 + ceil32(return_data.size) + 457
                                                                u = _12589 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12589 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12589 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12589 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12589 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20355 = mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12589 + ceil32(return_data.size) + return_data.size + 261
                                                                _20491 = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12589 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12589 + ceil32(return_data.size) + mem[_12589 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20355 + (32 * _20491) + 32
                                                                t = _12589 + ceil32(return_data.size) + _20355 + 293
                                                                u = _12589 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20491:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _12645 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_12645]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _12834 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _12835 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_12835 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12835 + 36 len 28]
                                                    mem[64] = _12834 + 164
                                                    mem[_12834 + 100] = 32
                                                    mem[_12834 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _12988 = mem[_12835]
                                                    s = 0
                                                    while s < _12988:
                                                        mem[s + _12834 + 164] = mem[s + _12835 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_12988) <= _12988:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12834 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12834 + 168 len _12988 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12834 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12834 + 232] = mem[idx + _12834 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12834 + 232]
                                                            if not mem[96]:
                                                                mem[_12834 + 164] = 2
                                                                mem[64] = _12834 + 260
                                                                mem[_12834 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + 228] = address(cd[36])
                                                                mem[_12834 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + 296] = 0
                                                                mem[_12834 + 328] = 160
                                                                mem[_12834 + 424] = 2
                                                                s = 0
                                                                t = _12834 + 456
                                                                u = _12834 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + 360] = this.address
                                                                mem[_12834 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12834 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20074 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20356 = mem[_20074]
                                                                require mem[_20074] <= test266151307()
                                                                require _20074 + mem[_20074] + 31 < _20074 + return_data.size
                                                                _20492 = mem[_20074 + mem[_20074]]
                                                                if mem[_20074 + mem[_20074]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20074 + ceil32(return_data.size) + ceil32(32 * mem[_20074 + mem[_20074]]) + 1 > test266151307() or ceil32(32 * mem[_20074 + mem[_20074]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20074 + ceil32(return_data.size) + ceil32(32 * mem[_20074 + mem[_20074]]) + 1
                                                                mem[_20074 + ceil32(return_data.size)] = _20492
                                                                require return_data.size >= _20356 + (32 * _20492) + 32
                                                                t = _20074 + _20356 + 32
                                                                u = _20074 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20492:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12834 + 164] = 2
                                                                mem[64] = _12834 + 260
                                                                mem[_12834 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + 228] = address(cd[36])
                                                                mem[_12834 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + 296] = 0
                                                                mem[_12834 + 328] = 160
                                                                mem[_12834 + 424] = 2
                                                                s = 0
                                                                t = _12834 + 456
                                                                u = _12834 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + 360] = this.address
                                                                mem[_12834 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12834 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20075 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20357 = mem[_20075]
                                                                require mem[_20075] <= test266151307()
                                                                require _20075 + mem[_20075] + 31 < _20075 + return_data.size
                                                                _20493 = mem[_20075 + mem[_20075]]
                                                                if mem[_20075 + mem[_20075]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20075 + ceil32(return_data.size) + ceil32(32 * mem[_20075 + mem[_20075]]) + 1 > test266151307() or ceil32(32 * mem[_20075 + mem[_20075]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20075 + ceil32(return_data.size) + ceil32(32 * mem[_20075 + mem[_20075]]) + 1
                                                                mem[_20075 + ceil32(return_data.size)] = _20493
                                                                require return_data.size >= _20357 + (32 * _20493) + 32
                                                                t = _20075 + _20357 + 32
                                                                u = _20075 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20493:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12834 + 164] = return_data.size
                                                            mem[_12834 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12834 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12834 + ceil32(return_data.size) + 233] = mem[idx + _12834 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12834 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12834 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12834 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12834 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12834 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12834 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12834 + ceil32(return_data.size) + 457
                                                                u = _12834 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12834 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12834 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12834 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20358 = mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12834 + ceil32(return_data.size) + return_data.size + 261
                                                                _20494 = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20358 + (32 * _20494) + 32
                                                                t = _12834 + ceil32(return_data.size) + _20358 + 293
                                                                u = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20494:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12834 + 196] == bool(mem[_12834 + 196])
                                                                if not mem[_12834 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12834 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12834 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12834 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12834 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12834 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12834 + ceil32(return_data.size) + 457
                                                                u = _12834 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12834 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12834 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12834 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20359 = mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12834 + ceil32(return_data.size) + return_data.size + 261
                                                                _20495 = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20359 + (32 * _20495) + 32
                                                                t = _12834 + ceil32(return_data.size) + _20359 + 293
                                                                u = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20495:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_12988 + _12834 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12834 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12834 + 168 len _12988 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12834 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12834 + 232] = mem[idx + _12834 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12834 + 232]
                                                            if not mem[96]:
                                                                mem[_12834 + 164] = 2
                                                                mem[64] = _12834 + 260
                                                                mem[_12834 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + 228] = address(cd[36])
                                                                mem[_12834 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + 296] = 0
                                                                mem[_12834 + 328] = 160
                                                                mem[_12834 + 424] = 2
                                                                s = 0
                                                                t = _12834 + 456
                                                                u = _12834 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + 360] = this.address
                                                                mem[_12834 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12834 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20082 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20360 = mem[_20082]
                                                                require mem[_20082] <= test266151307()
                                                                require _20082 + mem[_20082] + 31 < _20082 + return_data.size
                                                                _20496 = mem[_20082 + mem[_20082]]
                                                                if mem[_20082 + mem[_20082]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20082 + ceil32(return_data.size) + ceil32(32 * mem[_20082 + mem[_20082]]) + 1 > test266151307() or ceil32(32 * mem[_20082 + mem[_20082]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20082 + ceil32(return_data.size) + ceil32(32 * mem[_20082 + mem[_20082]]) + 1
                                                                mem[_20082 + ceil32(return_data.size)] = _20496
                                                                require return_data.size >= _20360 + (32 * _20496) + 32
                                                                t = _20082 + _20360 + 32
                                                                u = _20082 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20496:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12834 + 164] = 2
                                                                mem[64] = _12834 + 260
                                                                mem[_12834 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + 228] = address(cd[36])
                                                                mem[_12834 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + 296] = 0
                                                                mem[_12834 + 328] = 160
                                                                mem[_12834 + 424] = 2
                                                                s = 0
                                                                t = _12834 + 456
                                                                u = _12834 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + 360] = this.address
                                                                mem[_12834 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12834 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20083 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20361 = mem[_20083]
                                                                require mem[_20083] <= test266151307()
                                                                require _20083 + mem[_20083] + 31 < _20083 + return_data.size
                                                                _20497 = mem[_20083 + mem[_20083]]
                                                                if mem[_20083 + mem[_20083]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20083 + ceil32(return_data.size) + ceil32(32 * mem[_20083 + mem[_20083]]) + 1 > test266151307() or ceil32(32 * mem[_20083 + mem[_20083]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20083 + ceil32(return_data.size) + ceil32(32 * mem[_20083 + mem[_20083]]) + 1
                                                                mem[_20083 + ceil32(return_data.size)] = _20497
                                                                require return_data.size >= _20361 + (32 * _20497) + 32
                                                                t = _20083 + _20361 + 32
                                                                u = _20083 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20497:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12834 + 164] = return_data.size
                                                            mem[_12834 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12834 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12834 + ceil32(return_data.size) + 233] = mem[idx + _12834 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12834 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12834 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12834 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12834 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12834 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12834 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12834 + ceil32(return_data.size) + 457
                                                                u = _12834 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12834 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12834 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12834 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20362 = mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12834 + ceil32(return_data.size) + return_data.size + 261
                                                                _20498 = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20362 + (32 * _20498) + 32
                                                                t = _12834 + ceil32(return_data.size) + _20362 + 293
                                                                u = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20498:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12834 + 196] == bool(mem[_12834 + 196])
                                                                if not mem[_12834 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12834 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12834 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12834 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12834 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12834 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12834 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12834 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12834 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12834 + ceil32(return_data.size) + 457
                                                                u = _12834 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12834 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12834 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12834 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12834 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20363 = mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12834 + ceil32(return_data.size) + return_data.size + 261
                                                                _20499 = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12834 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12834 + ceil32(return_data.size) + mem[_12834 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20363 + (32 * _20499) + 32
                                                                t = _12834 + ceil32(return_data.size) + _20363 + 293
                                                                u = _12834 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20499:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                            else:
                                                if bool(bool(mem[_11413 + 31 len 1] < 78)) or bool(bool(mem[_11413 + 31 len 1] < 32)):
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 10^mem[_11413 + 31 len 1] > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^mem[_11413 + 31 len 1] / cd[((32 * idx) + cd[100] + 36)]:
                                                        _12789 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                        _12790 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_12790 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12790 + 36 len 28]
                                                        mem[64] = _12789 + 164
                                                        mem[_12789 + 100] = 32
                                                        mem[_12789 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _12938 = mem[_12790]
                                                        s = 0
                                                        while s < _12938:
                                                            mem[s + _12789 + 164] = mem[s + _12790 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_12938) <= _12938:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12789 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12789 + 168 len _12938 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12789 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12789 + 232] = mem[idx + _12789 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12789 + 232]
                                                                if not mem[96]:
                                                                    mem[_12789 + 164] = 2
                                                                    mem[64] = _12789 + 260
                                                                    mem[_12789 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + 228] = address(cd[36])
                                                                    mem[_12789 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + 296] = 0
                                                                    mem[_12789 + 328] = 160
                                                                    mem[_12789 + 424] = 2
                                                                    s = 0
                                                                    t = _12789 + 456
                                                                    u = _12789 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + 360] = this.address
                                                                    mem[_12789 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12789 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20026 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20332 = mem[_20026]
                                                                    require mem[_20026] <= test266151307()
                                                                    require _20026 + mem[_20026] + 31 < _20026 + return_data.size
                                                                    _20468 = mem[_20026 + mem[_20026]]
                                                                    if mem[_20026 + mem[_20026]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20026 + ceil32(return_data.size) + ceil32(32 * mem[_20026 + mem[_20026]]) + 1 > test266151307() or ceil32(32 * mem[_20026 + mem[_20026]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20026 + ceil32(return_data.size) + ceil32(32 * mem[_20026 + mem[_20026]]) + 1
                                                                    mem[_20026 + ceil32(return_data.size)] = _20468
                                                                    require return_data.size >= _20332 + (32 * _20468) + 32
                                                                    t = _20026 + _20332 + 32
                                                                    u = _20026 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20468:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12789 + 164] = 2
                                                                    mem[64] = _12789 + 260
                                                                    mem[_12789 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + 228] = address(cd[36])
                                                                    mem[_12789 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + 296] = 0
                                                                    mem[_12789 + 328] = 160
                                                                    mem[_12789 + 424] = 2
                                                                    s = 0
                                                                    t = _12789 + 456
                                                                    u = _12789 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + 360] = this.address
                                                                    mem[_12789 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12789 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20027 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20333 = mem[_20027]
                                                                    require mem[_20027] <= test266151307()
                                                                    require _20027 + mem[_20027] + 31 < _20027 + return_data.size
                                                                    _20469 = mem[_20027 + mem[_20027]]
                                                                    if mem[_20027 + mem[_20027]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20027 + ceil32(return_data.size) + ceil32(32 * mem[_20027 + mem[_20027]]) + 1 > test266151307() or ceil32(32 * mem[_20027 + mem[_20027]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20027 + ceil32(return_data.size) + ceil32(32 * mem[_20027 + mem[_20027]]) + 1
                                                                    mem[_20027 + ceil32(return_data.size)] = _20469
                                                                    require return_data.size >= _20333 + (32 * _20469) + 32
                                                                    t = _20027 + _20333 + 32
                                                                    u = _20027 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20469:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12789 + 164] = return_data.size
                                                                mem[_12789 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12789 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12789 + ceil32(return_data.size) + 233] = mem[idx + _12789 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12789 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12789 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12789 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12789 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12789 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12789 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12789 + ceil32(return_data.size) + 457
                                                                    u = _12789 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12789 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12789 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12789 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20334 = mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12789 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20470 = mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20470
                                                                    require return_data.size >= _20334 + (32 * _20470) + 32
                                                                    t = _12789 + ceil32(return_data.size) + _20334 + 293
                                                                    u = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20470:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12789 + 196] == bool(mem[_12789 + 196])
                                                                    if not mem[_12789 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12789 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12789 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12789 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12789 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12789 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12789 + ceil32(return_data.size) + 457
                                                                    u = _12789 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12789 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12789 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12789 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20335 = mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12789 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20471 = mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20471
                                                                    require return_data.size >= _20335 + (32 * _20471) + 32
                                                                    t = _12789 + ceil32(return_data.size) + _20335 + 293
                                                                    u = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20471:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_12938 + _12789 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12789 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12789 + 168 len _12938 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12789 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12789 + 232] = mem[idx + _12789 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12789 + 232]
                                                                if not mem[96]:
                                                                    mem[_12789 + 164] = 2
                                                                    mem[64] = _12789 + 260
                                                                    mem[_12789 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + 228] = address(cd[36])
                                                                    mem[_12789 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + 296] = 0
                                                                    mem[_12789 + 328] = 160
                                                                    mem[_12789 + 424] = 2
                                                                    s = 0
                                                                    t = _12789 + 456
                                                                    u = _12789 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + 360] = this.address
                                                                    mem[_12789 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12789 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20034 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20336 = mem[_20034]
                                                                    require mem[_20034] <= test266151307()
                                                                    require _20034 + mem[_20034] + 31 < _20034 + return_data.size
                                                                    _20472 = mem[_20034 + mem[_20034]]
                                                                    if mem[_20034 + mem[_20034]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20034 + ceil32(return_data.size) + ceil32(32 * mem[_20034 + mem[_20034]]) + 1 > test266151307() or ceil32(32 * mem[_20034 + mem[_20034]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20034 + ceil32(return_data.size) + ceil32(32 * mem[_20034 + mem[_20034]]) + 1
                                                                    mem[_20034 + ceil32(return_data.size)] = _20472
                                                                    require return_data.size >= _20336 + (32 * _20472) + 32
                                                                    t = _20034 + _20336 + 32
                                                                    u = _20034 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20472:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12789 + 164] = 2
                                                                    mem[64] = _12789 + 260
                                                                    mem[_12789 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + 228] = address(cd[36])
                                                                    mem[_12789 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + 296] = 0
                                                                    mem[_12789 + 328] = 160
                                                                    mem[_12789 + 424] = 2
                                                                    s = 0
                                                                    t = _12789 + 456
                                                                    u = _12789 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + 360] = this.address
                                                                    mem[_12789 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12789 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20035 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20337 = mem[_20035]
                                                                    require mem[_20035] <= test266151307()
                                                                    require _20035 + mem[_20035] + 31 < _20035 + return_data.size
                                                                    _20473 = mem[_20035 + mem[_20035]]
                                                                    if mem[_20035 + mem[_20035]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20035 + ceil32(return_data.size) + ceil32(32 * mem[_20035 + mem[_20035]]) + 1 > test266151307() or ceil32(32 * mem[_20035 + mem[_20035]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20035 + ceil32(return_data.size) + ceil32(32 * mem[_20035 + mem[_20035]]) + 1
                                                                    mem[_20035 + ceil32(return_data.size)] = _20473
                                                                    require return_data.size >= _20337 + (32 * _20473) + 32
                                                                    t = _20035 + _20337 + 32
                                                                    u = _20035 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20473:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12789 + 164] = return_data.size
                                                                mem[_12789 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12789 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12789 + ceil32(return_data.size) + 233] = mem[idx + _12789 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12789 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12789 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12789 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12789 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12789 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12789 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12789 + ceil32(return_data.size) + 457
                                                                    u = _12789 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12789 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12789 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12789 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20338 = mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12789 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20474 = mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20474
                                                                    require return_data.size >= _20338 + (32 * _20474) + 32
                                                                    t = _12789 + ceil32(return_data.size) + _20338 + 293
                                                                    u = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20474:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12789 + 196] == bool(mem[_12789 + 196])
                                                                    if not mem[_12789 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12789 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12789 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12789 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12789 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12789 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12789 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12789 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12789 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12789 + ceil32(return_data.size) + 457
                                                                    u = _12789 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12789 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12789 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12789 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12789 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20339 = mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12789 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20475 = mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12789 + ceil32(return_data.size) + mem[_12789 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12789 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20475
                                                                    require return_data.size >= _20339 + (32 * _20475) + 32
                                                                    t = _12789 + ceil32(return_data.size) + _20339 + 293
                                                                    u = _12789 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20475:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _12833 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_12833]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _12981 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                        _12982 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_12982 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12982 + 36 len 28]
                                                        mem[64] = _12981 + 164
                                                        mem[_12981 + 100] = 32
                                                        mem[_12981 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _13100 = mem[_12982]
                                                        s = 0
                                                        while s < _13100:
                                                            mem[s + _12981 + 164] = mem[s + _12982 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_13100) <= _13100:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12981 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12981 + 168 len _13100 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12981 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12981 + 232] = mem[idx + _12981 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12981 + 232]
                                                                if not mem[96]:
                                                                    mem[_12981 + 164] = 2
                                                                    mem[64] = _12981 + 260
                                                                    mem[_12981 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + 228] = address(cd[36])
                                                                    mem[_12981 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + 296] = 0
                                                                    mem[_12981 + 328] = 160
                                                                    mem[_12981 + 424] = 2
                                                                    s = 0
                                                                    t = _12981 + 456
                                                                    u = _12981 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + 360] = this.address
                                                                    mem[_12981 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12981 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20042 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20340 = mem[_20042]
                                                                    require mem[_20042] <= test266151307()
                                                                    require _20042 + mem[_20042] + 31 < _20042 + return_data.size
                                                                    _20476 = mem[_20042 + mem[_20042]]
                                                                    if mem[_20042 + mem[_20042]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20042 + ceil32(return_data.size) + ceil32(32 * mem[_20042 + mem[_20042]]) + 1 > test266151307() or ceil32(32 * mem[_20042 + mem[_20042]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20042 + ceil32(return_data.size) + ceil32(32 * mem[_20042 + mem[_20042]]) + 1
                                                                    mem[_20042 + ceil32(return_data.size)] = _20476
                                                                    require return_data.size >= _20340 + (32 * _20476) + 32
                                                                    t = _20042 + _20340 + 32
                                                                    u = _20042 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20476:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12981 + 164] = 2
                                                                    mem[64] = _12981 + 260
                                                                    mem[_12981 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + 228] = address(cd[36])
                                                                    mem[_12981 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + 296] = 0
                                                                    mem[_12981 + 328] = 160
                                                                    mem[_12981 + 424] = 2
                                                                    s = 0
                                                                    t = _12981 + 456
                                                                    u = _12981 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + 360] = this.address
                                                                    mem[_12981 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12981 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20043 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20341 = mem[_20043]
                                                                    require mem[_20043] <= test266151307()
                                                                    require _20043 + mem[_20043] + 31 < _20043 + return_data.size
                                                                    _20477 = mem[_20043 + mem[_20043]]
                                                                    if mem[_20043 + mem[_20043]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20043 + ceil32(return_data.size) + ceil32(32 * mem[_20043 + mem[_20043]]) + 1 > test266151307() or ceil32(32 * mem[_20043 + mem[_20043]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20043 + ceil32(return_data.size) + ceil32(32 * mem[_20043 + mem[_20043]]) + 1
                                                                    mem[_20043 + ceil32(return_data.size)] = _20477
                                                                    require return_data.size >= _20341 + (32 * _20477) + 32
                                                                    t = _20043 + _20341 + 32
                                                                    u = _20043 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20477:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12981 + 164] = return_data.size
                                                                mem[_12981 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12981 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12981 + ceil32(return_data.size) + 233] = mem[idx + _12981 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12981 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12981 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12981 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12981 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12981 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12981 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12981 + ceil32(return_data.size) + 457
                                                                    u = _12981 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12981 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12981 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12981 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20342 = mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12981 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20478 = mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20478
                                                                    require return_data.size >= _20342 + (32 * _20478) + 32
                                                                    t = _12981 + ceil32(return_data.size) + _20342 + 293
                                                                    u = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20478:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12981 + 196] == bool(mem[_12981 + 196])
                                                                    if not mem[_12981 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12981 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12981 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12981 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12981 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12981 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12981 + ceil32(return_data.size) + 457
                                                                    u = _12981 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12981 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12981 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12981 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20343 = mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12981 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20479 = mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20479
                                                                    require return_data.size >= _20343 + (32 * _20479) + 32
                                                                    t = _12981 + ceil32(return_data.size) + _20343 + 293
                                                                    u = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20479:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_13100 + _12981 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12981 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12981 + 168 len _13100 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12981 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12981 + 232] = mem[idx + _12981 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12981 + 232]
                                                                if not mem[96]:
                                                                    mem[_12981 + 164] = 2
                                                                    mem[64] = _12981 + 260
                                                                    mem[_12981 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + 228] = address(cd[36])
                                                                    mem[_12981 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + 296] = 0
                                                                    mem[_12981 + 328] = 160
                                                                    mem[_12981 + 424] = 2
                                                                    s = 0
                                                                    t = _12981 + 456
                                                                    u = _12981 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + 360] = this.address
                                                                    mem[_12981 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12981 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20050 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20344 = mem[_20050]
                                                                    require mem[_20050] <= test266151307()
                                                                    require _20050 + mem[_20050] + 31 < _20050 + return_data.size
                                                                    _20480 = mem[_20050 + mem[_20050]]
                                                                    if mem[_20050 + mem[_20050]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20050 + ceil32(return_data.size) + ceil32(32 * mem[_20050 + mem[_20050]]) + 1 > test266151307() or ceil32(32 * mem[_20050 + mem[_20050]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20050 + ceil32(return_data.size) + ceil32(32 * mem[_20050 + mem[_20050]]) + 1
                                                                    mem[_20050 + ceil32(return_data.size)] = _20480
                                                                    require return_data.size >= _20344 + (32 * _20480) + 32
                                                                    t = _20050 + _20344 + 32
                                                                    u = _20050 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20480:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12981 + 164] = 2
                                                                    mem[64] = _12981 + 260
                                                                    mem[_12981 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + 228] = address(cd[36])
                                                                    mem[_12981 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + 296] = 0
                                                                    mem[_12981 + 328] = 160
                                                                    mem[_12981 + 424] = 2
                                                                    s = 0
                                                                    t = _12981 + 456
                                                                    u = _12981 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + 360] = this.address
                                                                    mem[_12981 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12981 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20051 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20345 = mem[_20051]
                                                                    require mem[_20051] <= test266151307()
                                                                    require _20051 + mem[_20051] + 31 < _20051 + return_data.size
                                                                    _20481 = mem[_20051 + mem[_20051]]
                                                                    if mem[_20051 + mem[_20051]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20051 + ceil32(return_data.size) + ceil32(32 * mem[_20051 + mem[_20051]]) + 1 > test266151307() or ceil32(32 * mem[_20051 + mem[_20051]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20051 + ceil32(return_data.size) + ceil32(32 * mem[_20051 + mem[_20051]]) + 1
                                                                    mem[_20051 + ceil32(return_data.size)] = _20481
                                                                    require return_data.size >= _20345 + (32 * _20481) + 32
                                                                    t = _20051 + _20345 + 32
                                                                    u = _20051 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20481:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12981 + 164] = return_data.size
                                                                mem[_12981 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12981 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12981 + ceil32(return_data.size) + 233] = mem[idx + _12981 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12981 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12981 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12981 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12981 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12981 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12981 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12981 + ceil32(return_data.size) + 457
                                                                    u = _12981 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12981 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12981 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12981 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20346 = mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12981 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20482 = mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20482
                                                                    require return_data.size >= _20346 + (32 * _20482) + 32
                                                                    t = _12981 + ceil32(return_data.size) + _20346 + 293
                                                                    u = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20482:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12981 + 196] == bool(mem[_12981 + 196])
                                                                    if not mem[_12981 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12981 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12981 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12981 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12981 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12981 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12981 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12981 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12981 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12981 + ceil32(return_data.size) + 457
                                                                    u = _12981 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12981 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12981 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12981 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12981 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20347 = mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12981 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20483 = mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12981 + ceil32(return_data.size) + mem[_12981 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11575) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12981 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20483
                                                                    require return_data.size >= _20347 + (32 * _20483) + 32
                                                                    t = _12981 + ceil32(return_data.size) + _20347 + 293
                                                                    u = _12981 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20483:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                else:
                                                    t = 10
                                                    u = 1
                                                    s = mem[_11413 + 31 len 1]
                                                    while s > 1:
                                                        if t > -1 / t:
                                                            revert with 0, 17
                                                        if not bool(s):
                                                            t = t * t
                                                            u = u
                                                            s = uint255(s) * 0.5
                                                            continue 
                                                        t = t * t
                                                        u = t * u
                                                        s = uint255(s) * 0.5
                                                        continue 
                                                    if u > -1 / t:
                                                        revert with 0, 17
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and t * u > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]:
                                                        _16730 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _16731 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_16731 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_16731 + 36 len 28]
                                                        mem[64] = _16730 + 164
                                                        mem[_16730 + 100] = 32
                                                        mem[_16730 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _17366 = mem[_16731]
                                                        s = 0
                                                        while s < _17366:
                                                            mem[s + _16730 + 164] = mem[s + _16731 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_17366) <= _17366:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_16730 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_16730 + 168 len _17366 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_16730 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16730 + 232] = mem[idx + _16730 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16730 + 232]
                                                                if not mem[96]:
                                                                    mem[_16730 + 164] = 2
                                                                    mem[64] = _16730 + 260
                                                                    mem[_16730 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + 228] = address(cd[36])
                                                                    mem[_16730 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + 296] = 0
                                                                    mem[_16730 + 328] = 160
                                                                    mem[_16730 + 424] = 2
                                                                    s = 0
                                                                    t = _16730 + 456
                                                                    u = _16730 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16730 + 360] = this.address
                                                                    mem[_16730 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16730 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _21998 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22100 = mem[_21998]
                                                                    require mem[_21998] <= test266151307()
                                                                    require _21998 + mem[_21998] + 31 < _21998 + return_data.size
                                                                    _22132 = mem[_21998 + mem[_21998]]
                                                                    if mem[_21998 + mem[_21998]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _21998 + ceil32(return_data.size) + ceil32(32 * mem[_21998 + mem[_21998]]) + 1 > test266151307() or ceil32(32 * mem[_21998 + mem[_21998]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _21998 + ceil32(return_data.size) + ceil32(32 * mem[_21998 + mem[_21998]]) + 1
                                                                    mem[_21998 + ceil32(return_data.size)] = _22132
                                                                    require return_data.size >= _22100 + (32 * _22132) + 32
                                                                    t = _21998 + _22100 + 32
                                                                    u = _21998 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22132:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16730 + 164] = 2
                                                                    mem[64] = _16730 + 260
                                                                    mem[_16730 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + 228] = address(cd[36])
                                                                    mem[_16730 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + 296] = 0
                                                                    mem[_16730 + 328] = 160
                                                                    mem[_16730 + 424] = 2
                                                                    s = 0
                                                                    t = _16730 + 456
                                                                    u = _16730 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16730 + 360] = this.address
                                                                    mem[_16730 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16730 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _21999 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22101 = mem[_21999]
                                                                    require mem[_21999] <= test266151307()
                                                                    require _21999 + mem[_21999] + 31 < _21999 + return_data.size
                                                                    _22133 = mem[_21999 + mem[_21999]]
                                                                    if mem[_21999 + mem[_21999]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _21999 + ceil32(return_data.size) + ceil32(32 * mem[_21999 + mem[_21999]]) + 1 > test266151307() or ceil32(32 * mem[_21999 + mem[_21999]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _21999 + ceil32(return_data.size) + ceil32(32 * mem[_21999 + mem[_21999]]) + 1
                                                                    mem[_21999 + ceil32(return_data.size)] = _22133
                                                                    require return_data.size >= _22101 + (32 * _22133) + 32
                                                                    t = _21999 + _22101 + 32
                                                                    u = _21999 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22133:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_16730 + 164] = return_data.size
                                                                mem[_16730 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16730 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16730 + ceil32(return_data.size) + 233] = mem[idx + _16730 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16730 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_16730 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16730 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16730 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16730 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16730 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16730 + ceil32(return_data.size) + 457
                                                                    w = _16730 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16730 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16730 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16730 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16730 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22102 = mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16730 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22134 = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _22102 + (32 * _22134) + 32
                                                                    t = _16730 + ceil32(return_data.size) + _22102 + 293
                                                                    u = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22134:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_16730 + 196] == bool(mem[_16730 + 196])
                                                                    if not mem[_16730 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16730 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16730 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16730 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16730 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16730 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16730 + ceil32(return_data.size) + 457
                                                                    w = _16730 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16730 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16730 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16730 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16730 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22103 = mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16730 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22135 = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _22103 + (32 * _22135) + 32
                                                                    t = _16730 + ceil32(return_data.size) + _22103 + 293
                                                                    u = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22135:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_17366 + _16730 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_16730 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_16730 + 168 len _17366 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_16730 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16730 + 232] = mem[idx + _16730 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16730 + 232]
                                                                if not mem[96]:
                                                                    mem[_16730 + 164] = 2
                                                                    mem[64] = _16730 + 260
                                                                    mem[_16730 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + 228] = address(cd[36])
                                                                    mem[_16730 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + 296] = 0
                                                                    mem[_16730 + 328] = 160
                                                                    mem[_16730 + 424] = 2
                                                                    s = 0
                                                                    t = _16730 + 456
                                                                    u = _16730 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16730 + 360] = this.address
                                                                    mem[_16730 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16730 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22006 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22104 = mem[_22006]
                                                                    require mem[_22006] <= test266151307()
                                                                    require _22006 + mem[_22006] + 31 < _22006 + return_data.size
                                                                    _22136 = mem[_22006 + mem[_22006]]
                                                                    if mem[_22006 + mem[_22006]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22006 + ceil32(return_data.size) + ceil32(32 * mem[_22006 + mem[_22006]]) + 1 > test266151307() or ceil32(32 * mem[_22006 + mem[_22006]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22006 + ceil32(return_data.size) + ceil32(32 * mem[_22006 + mem[_22006]]) + 1
                                                                    mem[_22006 + ceil32(return_data.size)] = _22136
                                                                    require return_data.size >= _22104 + (32 * _22136) + 32
                                                                    t = _22006 + _22104 + 32
                                                                    u = _22006 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22136:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16730 + 164] = 2
                                                                    mem[64] = _16730 + 260
                                                                    mem[_16730 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + 228] = address(cd[36])
                                                                    mem[_16730 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + 296] = 0
                                                                    mem[_16730 + 328] = 160
                                                                    mem[_16730 + 424] = 2
                                                                    s = 0
                                                                    t = _16730 + 456
                                                                    u = _16730 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16730 + 360] = this.address
                                                                    mem[_16730 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16730 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22007 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22105 = mem[_22007]
                                                                    require mem[_22007] <= test266151307()
                                                                    require _22007 + mem[_22007] + 31 < _22007 + return_data.size
                                                                    _22137 = mem[_22007 + mem[_22007]]
                                                                    if mem[_22007 + mem[_22007]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22007 + ceil32(return_data.size) + ceil32(32 * mem[_22007 + mem[_22007]]) + 1 > test266151307() or ceil32(32 * mem[_22007 + mem[_22007]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22007 + ceil32(return_data.size) + ceil32(32 * mem[_22007 + mem[_22007]]) + 1
                                                                    mem[_22007 + ceil32(return_data.size)] = _22137
                                                                    require return_data.size >= _22105 + (32 * _22137) + 32
                                                                    t = _22007 + _22105 + 32
                                                                    u = _22007 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22137:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_16730 + 164] = return_data.size
                                                                mem[_16730 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16730 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16730 + ceil32(return_data.size) + 233] = mem[idx + _16730 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16730 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_16730 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16730 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16730 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16730 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16730 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16730 + ceil32(return_data.size) + 457
                                                                    w = _16730 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16730 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16730 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16730 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16730 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22106 = mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16730 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22138 = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _22106 + (32 * _22138) + 32
                                                                    t = _16730 + ceil32(return_data.size) + _22106 + 293
                                                                    u = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22138:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_16730 + 196] == bool(mem[_16730 + 196])
                                                                    if not mem[_16730 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16730 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16730 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16730 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16730 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16730 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16730 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16730 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16730 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16730 + ceil32(return_data.size) + 457
                                                                    w = _16730 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16730 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16730 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16730 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16730 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22107 = mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16730 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22139 = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16730 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_16730 + ceil32(return_data.size) + mem[_16730 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _22107 + (32 * _22139) + 32
                                                                    t = _16730 + ceil32(return_data.size) + _22107 + 293
                                                                    u = _16730 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22139:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _16738 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_16738]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _17434 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _17435 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_17435 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_17435 + 36 len 28]
                                                        mem[64] = _17434 + 164
                                                        mem[_17434 + 100] = 32
                                                        mem[_17434 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _18098 = mem[_17435]
                                                        s = 0
                                                        while s < _18098:
                                                            mem[s + _17434 + 164] = mem[s + _17435 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_18098) <= _18098:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_17434 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_17434 + 168 len _18098 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_17434 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17434 + 232] = mem[idx + _17434 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17434 + 232]
                                                                if not mem[96]:
                                                                    mem[_17434 + 164] = 2
                                                                    mem[64] = _17434 + 260
                                                                    mem[_17434 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + 228] = address(cd[36])
                                                                    mem[_17434 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + 296] = 0
                                                                    mem[_17434 + 328] = 160
                                                                    mem[_17434 + 424] = 2
                                                                    s = 0
                                                                    t = _17434 + 456
                                                                    u = _17434 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17434 + 360] = this.address
                                                                    mem[_17434 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17434 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22014 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22108 = mem[_22014]
                                                                    require mem[_22014] <= test266151307()
                                                                    require _22014 + mem[_22014] + 31 < _22014 + return_data.size
                                                                    _22140 = mem[_22014 + mem[_22014]]
                                                                    if mem[_22014 + mem[_22014]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22014 + ceil32(return_data.size) + ceil32(32 * mem[_22014 + mem[_22014]]) + 1 > test266151307() or ceil32(32 * mem[_22014 + mem[_22014]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22014 + ceil32(return_data.size) + ceil32(32 * mem[_22014 + mem[_22014]]) + 1
                                                                    mem[_22014 + ceil32(return_data.size)] = _22140
                                                                    require return_data.size >= _22108 + (32 * _22140) + 32
                                                                    t = _22014 + _22108 + 32
                                                                    u = _22014 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22140:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17434 + 164] = 2
                                                                    mem[64] = _17434 + 260
                                                                    mem[_17434 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + 228] = address(cd[36])
                                                                    mem[_17434 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + 296] = 0
                                                                    mem[_17434 + 328] = 160
                                                                    mem[_17434 + 424] = 2
                                                                    s = 0
                                                                    t = _17434 + 456
                                                                    u = _17434 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17434 + 360] = this.address
                                                                    mem[_17434 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17434 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22015 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22109 = mem[_22015]
                                                                    require mem[_22015] <= test266151307()
                                                                    require _22015 + mem[_22015] + 31 < _22015 + return_data.size
                                                                    _22141 = mem[_22015 + mem[_22015]]
                                                                    if mem[_22015 + mem[_22015]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22015 + ceil32(return_data.size) + ceil32(32 * mem[_22015 + mem[_22015]]) + 1 > test266151307() or ceil32(32 * mem[_22015 + mem[_22015]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22015 + ceil32(return_data.size) + ceil32(32 * mem[_22015 + mem[_22015]]) + 1
                                                                    mem[_22015 + ceil32(return_data.size)] = _22141
                                                                    require return_data.size >= _22109 + (32 * _22141) + 32
                                                                    t = _22015 + _22109 + 32
                                                                    u = _22015 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22141:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_17434 + 164] = return_data.size
                                                                mem[_17434 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17434 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17434 + ceil32(return_data.size) + 233] = mem[idx + _17434 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17434 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_17434 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17434 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17434 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17434 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17434 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17434 + ceil32(return_data.size) + 457
                                                                    w = _17434 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17434 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17434 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17434 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17434 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22110 = mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17434 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22142 = mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22142
                                                                    require return_data.size >= _22110 + (32 * _22142) + 32
                                                                    t = _17434 + ceil32(return_data.size) + _22110 + 293
                                                                    u = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22142:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_17434 + 196] == bool(mem[_17434 + 196])
                                                                    if not mem[_17434 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17434 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17434 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17434 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17434 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17434 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17434 + ceil32(return_data.size) + 457
                                                                    w = _17434 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17434 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17434 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17434 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17434 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22111 = mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17434 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22143 = mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22143
                                                                    require return_data.size >= _22111 + (32 * _22143) + 32
                                                                    t = _17434 + ceil32(return_data.size) + _22111 + 293
                                                                    u = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22143:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_18098 + _17434 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_17434 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_17434 + 168 len _18098 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_17434 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17434 + 232] = mem[idx + _17434 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17434 + 232]
                                                                if not mem[96]:
                                                                    mem[_17434 + 164] = 2
                                                                    mem[64] = _17434 + 260
                                                                    mem[_17434 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + 228] = address(cd[36])
                                                                    mem[_17434 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + 296] = 0
                                                                    mem[_17434 + 328] = 160
                                                                    mem[_17434 + 424] = 2
                                                                    s = 0
                                                                    t = _17434 + 456
                                                                    u = _17434 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17434 + 360] = this.address
                                                                    mem[_17434 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17434 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22022 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22112 = mem[_22022]
                                                                    require mem[_22022] <= test266151307()
                                                                    require _22022 + mem[_22022] + 31 < _22022 + return_data.size
                                                                    _22144 = mem[_22022 + mem[_22022]]
                                                                    if mem[_22022 + mem[_22022]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22022 + ceil32(return_data.size) + ceil32(32 * mem[_22022 + mem[_22022]]) + 1 > test266151307() or ceil32(32 * mem[_22022 + mem[_22022]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22022 + ceil32(return_data.size) + ceil32(32 * mem[_22022 + mem[_22022]]) + 1
                                                                    mem[_22022 + ceil32(return_data.size)] = _22144
                                                                    require return_data.size >= _22112 + (32 * _22144) + 32
                                                                    t = _22022 + _22112 + 32
                                                                    u = _22022 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22144:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17434 + 164] = 2
                                                                    mem[64] = _17434 + 260
                                                                    mem[_17434 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + 228] = address(cd[36])
                                                                    mem[_17434 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + 296] = 0
                                                                    mem[_17434 + 328] = 160
                                                                    mem[_17434 + 424] = 2
                                                                    s = 0
                                                                    t = _17434 + 456
                                                                    u = _17434 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17434 + 360] = this.address
                                                                    mem[_17434 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17434 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22023 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22113 = mem[_22023]
                                                                    require mem[_22023] <= test266151307()
                                                                    require _22023 + mem[_22023] + 31 < _22023 + return_data.size
                                                                    _22145 = mem[_22023 + mem[_22023]]
                                                                    if mem[_22023 + mem[_22023]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22023 + ceil32(return_data.size) + ceil32(32 * mem[_22023 + mem[_22023]]) + 1 > test266151307() or ceil32(32 * mem[_22023 + mem[_22023]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22023 + ceil32(return_data.size) + ceil32(32 * mem[_22023 + mem[_22023]]) + 1
                                                                    mem[_22023 + ceil32(return_data.size)] = _22145
                                                                    require return_data.size >= _22113 + (32 * _22145) + 32
                                                                    t = _22023 + _22113 + 32
                                                                    u = _22023 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22145:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_17434 + 164] = return_data.size
                                                                mem[_17434 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17434 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17434 + ceil32(return_data.size) + 233] = mem[idx + _17434 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17434 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_17434 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17434 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17434 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17434 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17434 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17434 + ceil32(return_data.size) + 457
                                                                    w = _17434 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17434 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17434 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17434 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17434 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22114 = mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17434 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22146 = mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22146
                                                                    require return_data.size >= _22114 + (32 * _22146) + 32
                                                                    t = _17434 + ceil32(return_data.size) + _22114 + 293
                                                                    u = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22146:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_17434 + 196] == bool(mem[_17434 + 196])
                                                                    if not mem[_17434 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17434 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17434 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17434 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17434 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17434 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17434 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17434 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17434 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17434 + ceil32(return_data.size) + 457
                                                                    w = _17434 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17434 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17434 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17434 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17434 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22115 = mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17434 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22147 = mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17434 + ceil32(return_data.size) + mem[_17434 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17434 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22147
                                                                    require return_data.size >= _22115 + (32 * _22147) + 32
                                                                    t = _17434 + ceil32(return_data.size) + _22115 + 293
                                                                    u = _17434 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22147:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[32] = 1
                                            sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])] = 1
                                            if sub_8cf086ad > -2:
                                                revert with 0, 17
                                            sub_8cf086ad++
                            else:
                                _2814 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_2814] == mem[_2814 + 31 len 1]
                                if not mem[_2814 + 31 len 1]:
                                    if Mask(112, 0, _2803) and cd[((32 * idx) + cd[100] + 36)] > -1 / Mask(112, 0, _2803):
                                        revert with 0, 17
                                    if cd[196] <= Mask(112, 0, _2803) * cd[((32 * idx) + cd[100] + 36)]:
                                        if idx >= ('cd', 68).length:
                                            revert with 0, 50
                                        require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                        if idx >= ('cd', 100).length:
                                            revert with 0, 50
                                        if idx >= ('cd', 132).length:
                                            revert with 0, 50
                                        if cd[164] and cd[((32 * idx) + cd[132] + 36)] > -1 / cd[164]:
                                            revert with 0, 17
                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _2822 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _2824 = mem[_2822]
                                        require mem[_2822] == mem[_2822 + 31 len 1]
                                        if not mem[_2822 + 31 len 1]:
                                            if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 1 > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                revert with 0, 17
                                            if not cd[((32 * idx) + cd[100] + 36)]:
                                                revert with 0, 18
                                            if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]:
                                                _2849 = mem[64]
                                                mem[mem[64] + 36] = address(cd[4])
                                                mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                _2850 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_2850 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2850 + 36 len 28]
                                                mem[64] = _2849 + 164
                                                mem[_2849 + 100] = 32
                                                mem[_2849 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _2891 = mem[_2850]
                                                s = 0
                                                while s < _2891:
                                                    mem[s + _2849 + 164] = mem[s + _2850 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_2891) <= _2891:
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2849 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2849 + 168 len _2891 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2849 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2849 + 232] = mem[idx + _2849 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2849 + 232]
                                                        if not mem[96]:
                                                            mem[_2849 + 164] = 2
                                                            mem[64] = _2849 + 260
                                                            mem[_2849 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + 228] = address(cd[36])
                                                            mem[_2849 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + 296] = 0
                                                            mem[_2849 + 328] = 160
                                                            mem[_2849 + 424] = 2
                                                            s = 0
                                                            t = _2849 + 456
                                                            u = _2849 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + 360] = this.address
                                                            mem[_2849 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2849 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15634 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15808 = mem[_15634]
                                                            require mem[_15634] <= test266151307()
                                                            require _15634 + mem[_15634] + 31 < _15634 + return_data.size
                                                            _16010 = mem[_15634 + mem[_15634]]
                                                            if mem[_15634 + mem[_15634]] > test266151307():
                                                                revert with 0, 65
                                                            if _15634 + ceil32(return_data.size) + ceil32(32 * mem[_15634 + mem[_15634]]) + 1 > test266151307() or ceil32(32 * mem[_15634 + mem[_15634]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15634 + ceil32(return_data.size) + ceil32(32 * mem[_15634 + mem[_15634]]) + 1
                                                            mem[_15634 + ceil32(return_data.size)] = _16010
                                                            require return_data.size >= _15808 + (32 * _16010) + 32
                                                            t = _15634 + _15808 + 32
                                                            u = _15634 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16010:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2849 + 164] = 2
                                                            mem[64] = _2849 + 260
                                                            mem[_2849 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + 228] = address(cd[36])
                                                            mem[_2849 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + 296] = 0
                                                            mem[_2849 + 328] = 160
                                                            mem[_2849 + 424] = 2
                                                            s = 0
                                                            t = _2849 + 456
                                                            u = _2849 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + 360] = this.address
                                                            mem[_2849 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2849 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15635 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15809 = mem[_15635]
                                                            require mem[_15635] <= test266151307()
                                                            require _15635 + mem[_15635] + 31 < _15635 + return_data.size
                                                            _16011 = mem[_15635 + mem[_15635]]
                                                            if mem[_15635 + mem[_15635]] > test266151307():
                                                                revert with 0, 65
                                                            if _15635 + ceil32(return_data.size) + ceil32(32 * mem[_15635 + mem[_15635]]) + 1 > test266151307() or ceil32(32 * mem[_15635 + mem[_15635]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15635 + ceil32(return_data.size) + ceil32(32 * mem[_15635 + mem[_15635]]) + 1
                                                            mem[_15635 + ceil32(return_data.size)] = _16011
                                                            require return_data.size >= _15809 + (32 * _16011) + 32
                                                            t = _15635 + _15809 + 32
                                                            u = _15635 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16011:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2849 + 164] = return_data.size
                                                        mem[_2849 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2849 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2849 + ceil32(return_data.size) + 233] = mem[idx + _2849 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2849 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2849 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2849 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2849 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2849 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2849 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2849 + ceil32(return_data.size) + 457
                                                            u = _2849 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2849 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2849 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2849 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15810 = mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2849 + ceil32(return_data.size) + return_data.size + 261
                                                            _16012 = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15810 + (32 * _16012) + 32
                                                            t = _2849 + ceil32(return_data.size) + _15810 + 293
                                                            u = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16012:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2849 + 196] == bool(mem[_2849 + 196])
                                                            if not mem[_2849 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2849 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2849 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2849 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2849 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2849 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2849 + ceil32(return_data.size) + 457
                                                            u = _2849 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2849 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2849 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2849 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15811 = mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2849 + ceil32(return_data.size) + return_data.size + 261
                                                            _16013 = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15811 + (32 * _16013) + 32
                                                            t = _2849 + ceil32(return_data.size) + _15811 + 293
                                                            u = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16013:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[_2891 + _2849 + 164] = 0
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2849 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2849 + 168 len _2891 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2849 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2849 + 232] = mem[idx + _2849 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2849 + 232]
                                                        if not mem[96]:
                                                            mem[_2849 + 164] = 2
                                                            mem[64] = _2849 + 260
                                                            mem[_2849 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + 228] = address(cd[36])
                                                            mem[_2849 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + 296] = 0
                                                            mem[_2849 + 328] = 160
                                                            mem[_2849 + 424] = 2
                                                            s = 0
                                                            t = _2849 + 456
                                                            u = _2849 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + 360] = this.address
                                                            mem[_2849 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2849 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15642 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15812 = mem[_15642]
                                                            require mem[_15642] <= test266151307()
                                                            require _15642 + mem[_15642] + 31 < _15642 + return_data.size
                                                            _16014 = mem[_15642 + mem[_15642]]
                                                            if mem[_15642 + mem[_15642]] > test266151307():
                                                                revert with 0, 65
                                                            if _15642 + ceil32(return_data.size) + ceil32(32 * mem[_15642 + mem[_15642]]) + 1 > test266151307() or ceil32(32 * mem[_15642 + mem[_15642]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15642 + ceil32(return_data.size) + ceil32(32 * mem[_15642 + mem[_15642]]) + 1
                                                            mem[_15642 + ceil32(return_data.size)] = _16014
                                                            require return_data.size >= _15812 + (32 * _16014) + 32
                                                            t = _15642 + _15812 + 32
                                                            u = _15642 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16014:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2849 + 164] = 2
                                                            mem[64] = _2849 + 260
                                                            mem[_2849 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + 228] = address(cd[36])
                                                            mem[_2849 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + 296] = 0
                                                            mem[_2849 + 328] = 160
                                                            mem[_2849 + 424] = 2
                                                            s = 0
                                                            t = _2849 + 456
                                                            u = _2849 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + 360] = this.address
                                                            mem[_2849 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2849 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15643 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15813 = mem[_15643]
                                                            require mem[_15643] <= test266151307()
                                                            require _15643 + mem[_15643] + 31 < _15643 + return_data.size
                                                            _16015 = mem[_15643 + mem[_15643]]
                                                            if mem[_15643 + mem[_15643]] > test266151307():
                                                                revert with 0, 65
                                                            if _15643 + ceil32(return_data.size) + ceil32(32 * mem[_15643 + mem[_15643]]) + 1 > test266151307() or ceil32(32 * mem[_15643 + mem[_15643]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15643 + ceil32(return_data.size) + ceil32(32 * mem[_15643 + mem[_15643]]) + 1
                                                            mem[_15643 + ceil32(return_data.size)] = _16015
                                                            require return_data.size >= _15813 + (32 * _16015) + 32
                                                            t = _15643 + _15813 + 32
                                                            u = _15643 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16015:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2849 + 164] = return_data.size
                                                        mem[_2849 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2849 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2849 + ceil32(return_data.size) + 233] = mem[idx + _2849 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2849 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2849 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2849 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2849 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2849 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2849 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2849 + ceil32(return_data.size) + 457
                                                            u = _2849 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2849 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2849 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2849 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15814 = mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2849 + ceil32(return_data.size) + return_data.size + 261
                                                            _16016 = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15814 + (32 * _16016) + 32
                                                            t = _2849 + ceil32(return_data.size) + _15814 + 293
                                                            u = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16016:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2849 + 196] == bool(mem[_2849 + 196])
                                                            if not mem[_2849 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2849 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2849 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2849 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2849 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2849 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2849 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2849 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2849 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2849 + ceil32(return_data.size) + 457
                                                            u = _2849 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2849 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2849 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2849 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2849 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15815 = mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2849 + ceil32(return_data.size) + return_data.size + 261
                                                            _16017 = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2849 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_2849 + ceil32(return_data.size) + mem[_2849 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            require return_data.size >= _15815 + (32 * _16017) + 32
                                                            t = _2849 + ceil32(return_data.size) + _15815 + 293
                                                            u = _2849 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16017:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                            else:
                                                mem[mem[64] + 4] = this.address
                                                mem[mem[64] + 36] = address(cd[4])
                                                require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                        gas gas_remaining wei
                                                       args this.address, address(cd[4])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2854 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if mem[_2854]:
                                                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                _2902 = mem[64]
                                                mem[mem[64] + 36] = address(cd[4])
                                                mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                _2903 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_2903 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2903 + 36 len 28]
                                                mem[64] = _2902 + 164
                                                mem[_2902 + 100] = 32
                                                mem[_2902 + 132] = 'SafeERC20: low-level call failed'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 'Address: insufficient balance for call'
                                                if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                    revert with 0, 'Address: call to non-contract'
                                                _3015 = mem[_2903]
                                                s = 0
                                                while s < _3015:
                                                    mem[s + _2902 + 164] = mem[s + _2903 + 32]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_3015) <= _3015:
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2902 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2902 + 168 len _3015 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2902 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2902 + 232] = mem[idx + _2902 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2902 + 232]
                                                        if not mem[96]:
                                                            mem[_2902 + 164] = 2
                                                            mem[64] = _2902 + 260
                                                            mem[_2902 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + 228] = address(cd[36])
                                                            mem[_2902 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + 296] = 0
                                                            mem[_2902 + 328] = 160
                                                            mem[_2902 + 424] = 2
                                                            s = 0
                                                            t = _2902 + 456
                                                            u = _2902 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + 360] = this.address
                                                            mem[_2902 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2902 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15650 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15816 = mem[_15650]
                                                            require mem[_15650] <= test266151307()
                                                            require _15650 + mem[_15650] + 31 < _15650 + return_data.size
                                                            _16018 = mem[_15650 + mem[_15650]]
                                                            if mem[_15650 + mem[_15650]] > test266151307():
                                                                revert with 0, 65
                                                            if _15650 + ceil32(return_data.size) + ceil32(32 * mem[_15650 + mem[_15650]]) + 1 > test266151307() or ceil32(32 * mem[_15650 + mem[_15650]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15650 + ceil32(return_data.size) + ceil32(32 * mem[_15650 + mem[_15650]]) + 1
                                                            mem[_15650 + ceil32(return_data.size)] = _16018
                                                            require return_data.size >= _15816 + (32 * _16018) + 32
                                                            t = _15650 + _15816 + 32
                                                            u = _15650 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16018:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2902 + 164] = 2
                                                            mem[64] = _2902 + 260
                                                            mem[_2902 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + 228] = address(cd[36])
                                                            mem[_2902 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + 296] = 0
                                                            mem[_2902 + 328] = 160
                                                            mem[_2902 + 424] = 2
                                                            s = 0
                                                            t = _2902 + 456
                                                            u = _2902 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + 360] = this.address
                                                            mem[_2902 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2902 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15651 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15817 = mem[_15651]
                                                            require mem[_15651] <= test266151307()
                                                            require _15651 + mem[_15651] + 31 < _15651 + return_data.size
                                                            _16019 = mem[_15651 + mem[_15651]]
                                                            if mem[_15651 + mem[_15651]] > test266151307():
                                                                revert with 0, 65
                                                            if _15651 + ceil32(return_data.size) + ceil32(32 * mem[_15651 + mem[_15651]]) + 1 > test266151307() or ceil32(32 * mem[_15651 + mem[_15651]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15651 + ceil32(return_data.size) + ceil32(32 * mem[_15651 + mem[_15651]]) + 1
                                                            mem[_15651 + ceil32(return_data.size)] = _16019
                                                            require return_data.size >= _15817 + (32 * _16019) + 32
                                                            t = _15651 + _15817 + 32
                                                            u = _15651 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16019:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2902 + 164] = return_data.size
                                                        mem[_2902 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2902 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2902 + ceil32(return_data.size) + 233] = mem[idx + _2902 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2902 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2902 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2902 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2902 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2902 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2902 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2902 + ceil32(return_data.size) + 457
                                                            u = _2902 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2902 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2902 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2902 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15818 = mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2902 + ceil32(return_data.size) + return_data.size + 261
                                                            _16020 = mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16020
                                                            require return_data.size >= _15818 + (32 * _16020) + 32
                                                            t = _2902 + ceil32(return_data.size) + _15818 + 293
                                                            u = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16020:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2902 + 196] == bool(mem[_2902 + 196])
                                                            if not mem[_2902 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2902 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2902 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2902 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2902 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2902 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2902 + ceil32(return_data.size) + 457
                                                            u = _2902 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2902 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2902 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2902 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15819 = mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2902 + ceil32(return_data.size) + return_data.size + 261
                                                            _16021 = mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16021
                                                            require return_data.size >= _15819 + (32 * _16021) + 32
                                                            t = _2902 + ceil32(return_data.size) + _15819 + 293
                                                            u = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16021:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                else:
                                                    mem[_3015 + _2902 + 164] = 0
                                                    call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2902 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_2902 + 168 len _3015 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_2902 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + 168] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2902 + 232] = mem[idx + _2902 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2902 + 232]
                                                        if not mem[96]:
                                                            mem[_2902 + 164] = 2
                                                            mem[64] = _2902 + 260
                                                            mem[_2902 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + 228] = address(cd[36])
                                                            mem[_2902 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + 296] = 0
                                                            mem[_2902 + 328] = 160
                                                            mem[_2902 + 424] = 2
                                                            s = 0
                                                            t = _2902 + 456
                                                            u = _2902 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + 360] = this.address
                                                            mem[_2902 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2902 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15658 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15820 = mem[_15658]
                                                            require mem[_15658] <= test266151307()
                                                            require _15658 + mem[_15658] + 31 < _15658 + return_data.size
                                                            _16022 = mem[_15658 + mem[_15658]]
                                                            if mem[_15658 + mem[_15658]] > test266151307():
                                                                revert with 0, 65
                                                            if _15658 + ceil32(return_data.size) + ceil32(32 * mem[_15658 + mem[_15658]]) + 1 > test266151307() or ceil32(32 * mem[_15658 + mem[_15658]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15658 + ceil32(return_data.size) + ceil32(32 * mem[_15658 + mem[_15658]]) + 1
                                                            mem[_15658 + ceil32(return_data.size)] = _16022
                                                            require return_data.size >= _15820 + (32 * _16022) + 32
                                                            t = _15658 + _15820 + 32
                                                            u = _15658 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16022:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2902 + 164] = 2
                                                            mem[64] = _2902 + 260
                                                            mem[_2902 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + 228] = address(cd[36])
                                                            mem[_2902 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + 296] = 0
                                                            mem[_2902 + 328] = 160
                                                            mem[_2902 + 424] = 2
                                                            s = 0
                                                            t = _2902 + 456
                                                            u = _2902 + 196
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + 360] = this.address
                                                            mem[_2902 + 392] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _2902 + -mem[64] + 516]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _15659 = mem[64]
                                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            _15821 = mem[_15659]
                                                            require mem[_15659] <= test266151307()
                                                            require _15659 + mem[_15659] + 31 < _15659 + return_data.size
                                                            _16023 = mem[_15659 + mem[_15659]]
                                                            if mem[_15659 + mem[_15659]] > test266151307():
                                                                revert with 0, 65
                                                            if _15659 + ceil32(return_data.size) + ceil32(32 * mem[_15659 + mem[_15659]]) + 1 > test266151307() or ceil32(32 * mem[_15659 + mem[_15659]]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _15659 + ceil32(return_data.size) + ceil32(32 * mem[_15659 + mem[_15659]]) + 1
                                                            mem[_15659 + ceil32(return_data.size)] = _16023
                                                            require return_data.size >= _15821 + (32 * _16023) + 32
                                                            t = _15659 + _15821 + 32
                                                            u = _15659 + ceil32(return_data.size) + 32
                                                            s = 0
                                                            while s < _16023:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                    else:
                                                        mem[_2902 + 164] = return_data.size
                                                        mem[_2902 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2902 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + ceil32(return_data.size) + 169] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _2902 + ceil32(return_data.size) + 233] = mem[idx + _2902 + 132]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_2902 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            mem[_2902 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2902 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2902 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2902 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2902 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2902 + ceil32(return_data.size) + 457
                                                            u = _2902 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2902 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2902 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2902 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15822 = mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2902 + ceil32(return_data.size) + return_data.size + 261
                                                            _16024 = mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16024
                                                            require return_data.size >= _15822 + (32 * _16024) + 32
                                                            t = _2902 + ceil32(return_data.size) + _15822 + 293
                                                            u = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16024:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_2902 + 196] == bool(mem[_2902 + 196])
                                                            if not mem[_2902 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            mem[_2902 + ceil32(return_data.size) + 165] = 2
                                                            mem[_2902 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                            mem[_2902 + ceil32(return_data.size) + 229] = address(cd[36])
                                                            mem[_2902 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                            mem[_2902 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                            mem[_2902 + ceil32(return_data.size) + 297] = 0
                                                            mem[_2902 + ceil32(return_data.size) + 329] = 160
                                                            mem[_2902 + ceil32(return_data.size) + 425] = 2
                                                            s = 0
                                                            t = _2902 + ceil32(return_data.size) + 457
                                                            u = _2902 + ceil32(return_data.size) + 197
                                                            while s < 2:
                                                                mem[t] = mem[u + 12 len 20]
                                                                s = s + 1
                                                                t = t + 32
                                                                u = u + 32
                                                                continue 
                                                            mem[_2902 + ceil32(return_data.size) + 361] = this.address
                                                            mem[_2902 + ceil32(return_data.size) + 393] = cd[228]
                                                            require ext_code.size(address(cd[4]))
                                                            call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2902 + ceil32(return_data.size) + 457 len 64]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_2902 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                            require return_data.size >= 32
                                                            _15823 = mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                            require mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                            require _2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2902 + ceil32(return_data.size) + return_data.size + 261
                                                            _16025 = mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                            if mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                revert with 0, 65
                                                            if _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                revert with 0, 65
                                                            mem[64] = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2902 + ceil32(return_data.size) + mem[_2902 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                            mem[_2902 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16025
                                                            require return_data.size >= _15823 + (32 * _16025) + 32
                                                            t = _2902 + ceil32(return_data.size) + _15823 + 293
                                                            u = _2902 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                            s = 0
                                                            while s < _16025:
                                                                mem[u] = mem[t]
                                                                t = t + 32
                                                                u = u + 32
                                                                s = s + 1
                                                                continue 
                                        else:
                                            if bool(bool(mem[_2822 + 31 len 1] < 78)) or bool(bool(mem[_2822 + 31 len 1] < 32)):
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 10^mem[_2822 + 31 len 1] > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^mem[_2822 + 31 len 1] / cd[((32 * idx) + cd[100] + 36)]:
                                                    _2887 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                    _2888 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_2888 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2888 + 36 len 28]
                                                    mem[64] = _2887 + 164
                                                    mem[_2887 + 100] = 32
                                                    mem[_2887 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _2982 = mem[_2888]
                                                    s = 0
                                                    while s < _2982:
                                                        mem[s + _2887 + 164] = mem[s + _2888 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_2982) <= _2982:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2887 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2887 + 168 len _2982 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2887 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2887 + 232] = mem[idx + _2887 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2887 + 232]
                                                            if not mem[96]:
                                                                mem[_2887 + 164] = 2
                                                                mem[64] = _2887 + 260
                                                                mem[_2887 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + 228] = address(cd[36])
                                                                mem[_2887 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + 296] = 0
                                                                mem[_2887 + 328] = 160
                                                                mem[_2887 + 424] = 2
                                                                s = 0
                                                                t = _2887 + 456
                                                                u = _2887 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + 360] = this.address
                                                                mem[_2887 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2887 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15602 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15792 = mem[_15602]
                                                                require mem[_15602] <= test266151307()
                                                                require _15602 + mem[_15602] + 31 < _15602 + return_data.size
                                                                _15994 = mem[_15602 + mem[_15602]]
                                                                if mem[_15602 + mem[_15602]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15602 + ceil32(return_data.size) + ceil32(32 * mem[_15602 + mem[_15602]]) + 1 > test266151307() or ceil32(32 * mem[_15602 + mem[_15602]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15602 + ceil32(return_data.size) + ceil32(32 * mem[_15602 + mem[_15602]]) + 1
                                                                mem[_15602 + ceil32(return_data.size)] = _15994
                                                                require return_data.size >= _15792 + (32 * _15994) + 32
                                                                t = _15602 + _15792 + 32
                                                                u = _15602 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15994:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2887 + 164] = 2
                                                                mem[64] = _2887 + 260
                                                                mem[_2887 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + 228] = address(cd[36])
                                                                mem[_2887 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + 296] = 0
                                                                mem[_2887 + 328] = 160
                                                                mem[_2887 + 424] = 2
                                                                s = 0
                                                                t = _2887 + 456
                                                                u = _2887 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + 360] = this.address
                                                                mem[_2887 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2887 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15603 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15793 = mem[_15603]
                                                                require mem[_15603] <= test266151307()
                                                                require _15603 + mem[_15603] + 31 < _15603 + return_data.size
                                                                _15995 = mem[_15603 + mem[_15603]]
                                                                if mem[_15603 + mem[_15603]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15603 + ceil32(return_data.size) + ceil32(32 * mem[_15603 + mem[_15603]]) + 1 > test266151307() or ceil32(32 * mem[_15603 + mem[_15603]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15603 + ceil32(return_data.size) + ceil32(32 * mem[_15603 + mem[_15603]]) + 1
                                                                mem[_15603 + ceil32(return_data.size)] = _15995
                                                                require return_data.size >= _15793 + (32 * _15995) + 32
                                                                t = _15603 + _15793 + 32
                                                                u = _15603 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15995:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2887 + 164] = return_data.size
                                                            mem[_2887 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2887 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2887 + ceil32(return_data.size) + 233] = mem[idx + _2887 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2887 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2887 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2887 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2887 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2887 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2887 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2887 + ceil32(return_data.size) + 457
                                                                u = _2887 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2887 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2887 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2887 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15794 = mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2887 + ceil32(return_data.size) + return_data.size + 261
                                                                _15996 = mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15996
                                                                require return_data.size >= _15794 + (32 * _15996) + 32
                                                                t = _2887 + ceil32(return_data.size) + _15794 + 293
                                                                u = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15996:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2887 + 196] == bool(mem[_2887 + 196])
                                                                if not mem[_2887 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2887 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2887 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2887 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2887 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2887 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2887 + ceil32(return_data.size) + 457
                                                                u = _2887 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2887 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2887 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2887 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15795 = mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2887 + ceil32(return_data.size) + return_data.size + 261
                                                                _15997 = mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15997
                                                                require return_data.size >= _15795 + (32 * _15997) + 32
                                                                t = _2887 + ceil32(return_data.size) + _15795 + 293
                                                                u = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15997:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_2982 + _2887 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2887 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2887 + 168 len _2982 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2887 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2887 + 232] = mem[idx + _2887 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2887 + 232]
                                                            if not mem[96]:
                                                                mem[_2887 + 164] = 2
                                                                mem[64] = _2887 + 260
                                                                mem[_2887 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + 228] = address(cd[36])
                                                                mem[_2887 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + 296] = 0
                                                                mem[_2887 + 328] = 160
                                                                mem[_2887 + 424] = 2
                                                                s = 0
                                                                t = _2887 + 456
                                                                u = _2887 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + 360] = this.address
                                                                mem[_2887 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2887 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15610 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15796 = mem[_15610]
                                                                require mem[_15610] <= test266151307()
                                                                require _15610 + mem[_15610] + 31 < _15610 + return_data.size
                                                                _15998 = mem[_15610 + mem[_15610]]
                                                                if mem[_15610 + mem[_15610]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15610 + ceil32(return_data.size) + ceil32(32 * mem[_15610 + mem[_15610]]) + 1 > test266151307() or ceil32(32 * mem[_15610 + mem[_15610]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15610 + ceil32(return_data.size) + ceil32(32 * mem[_15610 + mem[_15610]]) + 1
                                                                mem[_15610 + ceil32(return_data.size)] = _15998
                                                                require return_data.size >= _15796 + (32 * _15998) + 32
                                                                t = _15610 + _15796 + 32
                                                                u = _15610 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15998:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2887 + 164] = 2
                                                                mem[64] = _2887 + 260
                                                                mem[_2887 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + 228] = address(cd[36])
                                                                mem[_2887 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + 296] = 0
                                                                mem[_2887 + 328] = 160
                                                                mem[_2887 + 424] = 2
                                                                s = 0
                                                                t = _2887 + 456
                                                                u = _2887 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + 360] = this.address
                                                                mem[_2887 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2887 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15611 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15797 = mem[_15611]
                                                                require mem[_15611] <= test266151307()
                                                                require _15611 + mem[_15611] + 31 < _15611 + return_data.size
                                                                _15999 = mem[_15611 + mem[_15611]]
                                                                if mem[_15611 + mem[_15611]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15611 + ceil32(return_data.size) + ceil32(32 * mem[_15611 + mem[_15611]]) + 1 > test266151307() or ceil32(32 * mem[_15611 + mem[_15611]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15611 + ceil32(return_data.size) + ceil32(32 * mem[_15611 + mem[_15611]]) + 1
                                                                mem[_15611 + ceil32(return_data.size)] = _15999
                                                                require return_data.size >= _15797 + (32 * _15999) + 32
                                                                t = _15611 + _15797 + 32
                                                                u = _15611 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15999:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2887 + 164] = return_data.size
                                                            mem[_2887 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2887 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2887 + ceil32(return_data.size) + 233] = mem[idx + _2887 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2887 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2887 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2887 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2887 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2887 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2887 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2887 + ceil32(return_data.size) + 457
                                                                u = _2887 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2887 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2887 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2887 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15798 = mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2887 + ceil32(return_data.size) + return_data.size + 261
                                                                _16000 = mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16000
                                                                require return_data.size >= _15798 + (32 * _16000) + 32
                                                                t = _2887 + ceil32(return_data.size) + _15798 + 293
                                                                u = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _16000:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2887 + 196] == bool(mem[_2887 + 196])
                                                                if not mem[_2887 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2887 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2887 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2887 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2887 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2887 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2887 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2887 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2887 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2887 + ceil32(return_data.size) + 457
                                                                u = _2887 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2887 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2887 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2887 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2887 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15799 = mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2887 + ceil32(return_data.size) + return_data.size + 261
                                                                _16001 = mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2887 + ceil32(return_data.size) + mem[_2887 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2887 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16001
                                                                require return_data.size >= _15799 + (32 * _16001) + 32
                                                                t = _2887 + ceil32(return_data.size) + _15799 + 293
                                                                u = _2887 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _16001:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _2901 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_2901]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _3008 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                    _3009 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_3009 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_3009 + 36 len 28]
                                                    mem[64] = _3008 + 164
                                                    mem[_3008 + 100] = 32
                                                    mem[_3008 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _3181 = mem[_3009]
                                                    s = 0
                                                    while s < _3181:
                                                        mem[s + _3008 + 164] = mem[s + _3009 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_3181) <= _3181:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3008 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_3008 + 168 len _3181 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_3008 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3008 + 232] = mem[idx + _3008 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3008 + 232]
                                                            if not mem[96]:
                                                                mem[_3008 + 164] = 2
                                                                mem[64] = _3008 + 260
                                                                mem[_3008 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + 228] = address(cd[36])
                                                                mem[_3008 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + 296] = 0
                                                                mem[_3008 + 328] = 160
                                                                mem[_3008 + 424] = 2
                                                                s = 0
                                                                t = _3008 + 456
                                                                u = _3008 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + 360] = this.address
                                                                mem[_3008 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3008 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15618 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15800 = mem[_15618]
                                                                require mem[_15618] <= test266151307()
                                                                require _15618 + mem[_15618] + 31 < _15618 + return_data.size
                                                                _16002 = mem[_15618 + mem[_15618]]
                                                                if mem[_15618 + mem[_15618]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15618 + ceil32(return_data.size) + ceil32(32 * mem[_15618 + mem[_15618]]) + 1 > test266151307() or ceil32(32 * mem[_15618 + mem[_15618]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15618 + ceil32(return_data.size) + ceil32(32 * mem[_15618 + mem[_15618]]) + 1
                                                                mem[_15618 + ceil32(return_data.size)] = _16002
                                                                require return_data.size >= _15800 + (32 * _16002) + 32
                                                                t = _15618 + _15800 + 32
                                                                u = _15618 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _16002:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3008 + 164] = 2
                                                                mem[64] = _3008 + 260
                                                                mem[_3008 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + 228] = address(cd[36])
                                                                mem[_3008 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + 296] = 0
                                                                mem[_3008 + 328] = 160
                                                                mem[_3008 + 424] = 2
                                                                s = 0
                                                                t = _3008 + 456
                                                                u = _3008 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + 360] = this.address
                                                                mem[_3008 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3008 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15619 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15801 = mem[_15619]
                                                                require mem[_15619] <= test266151307()
                                                                require _15619 + mem[_15619] + 31 < _15619 + return_data.size
                                                                _16003 = mem[_15619 + mem[_15619]]
                                                                if mem[_15619 + mem[_15619]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15619 + ceil32(return_data.size) + ceil32(32 * mem[_15619 + mem[_15619]]) + 1 > test266151307() or ceil32(32 * mem[_15619 + mem[_15619]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15619 + ceil32(return_data.size) + ceil32(32 * mem[_15619 + mem[_15619]]) + 1
                                                                mem[_15619 + ceil32(return_data.size)] = _16003
                                                                require return_data.size >= _15801 + (32 * _16003) + 32
                                                                t = _15619 + _15801 + 32
                                                                u = _15619 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _16003:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_3008 + 164] = return_data.size
                                                            mem[_3008 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3008 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3008 + ceil32(return_data.size) + 233] = mem[idx + _3008 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3008 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_3008 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3008 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3008 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3008 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3008 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3008 + ceil32(return_data.size) + 457
                                                                u = _3008 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3008 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3008 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3008 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15802 = mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3008 + ceil32(return_data.size) + return_data.size + 261
                                                                _16004 = mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16004
                                                                require return_data.size >= _15802 + (32 * _16004) + 32
                                                                t = _3008 + ceil32(return_data.size) + _15802 + 293
                                                                u = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _16004:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_3008 + 196] == bool(mem[_3008 + 196])
                                                                if not mem[_3008 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3008 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3008 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3008 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3008 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3008 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3008 + ceil32(return_data.size) + 457
                                                                u = _3008 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3008 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3008 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3008 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15803 = mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3008 + ceil32(return_data.size) + return_data.size + 261
                                                                _16005 = mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16005
                                                                require return_data.size >= _15803 + (32 * _16005) + 32
                                                                t = _3008 + ceil32(return_data.size) + _15803 + 293
                                                                u = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _16005:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_3181 + _3008 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3008 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_3008 + 168 len _3181 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_3008 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3008 + 232] = mem[idx + _3008 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3008 + 232]
                                                            if not mem[96]:
                                                                mem[_3008 + 164] = 2
                                                                mem[64] = _3008 + 260
                                                                mem[_3008 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + 228] = address(cd[36])
                                                                mem[_3008 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + 296] = 0
                                                                mem[_3008 + 328] = 160
                                                                mem[_3008 + 424] = 2
                                                                s = 0
                                                                t = _3008 + 456
                                                                u = _3008 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + 360] = this.address
                                                                mem[_3008 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3008 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15626 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15804 = mem[_15626]
                                                                require mem[_15626] <= test266151307()
                                                                require _15626 + mem[_15626] + 31 < _15626 + return_data.size
                                                                _16006 = mem[_15626 + mem[_15626]]
                                                                if mem[_15626 + mem[_15626]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15626 + ceil32(return_data.size) + ceil32(32 * mem[_15626 + mem[_15626]]) + 1 > test266151307() or ceil32(32 * mem[_15626 + mem[_15626]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15626 + ceil32(return_data.size) + ceil32(32 * mem[_15626 + mem[_15626]]) + 1
                                                                mem[_15626 + ceil32(return_data.size)] = _16006
                                                                require return_data.size >= _15804 + (32 * _16006) + 32
                                                                t = _15626 + _15804 + 32
                                                                u = _15626 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _16006:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3008 + 164] = 2
                                                                mem[64] = _3008 + 260
                                                                mem[_3008 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + 228] = address(cd[36])
                                                                mem[_3008 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + 296] = 0
                                                                mem[_3008 + 328] = 160
                                                                mem[_3008 + 424] = 2
                                                                s = 0
                                                                t = _3008 + 456
                                                                u = _3008 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + 360] = this.address
                                                                mem[_3008 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3008 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15627 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15805 = mem[_15627]
                                                                require mem[_15627] <= test266151307()
                                                                require _15627 + mem[_15627] + 31 < _15627 + return_data.size
                                                                _16007 = mem[_15627 + mem[_15627]]
                                                                if mem[_15627 + mem[_15627]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15627 + ceil32(return_data.size) + ceil32(32 * mem[_15627 + mem[_15627]]) + 1 > test266151307() or ceil32(32 * mem[_15627 + mem[_15627]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15627 + ceil32(return_data.size) + ceil32(32 * mem[_15627 + mem[_15627]]) + 1
                                                                mem[_15627 + ceil32(return_data.size)] = _16007
                                                                require return_data.size >= _15805 + (32 * _16007) + 32
                                                                t = _15627 + _15805 + 32
                                                                u = _15627 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _16007:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_3008 + 164] = return_data.size
                                                            mem[_3008 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3008 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3008 + ceil32(return_data.size) + 233] = mem[idx + _3008 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3008 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_3008 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3008 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3008 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3008 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3008 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3008 + ceil32(return_data.size) + 457
                                                                u = _3008 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3008 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3008 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3008 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15806 = mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3008 + ceil32(return_data.size) + return_data.size + 261
                                                                _16008 = mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16008
                                                                require return_data.size >= _15806 + (32 * _16008) + 32
                                                                t = _3008 + ceil32(return_data.size) + _15806 + 293
                                                                u = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _16008:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_3008 + 196] == bool(mem[_3008 + 196])
                                                                if not mem[_3008 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3008 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3008 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3008 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3008 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3008 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3008 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3008 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3008 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3008 + ceil32(return_data.size) + 457
                                                                u = _3008 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3008 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3008 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3008 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3008 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15807 = mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3008 + ceil32(return_data.size) + return_data.size + 261
                                                                _16009 = mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3008 + ceil32(return_data.size) + mem[_3008 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2824) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3008 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _16009
                                                                require return_data.size >= _15807 + (32 * _16009) + 32
                                                                t = _3008 + ceil32(return_data.size) + _15807 + 293
                                                                u = _3008 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _16009:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                            else:
                                                t = 10
                                                u = 1
                                                s = mem[_2822 + 31 len 1]
                                                while s > 1:
                                                    if t > -1 / t:
                                                        revert with 0, 17
                                                    if not bool(s):
                                                        t = t * t
                                                        u = u
                                                        s = uint255(s) * 0.5
                                                        continue 
                                                    t = t * t
                                                    u = t * u
                                                    s = uint255(s) * 0.5
                                                    continue 
                                                if u > -1 / t:
                                                    revert with 0, 17
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and t * u > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]:
                                                    _9553 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                    _9554 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_9554 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_9554 + 36 len 28]
                                                    mem[64] = _9553 + 164
                                                    mem[_9553 + 100] = 32
                                                    mem[_9553 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10251 = mem[_9554]
                                                    s = 0
                                                    while s < _10251:
                                                        mem[s + _9553 + 164] = mem[s + _9554 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_10251) <= _10251:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9553 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_9553 + 168 len _10251 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_9553 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9553 + 232] = mem[idx + _9553 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9553 + 232]
                                                            if not mem[96]:
                                                                mem[_9553 + 164] = 2
                                                                mem[64] = _9553 + 260
                                                                mem[_9553 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + 228] = address(cd[36])
                                                                mem[_9553 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + 296] = 0
                                                                mem[_9553 + 328] = 160
                                                                mem[_9553 + 424] = 2
                                                                s = 0
                                                                t = _9553 + 456
                                                                u = _9553 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9553 + 360] = this.address
                                                                mem[_9553 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9553 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20254 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20444 = mem[_20254]
                                                                require mem[_20254] <= test266151307()
                                                                require _20254 + mem[_20254] + 31 < _20254 + return_data.size
                                                                _20588 = mem[_20254 + mem[_20254]]
                                                                if mem[_20254 + mem[_20254]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20254 + ceil32(return_data.size) + ceil32(32 * mem[_20254 + mem[_20254]]) + 1 > test266151307() or ceil32(32 * mem[_20254 + mem[_20254]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20254 + ceil32(return_data.size) + ceil32(32 * mem[_20254 + mem[_20254]]) + 1
                                                                mem[_20254 + ceil32(return_data.size)] = _20588
                                                                require return_data.size >= _20444 + (32 * _20588) + 32
                                                                t = _20254 + _20444 + 32
                                                                u = _20254 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20588:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9553 + 164] = 2
                                                                mem[64] = _9553 + 260
                                                                mem[_9553 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + 228] = address(cd[36])
                                                                mem[_9553 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + 296] = 0
                                                                mem[_9553 + 328] = 160
                                                                mem[_9553 + 424] = 2
                                                                s = 0
                                                                t = _9553 + 456
                                                                u = _9553 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9553 + 360] = this.address
                                                                mem[_9553 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9553 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20255 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20445 = mem[_20255]
                                                                require mem[_20255] <= test266151307()
                                                                require _20255 + mem[_20255] + 31 < _20255 + return_data.size
                                                                _20589 = mem[_20255 + mem[_20255]]
                                                                if mem[_20255 + mem[_20255]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20255 + ceil32(return_data.size) + ceil32(32 * mem[_20255 + mem[_20255]]) + 1 > test266151307() or ceil32(32 * mem[_20255 + mem[_20255]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20255 + ceil32(return_data.size) + ceil32(32 * mem[_20255 + mem[_20255]]) + 1
                                                                mem[_20255 + ceil32(return_data.size)] = _20589
                                                                require return_data.size >= _20445 + (32 * _20589) + 32
                                                                t = _20255 + _20445 + 32
                                                                u = _20255 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20589:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_9553 + 164] = return_data.size
                                                            mem[_9553 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9553 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9553 + ceil32(return_data.size) + 233] = mem[idx + _9553 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9553 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_9553 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9553 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9553 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9553 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9553 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9553 + ceil32(return_data.size) + 457
                                                                w = _9553 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9553 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9553 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9553 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9553 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20446 = mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9553 + ceil32(return_data.size) + return_data.size + 261
                                                                _20590 = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20446 + (32 * _20590) + 32
                                                                t = _9553 + ceil32(return_data.size) + _20446 + 293
                                                                u = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20590:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_9553 + 196] == bool(mem[_9553 + 196])
                                                                if not mem[_9553 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9553 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9553 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9553 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9553 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9553 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9553 + ceil32(return_data.size) + 457
                                                                w = _9553 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9553 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9553 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9553 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9553 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20447 = mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9553 + ceil32(return_data.size) + return_data.size + 261
                                                                _20591 = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20447 + (32 * _20591) + 32
                                                                t = _9553 + ceil32(return_data.size) + _20447 + 293
                                                                u = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20591:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_10251 + _9553 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9553 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_9553 + 168 len _10251 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_9553 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9553 + 232] = mem[idx + _9553 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9553 + 232]
                                                            if not mem[96]:
                                                                mem[_9553 + 164] = 2
                                                                mem[64] = _9553 + 260
                                                                mem[_9553 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + 228] = address(cd[36])
                                                                mem[_9553 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + 296] = 0
                                                                mem[_9553 + 328] = 160
                                                                mem[_9553 + 424] = 2
                                                                s = 0
                                                                t = _9553 + 456
                                                                u = _9553 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9553 + 360] = this.address
                                                                mem[_9553 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9553 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20262 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20448 = mem[_20262]
                                                                require mem[_20262] <= test266151307()
                                                                require _20262 + mem[_20262] + 31 < _20262 + return_data.size
                                                                _20592 = mem[_20262 + mem[_20262]]
                                                                if mem[_20262 + mem[_20262]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20262 + ceil32(return_data.size) + ceil32(32 * mem[_20262 + mem[_20262]]) + 1 > test266151307() or ceil32(32 * mem[_20262 + mem[_20262]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20262 + ceil32(return_data.size) + ceil32(32 * mem[_20262 + mem[_20262]]) + 1
                                                                mem[_20262 + ceil32(return_data.size)] = _20592
                                                                require return_data.size >= _20448 + (32 * _20592) + 32
                                                                t = _20262 + _20448 + 32
                                                                u = _20262 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20592:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9553 + 164] = 2
                                                                mem[64] = _9553 + 260
                                                                mem[_9553 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + 228] = address(cd[36])
                                                                mem[_9553 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + 296] = 0
                                                                mem[_9553 + 328] = 160
                                                                mem[_9553 + 424] = 2
                                                                s = 0
                                                                t = _9553 + 456
                                                                u = _9553 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_9553 + 360] = this.address
                                                                mem[_9553 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9553 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20263 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20449 = mem[_20263]
                                                                require mem[_20263] <= test266151307()
                                                                require _20263 + mem[_20263] + 31 < _20263 + return_data.size
                                                                _20593 = mem[_20263 + mem[_20263]]
                                                                if mem[_20263 + mem[_20263]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20263 + ceil32(return_data.size) + ceil32(32 * mem[_20263 + mem[_20263]]) + 1 > test266151307() or ceil32(32 * mem[_20263 + mem[_20263]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20263 + ceil32(return_data.size) + ceil32(32 * mem[_20263 + mem[_20263]]) + 1
                                                                mem[_20263 + ceil32(return_data.size)] = _20593
                                                                require return_data.size >= _20449 + (32 * _20593) + 32
                                                                t = _20263 + _20449 + 32
                                                                u = _20263 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20593:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_9553 + 164] = return_data.size
                                                            mem[_9553 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9553 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _9553 + ceil32(return_data.size) + 233] = mem[idx + _9553 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_9553 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_9553 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9553 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9553 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9553 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9553 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9553 + ceil32(return_data.size) + 457
                                                                w = _9553 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9553 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9553 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9553 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9553 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20450 = mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9553 + ceil32(return_data.size) + return_data.size + 261
                                                                _20594 = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20450 + (32 * _20594) + 32
                                                                t = _9553 + ceil32(return_data.size) + _20450 + 293
                                                                u = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20594:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_9553 + 196] == bool(mem[_9553 + 196])
                                                                if not mem[_9553 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_9553 + ceil32(return_data.size) + 165] = 2
                                                                mem[_9553 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_9553 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_9553 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_9553 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_9553 + ceil32(return_data.size) + 297] = 0
                                                                mem[_9553 + ceil32(return_data.size) + 329] = 160
                                                                mem[_9553 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _9553 + ceil32(return_data.size) + 457
                                                                w = _9553 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_9553 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_9553 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9553 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9553 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20451 = mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9553 + ceil32(return_data.size) + return_data.size + 261
                                                                _20595 = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_9553 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_9553 + ceil32(return_data.size) + mem[_9553 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20451 + (32 * _20595) + 32
                                                                t = _9553 + ceil32(return_data.size) + _20451 + 293
                                                                u = _9553 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20595:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9704 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_9704]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _10448 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                    _10449 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_10449 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_10449 + 36 len 28]
                                                    mem[64] = _10448 + 164
                                                    mem[_10448 + 100] = 32
                                                    mem[_10448 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _10995 = mem[_10449]
                                                    s = 0
                                                    while s < _10995:
                                                        mem[s + _10448 + 164] = mem[s + _10449 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_10995) <= _10995:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10448 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_10448 + 168 len _10995 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_10448 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10448 + 232] = mem[idx + _10448 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10448 + 232]
                                                            if not mem[96]:
                                                                mem[_10448 + 164] = 2
                                                                mem[64] = _10448 + 260
                                                                mem[_10448 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + 228] = address(cd[36])
                                                                mem[_10448 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + 296] = 0
                                                                mem[_10448 + 328] = 160
                                                                mem[_10448 + 424] = 2
                                                                s = 0
                                                                t = _10448 + 456
                                                                u = _10448 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10448 + 360] = this.address
                                                                mem[_10448 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10448 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20270 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20452 = mem[_20270]
                                                                require mem[_20270] <= test266151307()
                                                                require _20270 + mem[_20270] + 31 < _20270 + return_data.size
                                                                _20596 = mem[_20270 + mem[_20270]]
                                                                if mem[_20270 + mem[_20270]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20270 + ceil32(return_data.size) + ceil32(32 * mem[_20270 + mem[_20270]]) + 1 > test266151307() or ceil32(32 * mem[_20270 + mem[_20270]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20270 + ceil32(return_data.size) + ceil32(32 * mem[_20270 + mem[_20270]]) + 1
                                                                mem[_20270 + ceil32(return_data.size)] = _20596
                                                                require return_data.size >= _20452 + (32 * _20596) + 32
                                                                t = _20270 + _20452 + 32
                                                                u = _20270 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20596:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10448 + 164] = 2
                                                                mem[64] = _10448 + 260
                                                                mem[_10448 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + 228] = address(cd[36])
                                                                mem[_10448 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + 296] = 0
                                                                mem[_10448 + 328] = 160
                                                                mem[_10448 + 424] = 2
                                                                s = 0
                                                                t = _10448 + 456
                                                                u = _10448 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10448 + 360] = this.address
                                                                mem[_10448 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10448 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20271 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20453 = mem[_20271]
                                                                require mem[_20271] <= test266151307()
                                                                require _20271 + mem[_20271] + 31 < _20271 + return_data.size
                                                                _20597 = mem[_20271 + mem[_20271]]
                                                                if mem[_20271 + mem[_20271]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20271 + ceil32(return_data.size) + ceil32(32 * mem[_20271 + mem[_20271]]) + 1 > test266151307() or ceil32(32 * mem[_20271 + mem[_20271]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20271 + ceil32(return_data.size) + ceil32(32 * mem[_20271 + mem[_20271]]) + 1
                                                                mem[_20271 + ceil32(return_data.size)] = _20597
                                                                require return_data.size >= _20453 + (32 * _20597) + 32
                                                                t = _20271 + _20453 + 32
                                                                u = _20271 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20597:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_10448 + 164] = return_data.size
                                                            mem[_10448 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10448 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10448 + ceil32(return_data.size) + 233] = mem[idx + _10448 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10448 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_10448 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10448 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10448 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10448 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10448 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10448 + ceil32(return_data.size) + 457
                                                                w = _10448 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10448 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10448 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10448 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10448 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20454 = mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10448 + ceil32(return_data.size) + return_data.size + 261
                                                                _20598 = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20454 + (32 * _20598) + 32
                                                                t = _10448 + ceil32(return_data.size) + _20454 + 293
                                                                u = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20598:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_10448 + 196] == bool(mem[_10448 + 196])
                                                                if not mem[_10448 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10448 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10448 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10448 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10448 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10448 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10448 + ceil32(return_data.size) + 457
                                                                w = _10448 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10448 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10448 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10448 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10448 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20455 = mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10448 + ceil32(return_data.size) + return_data.size + 261
                                                                _20599 = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20455 + (32 * _20599) + 32
                                                                t = _10448 + ceil32(return_data.size) + _20455 + 293
                                                                u = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20599:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_10995 + _10448 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10448 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_10448 + 168 len _10995 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_10448 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10448 + 232] = mem[idx + _10448 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10448 + 232]
                                                            if not mem[96]:
                                                                mem[_10448 + 164] = 2
                                                                mem[64] = _10448 + 260
                                                                mem[_10448 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + 228] = address(cd[36])
                                                                mem[_10448 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + 296] = 0
                                                                mem[_10448 + 328] = 160
                                                                mem[_10448 + 424] = 2
                                                                s = 0
                                                                t = _10448 + 456
                                                                u = _10448 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10448 + 360] = this.address
                                                                mem[_10448 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10448 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20278 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20456 = mem[_20278]
                                                                require mem[_20278] <= test266151307()
                                                                require _20278 + mem[_20278] + 31 < _20278 + return_data.size
                                                                _20600 = mem[_20278 + mem[_20278]]
                                                                if mem[_20278 + mem[_20278]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20278 + ceil32(return_data.size) + ceil32(32 * mem[_20278 + mem[_20278]]) + 1 > test266151307() or ceil32(32 * mem[_20278 + mem[_20278]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20278 + ceil32(return_data.size) + ceil32(32 * mem[_20278 + mem[_20278]]) + 1
                                                                mem[_20278 + ceil32(return_data.size)] = _20600
                                                                require return_data.size >= _20456 + (32 * _20600) + 32
                                                                t = _20278 + _20456 + 32
                                                                u = _20278 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20600:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10448 + 164] = 2
                                                                mem[64] = _10448 + 260
                                                                mem[_10448 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + 228] = address(cd[36])
                                                                mem[_10448 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + 296] = 0
                                                                mem[_10448 + 328] = 160
                                                                mem[_10448 + 424] = 2
                                                                s = 0
                                                                t = _10448 + 456
                                                                u = _10448 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_10448 + 360] = this.address
                                                                mem[_10448 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _10448 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20279 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20457 = mem[_20279]
                                                                require mem[_20279] <= test266151307()
                                                                require _20279 + mem[_20279] + 31 < _20279 + return_data.size
                                                                _20601 = mem[_20279 + mem[_20279]]
                                                                if mem[_20279 + mem[_20279]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20279 + ceil32(return_data.size) + ceil32(32 * mem[_20279 + mem[_20279]]) + 1 > test266151307() or ceil32(32 * mem[_20279 + mem[_20279]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20279 + ceil32(return_data.size) + ceil32(32 * mem[_20279 + mem[_20279]]) + 1
                                                                mem[_20279 + ceil32(return_data.size)] = _20601
                                                                require return_data.size >= _20457 + (32 * _20601) + 32
                                                                t = _20279 + _20457 + 32
                                                                u = _20279 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20601:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_10448 + 164] = return_data.size
                                                            mem[_10448 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10448 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _10448 + ceil32(return_data.size) + 233] = mem[idx + _10448 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_10448 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_10448 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10448 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10448 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10448 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10448 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10448 + ceil32(return_data.size) + 457
                                                                w = _10448 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10448 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10448 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10448 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10448 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20458 = mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10448 + ceil32(return_data.size) + return_data.size + 261
                                                                _20602 = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20458 + (32 * _20602) + 32
                                                                t = _10448 + ceil32(return_data.size) + _20458 + 293
                                                                u = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20602:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_10448 + 196] == bool(mem[_10448 + 196])
                                                                if not mem[_10448 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_10448 + ceil32(return_data.size) + 165] = 2
                                                                mem[_10448 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_10448 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_10448 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_10448 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_10448 + ceil32(return_data.size) + 297] = 0
                                                                mem[_10448 + ceil32(return_data.size) + 329] = 160
                                                                mem[_10448 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                v = _10448 + ceil32(return_data.size) + 457
                                                                w = _10448 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[v] = mem[w + 12 len 20]
                                                                    s = s + 1
                                                                    v = v + 32
                                                                    w = w + 32
                                                                    continue 
                                                                mem[_10448 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_10448 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10448 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_10448 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20459 = mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10448 + ceil32(return_data.size) + return_data.size + 261
                                                                _20603 = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_10448 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10448 + ceil32(return_data.size) + mem[_10448 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20459 + (32 * _20603) + 32
                                                                t = _10448 + ceil32(return_data.size) + _20459 + 293
                                                                u = _10448 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20603:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                        if idx >= ('cd', 68).length:
                                            revert with 0, 50
                                        require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                        mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                                        mem[32] = 1
                                        sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])] = 1
                                        if sub_8cf086ad > -2:
                                            revert with 0, 17
                                        sub_8cf086ad++
                                else:
                                    if bool(bool(mem[_2814 + 31 len 1] < 78)) or bool(bool(mem[_2814 + 31 len 1] < 32)):
                                        if Mask(112, 0, _2803) and cd[((32 * idx) + cd[100] + 36)] > -1 / Mask(112, 0, _2803):
                                            revert with 0, 17
                                        if not 10^mem[_2814 + 31 len 1]:
                                            revert with 0, 18
                                        if cd[196] <= Mask(112, 0, _2803) * cd[((32 * idx) + cd[100] + 36)] / 10^mem[_2814 + 31 len 1]:
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            if idx >= ('cd', 100).length:
                                                revert with 0, 50
                                            if idx >= ('cd', 132).length:
                                                revert with 0, 50
                                            if cd[164] and cd[((32 * idx) + cd[132] + 36)] > -1 / cd[164]:
                                                revert with 0, 17
                                            require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                            staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2830 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _2836 = mem[_2830]
                                            require mem[_2830] == mem[_2830 + 31 len 1]
                                            if not mem[_2830 + 31 len 1]:
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 1 > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]:
                                                    _2883 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _2884 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_2884 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2884 + 36 len 28]
                                                    mem[64] = _2883 + 164
                                                    mem[_2883 + 100] = 32
                                                    mem[_2883 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _2979 = mem[_2884]
                                                    s = 0
                                                    while s < _2979:
                                                        mem[s + _2883 + 164] = mem[s + _2884 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_2979) <= _2979:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2883 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2883 + 168 len _2979 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2883 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2883 + 232] = mem[idx + _2883 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2883 + 232]
                                                            if not mem[96]:
                                                                mem[_2883 + 164] = 2
                                                                mem[64] = _2883 + 260
                                                                mem[_2883 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + 228] = address(cd[36])
                                                                mem[_2883 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + 296] = 0
                                                                mem[_2883 + 328] = 160
                                                                mem[_2883 + 424] = 2
                                                                s = 0
                                                                t = _2883 + 456
                                                                u = _2883 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + 360] = this.address
                                                                mem[_2883 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2883 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15566 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15776 = mem[_15566]
                                                                require mem[_15566] <= test266151307()
                                                                require _15566 + mem[_15566] + 31 < _15566 + return_data.size
                                                                _15970 = mem[_15566 + mem[_15566]]
                                                                if mem[_15566 + mem[_15566]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15566 + ceil32(return_data.size) + ceil32(32 * mem[_15566 + mem[_15566]]) + 1 > test266151307() or ceil32(32 * mem[_15566 + mem[_15566]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15566 + ceil32(return_data.size) + ceil32(32 * mem[_15566 + mem[_15566]]) + 1
                                                                mem[_15566 + ceil32(return_data.size)] = _15970
                                                                require return_data.size >= _15776 + (32 * _15970) + 32
                                                                t = _15566 + _15776 + 32
                                                                u = _15566 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15970:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2883 + 164] = 2
                                                                mem[64] = _2883 + 260
                                                                mem[_2883 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + 228] = address(cd[36])
                                                                mem[_2883 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + 296] = 0
                                                                mem[_2883 + 328] = 160
                                                                mem[_2883 + 424] = 2
                                                                s = 0
                                                                t = _2883 + 456
                                                                u = _2883 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + 360] = this.address
                                                                mem[_2883 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2883 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15567 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15777 = mem[_15567]
                                                                require mem[_15567] <= test266151307()
                                                                require _15567 + mem[_15567] + 31 < _15567 + return_data.size
                                                                _15971 = mem[_15567 + mem[_15567]]
                                                                if mem[_15567 + mem[_15567]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15567 + ceil32(return_data.size) + ceil32(32 * mem[_15567 + mem[_15567]]) + 1 > test266151307() or ceil32(32 * mem[_15567 + mem[_15567]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15567 + ceil32(return_data.size) + ceil32(32 * mem[_15567 + mem[_15567]]) + 1
                                                                mem[_15567 + ceil32(return_data.size)] = _15971
                                                                require return_data.size >= _15777 + (32 * _15971) + 32
                                                                t = _15567 + _15777 + 32
                                                                u = _15567 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15971:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2883 + 164] = return_data.size
                                                            mem[_2883 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2883 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2883 + ceil32(return_data.size) + 233] = mem[idx + _2883 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2883 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2883 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2883 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2883 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2883 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2883 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2883 + ceil32(return_data.size) + 457
                                                                u = _2883 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2883 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2883 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2883 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15778 = mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2883 + ceil32(return_data.size) + return_data.size + 261
                                                                _15972 = mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15972
                                                                require return_data.size >= _15778 + (32 * _15972) + 32
                                                                t = _2883 + ceil32(return_data.size) + _15778 + 293
                                                                u = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15972:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2883 + 196] == bool(mem[_2883 + 196])
                                                                if not mem[_2883 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2883 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2883 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2883 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2883 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2883 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2883 + ceil32(return_data.size) + 457
                                                                u = _2883 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2883 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2883 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2883 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15779 = mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2883 + ceil32(return_data.size) + return_data.size + 261
                                                                _15973 = mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15973
                                                                require return_data.size >= _15779 + (32 * _15973) + 32
                                                                t = _2883 + ceil32(return_data.size) + _15779 + 293
                                                                u = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15973:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_2979 + _2883 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2883 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_2883 + 168 len _2979 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_2883 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2883 + 232] = mem[idx + _2883 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2883 + 232]
                                                            if not mem[96]:
                                                                mem[_2883 + 164] = 2
                                                                mem[64] = _2883 + 260
                                                                mem[_2883 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + 228] = address(cd[36])
                                                                mem[_2883 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + 296] = 0
                                                                mem[_2883 + 328] = 160
                                                                mem[_2883 + 424] = 2
                                                                s = 0
                                                                t = _2883 + 456
                                                                u = _2883 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + 360] = this.address
                                                                mem[_2883 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2883 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15574 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15780 = mem[_15574]
                                                                require mem[_15574] <= test266151307()
                                                                require _15574 + mem[_15574] + 31 < _15574 + return_data.size
                                                                _15974 = mem[_15574 + mem[_15574]]
                                                                if mem[_15574 + mem[_15574]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15574 + ceil32(return_data.size) + ceil32(32 * mem[_15574 + mem[_15574]]) + 1 > test266151307() or ceil32(32 * mem[_15574 + mem[_15574]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15574 + ceil32(return_data.size) + ceil32(32 * mem[_15574 + mem[_15574]]) + 1
                                                                mem[_15574 + ceil32(return_data.size)] = _15974
                                                                require return_data.size >= _15780 + (32 * _15974) + 32
                                                                t = _15574 + _15780 + 32
                                                                u = _15574 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15974:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2883 + 164] = 2
                                                                mem[64] = _2883 + 260
                                                                mem[_2883 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + 228] = address(cd[36])
                                                                mem[_2883 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + 296] = 0
                                                                mem[_2883 + 328] = 160
                                                                mem[_2883 + 424] = 2
                                                                s = 0
                                                                t = _2883 + 456
                                                                u = _2883 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + 360] = this.address
                                                                mem[_2883 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _2883 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15575 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15781 = mem[_15575]
                                                                require mem[_15575] <= test266151307()
                                                                require _15575 + mem[_15575] + 31 < _15575 + return_data.size
                                                                _15975 = mem[_15575 + mem[_15575]]
                                                                if mem[_15575 + mem[_15575]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15575 + ceil32(return_data.size) + ceil32(32 * mem[_15575 + mem[_15575]]) + 1 > test266151307() or ceil32(32 * mem[_15575 + mem[_15575]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15575 + ceil32(return_data.size) + ceil32(32 * mem[_15575 + mem[_15575]]) + 1
                                                                mem[_15575 + ceil32(return_data.size)] = _15975
                                                                require return_data.size >= _15781 + (32 * _15975) + 32
                                                                t = _15575 + _15781 + 32
                                                                u = _15575 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15975:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_2883 + 164] = return_data.size
                                                            mem[_2883 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2883 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _2883 + ceil32(return_data.size) + 233] = mem[idx + _2883 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_2883 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_2883 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2883 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2883 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2883 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2883 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2883 + ceil32(return_data.size) + 457
                                                                u = _2883 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2883 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2883 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2883 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15782 = mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2883 + ceil32(return_data.size) + return_data.size + 261
                                                                _15976 = mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15976
                                                                require return_data.size >= _15782 + (32 * _15976) + 32
                                                                t = _2883 + ceil32(return_data.size) + _15782 + 293
                                                                u = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15976:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_2883 + 196] == bool(mem[_2883 + 196])
                                                                if not mem[_2883 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_2883 + ceil32(return_data.size) + 165] = 2
                                                                mem[_2883 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_2883 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_2883 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_2883 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_2883 + ceil32(return_data.size) + 297] = 0
                                                                mem[_2883 + ceil32(return_data.size) + 329] = 160
                                                                mem[_2883 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _2883 + ceil32(return_data.size) + 457
                                                                u = _2883 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_2883 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_2883 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2883 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_2883 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15783 = mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2883 + ceil32(return_data.size) + return_data.size + 261
                                                                _15977 = mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2883 + ceil32(return_data.size) + mem[_2883 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_2883 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15977
                                                                require return_data.size >= _15783 + (32 * _15977) + 32
                                                                t = _2883 + ceil32(return_data.size) + _15783 + 293
                                                                u = _2883 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15977:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _2900 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_2900]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _3003 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _3004 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_3004 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_3004 + 36 len 28]
                                                    mem[64] = _3003 + 164
                                                    mem[_3003 + 100] = 32
                                                    mem[_3003 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _3176 = mem[_3004]
                                                    s = 0
                                                    while s < _3176:
                                                        mem[s + _3003 + 164] = mem[s + _3004 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_3176) <= _3176:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3003 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_3003 + 168 len _3176 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_3003 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3003 + 232] = mem[idx + _3003 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3003 + 232]
                                                            if not mem[96]:
                                                                mem[_3003 + 164] = 2
                                                                mem[64] = _3003 + 260
                                                                mem[_3003 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + 228] = address(cd[36])
                                                                mem[_3003 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + 296] = 0
                                                                mem[_3003 + 328] = 160
                                                                mem[_3003 + 424] = 2
                                                                s = 0
                                                                t = _3003 + 456
                                                                u = _3003 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + 360] = this.address
                                                                mem[_3003 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3003 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15582 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15784 = mem[_15582]
                                                                require mem[_15582] <= test266151307()
                                                                require _15582 + mem[_15582] + 31 < _15582 + return_data.size
                                                                _15978 = mem[_15582 + mem[_15582]]
                                                                if mem[_15582 + mem[_15582]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15582 + ceil32(return_data.size) + ceil32(32 * mem[_15582 + mem[_15582]]) + 1 > test266151307() or ceil32(32 * mem[_15582 + mem[_15582]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15582 + ceil32(return_data.size) + ceil32(32 * mem[_15582 + mem[_15582]]) + 1
                                                                mem[_15582 + ceil32(return_data.size)] = _15978
                                                                require return_data.size >= _15784 + (32 * _15978) + 32
                                                                t = _15582 + _15784 + 32
                                                                u = _15582 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15978:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3003 + 164] = 2
                                                                mem[64] = _3003 + 260
                                                                mem[_3003 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + 228] = address(cd[36])
                                                                mem[_3003 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + 296] = 0
                                                                mem[_3003 + 328] = 160
                                                                mem[_3003 + 424] = 2
                                                                s = 0
                                                                t = _3003 + 456
                                                                u = _3003 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + 360] = this.address
                                                                mem[_3003 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3003 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15583 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15785 = mem[_15583]
                                                                require mem[_15583] <= test266151307()
                                                                require _15583 + mem[_15583] + 31 < _15583 + return_data.size
                                                                _15979 = mem[_15583 + mem[_15583]]
                                                                if mem[_15583 + mem[_15583]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15583 + ceil32(return_data.size) + ceil32(32 * mem[_15583 + mem[_15583]]) + 1 > test266151307() or ceil32(32 * mem[_15583 + mem[_15583]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15583 + ceil32(return_data.size) + ceil32(32 * mem[_15583 + mem[_15583]]) + 1
                                                                mem[_15583 + ceil32(return_data.size)] = _15979
                                                                require return_data.size >= _15785 + (32 * _15979) + 32
                                                                t = _15583 + _15785 + 32
                                                                u = _15583 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15979:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_3003 + 164] = return_data.size
                                                            mem[_3003 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3003 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3003 + ceil32(return_data.size) + 233] = mem[idx + _3003 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3003 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_3003 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3003 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3003 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3003 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3003 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3003 + ceil32(return_data.size) + 457
                                                                u = _3003 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3003 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3003 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3003 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15786 = mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3003 + ceil32(return_data.size) + return_data.size + 261
                                                                _15980 = mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15980
                                                                require return_data.size >= _15786 + (32 * _15980) + 32
                                                                t = _3003 + ceil32(return_data.size) + _15786 + 293
                                                                u = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15980:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_3003 + 196] == bool(mem[_3003 + 196])
                                                                if not mem[_3003 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3003 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3003 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3003 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3003 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3003 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3003 + ceil32(return_data.size) + 457
                                                                u = _3003 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3003 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3003 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3003 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15787 = mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3003 + ceil32(return_data.size) + return_data.size + 261
                                                                _15981 = mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15981
                                                                require return_data.size >= _15787 + (32 * _15981) + 32
                                                                t = _3003 + ceil32(return_data.size) + _15787 + 293
                                                                u = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15981:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_3176 + _3003 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3003 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_3003 + 168 len _3176 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_3003 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3003 + 232] = mem[idx + _3003 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3003 + 232]
                                                            if not mem[96]:
                                                                mem[_3003 + 164] = 2
                                                                mem[64] = _3003 + 260
                                                                mem[_3003 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + 228] = address(cd[36])
                                                                mem[_3003 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + 296] = 0
                                                                mem[_3003 + 328] = 160
                                                                mem[_3003 + 424] = 2
                                                                s = 0
                                                                t = _3003 + 456
                                                                u = _3003 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + 360] = this.address
                                                                mem[_3003 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3003 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15590 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15788 = mem[_15590]
                                                                require mem[_15590] <= test266151307()
                                                                require _15590 + mem[_15590] + 31 < _15590 + return_data.size
                                                                _15982 = mem[_15590 + mem[_15590]]
                                                                if mem[_15590 + mem[_15590]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15590 + ceil32(return_data.size) + ceil32(32 * mem[_15590 + mem[_15590]]) + 1 > test266151307() or ceil32(32 * mem[_15590 + mem[_15590]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15590 + ceil32(return_data.size) + ceil32(32 * mem[_15590 + mem[_15590]]) + 1
                                                                mem[_15590 + ceil32(return_data.size)] = _15982
                                                                require return_data.size >= _15788 + (32 * _15982) + 32
                                                                t = _15590 + _15788 + 32
                                                                u = _15590 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15982:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3003 + 164] = 2
                                                                mem[64] = _3003 + 260
                                                                mem[_3003 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + 228] = address(cd[36])
                                                                mem[_3003 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + 296] = 0
                                                                mem[_3003 + 328] = 160
                                                                mem[_3003 + 424] = 2
                                                                s = 0
                                                                t = _3003 + 456
                                                                u = _3003 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + 360] = this.address
                                                                mem[_3003 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _3003 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _15591 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _15789 = mem[_15591]
                                                                require mem[_15591] <= test266151307()
                                                                require _15591 + mem[_15591] + 31 < _15591 + return_data.size
                                                                _15983 = mem[_15591 + mem[_15591]]
                                                                if mem[_15591 + mem[_15591]] > test266151307():
                                                                    revert with 0, 65
                                                                if _15591 + ceil32(return_data.size) + ceil32(32 * mem[_15591 + mem[_15591]]) + 1 > test266151307() or ceil32(32 * mem[_15591 + mem[_15591]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _15591 + ceil32(return_data.size) + ceil32(32 * mem[_15591 + mem[_15591]]) + 1
                                                                mem[_15591 + ceil32(return_data.size)] = _15983
                                                                require return_data.size >= _15789 + (32 * _15983) + 32
                                                                t = _15591 + _15789 + 32
                                                                u = _15591 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _15983:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_3003 + 164] = return_data.size
                                                            mem[_3003 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3003 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _3003 + ceil32(return_data.size) + 233] = mem[idx + _3003 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_3003 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_3003 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3003 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3003 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3003 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3003 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3003 + ceil32(return_data.size) + 457
                                                                u = _3003 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3003 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3003 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3003 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15790 = mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3003 + ceil32(return_data.size) + return_data.size + 261
                                                                _15984 = mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15984
                                                                require return_data.size >= _15790 + (32 * _15984) + 32
                                                                t = _3003 + ceil32(return_data.size) + _15790 + 293
                                                                u = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15984:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_3003 + 196] == bool(mem[_3003 + 196])
                                                                if not mem[_3003 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_3003 + ceil32(return_data.size) + 165] = 2
                                                                mem[_3003 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_3003 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_3003 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_3003 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_3003 + ceil32(return_data.size) + 297] = 0
                                                                mem[_3003 + ceil32(return_data.size) + 329] = 160
                                                                mem[_3003 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _3003 + ceil32(return_data.size) + 457
                                                                u = _3003 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_3003 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_3003 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3003 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_3003 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _15791 = mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3003 + ceil32(return_data.size) + return_data.size + 261
                                                                _15985 = mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3003 + ceil32(return_data.size) + mem[_3003 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_3003 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15985
                                                                require return_data.size >= _15791 + (32 * _15985) + 32
                                                                t = _3003 + ceil32(return_data.size) + _15791 + 293
                                                                u = _3003 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _15985:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                            else:
                                                if bool(bool(mem[_2830 + 31 len 1] < 78)) or bool(bool(mem[_2830 + 31 len 1] < 32)):
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 10^mem[_2830 + 31 len 1] > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^mem[_2830 + 31 len 1] / cd[((32 * idx) + cd[100] + 36)]:
                                                        _2975 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                        _2976 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_2976 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_2976 + 36 len 28]
                                                        mem[64] = _2975 + 164
                                                        mem[_2975 + 100] = 32
                                                        mem[_2975 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _3128 = mem[_2976]
                                                        s = 0
                                                        while s < _3128:
                                                            mem[s + _2975 + 164] = mem[s + _2976 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_3128) <= _3128:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2975 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_2975 + 168 len _3128 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_2975 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2975 + 232] = mem[idx + _2975 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2975 + 232]
                                                                if not mem[96]:
                                                                    mem[_2975 + 164] = 2
                                                                    mem[64] = _2975 + 260
                                                                    mem[_2975 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + 228] = address(cd[36])
                                                                    mem[_2975 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + 296] = 0
                                                                    mem[_2975 + 328] = 160
                                                                    mem[_2975 + 424] = 2
                                                                    s = 0
                                                                    t = _2975 + 456
                                                                    u = _2975 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + 360] = this.address
                                                                    mem[_2975 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2975 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15534 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15760 = mem[_15534]
                                                                    require mem[_15534] <= test266151307()
                                                                    require _15534 + mem[_15534] + 31 < _15534 + return_data.size
                                                                    _15954 = mem[_15534 + mem[_15534]]
                                                                    if mem[_15534 + mem[_15534]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15534 + ceil32(return_data.size) + ceil32(32 * mem[_15534 + mem[_15534]]) + 1 > test266151307() or ceil32(32 * mem[_15534 + mem[_15534]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15534 + ceil32(return_data.size) + ceil32(32 * mem[_15534 + mem[_15534]]) + 1
                                                                    mem[_15534 + ceil32(return_data.size)] = _15954
                                                                    require return_data.size >= _15760 + (32 * _15954) + 32
                                                                    t = _15534 + _15760 + 32
                                                                    u = _15534 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15954:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2975 + 164] = 2
                                                                    mem[64] = _2975 + 260
                                                                    mem[_2975 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + 228] = address(cd[36])
                                                                    mem[_2975 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + 296] = 0
                                                                    mem[_2975 + 328] = 160
                                                                    mem[_2975 + 424] = 2
                                                                    s = 0
                                                                    t = _2975 + 456
                                                                    u = _2975 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + 360] = this.address
                                                                    mem[_2975 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2975 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15535 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15761 = mem[_15535]
                                                                    require mem[_15535] <= test266151307()
                                                                    require _15535 + mem[_15535] + 31 < _15535 + return_data.size
                                                                    _15955 = mem[_15535 + mem[_15535]]
                                                                    if mem[_15535 + mem[_15535]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15535 + ceil32(return_data.size) + ceil32(32 * mem[_15535 + mem[_15535]]) + 1 > test266151307() or ceil32(32 * mem[_15535 + mem[_15535]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15535 + ceil32(return_data.size) + ceil32(32 * mem[_15535 + mem[_15535]]) + 1
                                                                    mem[_15535 + ceil32(return_data.size)] = _15955
                                                                    require return_data.size >= _15761 + (32 * _15955) + 32
                                                                    t = _15535 + _15761 + 32
                                                                    u = _15535 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15955:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_2975 + 164] = return_data.size
                                                                mem[_2975 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2975 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2975 + ceil32(return_data.size) + 233] = mem[idx + _2975 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2975 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_2975 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2975 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2975 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2975 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2975 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2975 + ceil32(return_data.size) + 457
                                                                    u = _2975 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2975 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2975 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2975 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15762 = mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2975 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15956 = mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15956
                                                                    require return_data.size >= _15762 + (32 * _15956) + 32
                                                                    t = _2975 + ceil32(return_data.size) + _15762 + 293
                                                                    u = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15956:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_2975 + 196] == bool(mem[_2975 + 196])
                                                                    if not mem[_2975 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2975 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2975 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2975 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2975 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2975 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2975 + ceil32(return_data.size) + 457
                                                                    u = _2975 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2975 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2975 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2975 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15763 = mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2975 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15957 = mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15957
                                                                    require return_data.size >= _15763 + (32 * _15957) + 32
                                                                    t = _2975 + ceil32(return_data.size) + _15763 + 293
                                                                    u = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15957:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_3128 + _2975 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_2975 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_2975 + 168 len _3128 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_2975 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2975 + 232] = mem[idx + _2975 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2975 + 232]
                                                                if not mem[96]:
                                                                    mem[_2975 + 164] = 2
                                                                    mem[64] = _2975 + 260
                                                                    mem[_2975 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + 228] = address(cd[36])
                                                                    mem[_2975 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + 296] = 0
                                                                    mem[_2975 + 328] = 160
                                                                    mem[_2975 + 424] = 2
                                                                    s = 0
                                                                    t = _2975 + 456
                                                                    u = _2975 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + 360] = this.address
                                                                    mem[_2975 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2975 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15542 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15764 = mem[_15542]
                                                                    require mem[_15542] <= test266151307()
                                                                    require _15542 + mem[_15542] + 31 < _15542 + return_data.size
                                                                    _15958 = mem[_15542 + mem[_15542]]
                                                                    if mem[_15542 + mem[_15542]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15542 + ceil32(return_data.size) + ceil32(32 * mem[_15542 + mem[_15542]]) + 1 > test266151307() or ceil32(32 * mem[_15542 + mem[_15542]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15542 + ceil32(return_data.size) + ceil32(32 * mem[_15542 + mem[_15542]]) + 1
                                                                    mem[_15542 + ceil32(return_data.size)] = _15958
                                                                    require return_data.size >= _15764 + (32 * _15958) + 32
                                                                    t = _15542 + _15764 + 32
                                                                    u = _15542 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15958:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2975 + 164] = 2
                                                                    mem[64] = _2975 + 260
                                                                    mem[_2975 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + 228] = address(cd[36])
                                                                    mem[_2975 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + 296] = 0
                                                                    mem[_2975 + 328] = 160
                                                                    mem[_2975 + 424] = 2
                                                                    s = 0
                                                                    t = _2975 + 456
                                                                    u = _2975 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + 360] = this.address
                                                                    mem[_2975 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _2975 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15543 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15765 = mem[_15543]
                                                                    require mem[_15543] <= test266151307()
                                                                    require _15543 + mem[_15543] + 31 < _15543 + return_data.size
                                                                    _15959 = mem[_15543 + mem[_15543]]
                                                                    if mem[_15543 + mem[_15543]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15543 + ceil32(return_data.size) + ceil32(32 * mem[_15543 + mem[_15543]]) + 1 > test266151307() or ceil32(32 * mem[_15543 + mem[_15543]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15543 + ceil32(return_data.size) + ceil32(32 * mem[_15543 + mem[_15543]]) + 1
                                                                    mem[_15543 + ceil32(return_data.size)] = _15959
                                                                    require return_data.size >= _15765 + (32 * _15959) + 32
                                                                    t = _15543 + _15765 + 32
                                                                    u = _15543 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15959:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_2975 + 164] = return_data.size
                                                                mem[_2975 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2975 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _2975 + ceil32(return_data.size) + 233] = mem[idx + _2975 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_2975 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_2975 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2975 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2975 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2975 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2975 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2975 + ceil32(return_data.size) + 457
                                                                    u = _2975 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2975 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2975 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2975 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15766 = mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2975 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15960 = mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15960
                                                                    require return_data.size >= _15766 + (32 * _15960) + 32
                                                                    t = _2975 + ceil32(return_data.size) + _15766 + 293
                                                                    u = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15960:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_2975 + 196] == bool(mem[_2975 + 196])
                                                                    if not mem[_2975 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_2975 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_2975 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_2975 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_2975 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_2975 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_2975 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_2975 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_2975 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _2975 + ceil32(return_data.size) + 457
                                                                    u = _2975 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_2975 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_2975 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_2975 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_2975 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15767 = mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _2975 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15961 = mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_2975 + ceil32(return_data.size) + mem[_2975 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_2975 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15961
                                                                    require return_data.size >= _15767 + (32 * _15961) + 32
                                                                    t = _2975 + ceil32(return_data.size) + _15767 + 293
                                                                    u = _2975 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15961:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _3002 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_3002]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _3169 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                        _3170 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_3170 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_3170 + 36 len 28]
                                                        mem[64] = _3169 + 164
                                                        mem[_3169 + 100] = 32
                                                        mem[_3169 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _3409 = mem[_3170]
                                                        s = 0
                                                        while s < _3409:
                                                            mem[s + _3169 + 164] = mem[s + _3170 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_3409) <= _3409:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3169 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_3169 + 168 len _3409 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_3169 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3169 + 232] = mem[idx + _3169 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3169 + 232]
                                                                if not mem[96]:
                                                                    mem[_3169 + 164] = 2
                                                                    mem[64] = _3169 + 260
                                                                    mem[_3169 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + 228] = address(cd[36])
                                                                    mem[_3169 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + 296] = 0
                                                                    mem[_3169 + 328] = 160
                                                                    mem[_3169 + 424] = 2
                                                                    s = 0
                                                                    t = _3169 + 456
                                                                    u = _3169 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + 360] = this.address
                                                                    mem[_3169 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3169 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15550 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15768 = mem[_15550]
                                                                    require mem[_15550] <= test266151307()
                                                                    require _15550 + mem[_15550] + 31 < _15550 + return_data.size
                                                                    _15962 = mem[_15550 + mem[_15550]]
                                                                    if mem[_15550 + mem[_15550]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15550 + ceil32(return_data.size) + ceil32(32 * mem[_15550 + mem[_15550]]) + 1 > test266151307() or ceil32(32 * mem[_15550 + mem[_15550]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15550 + ceil32(return_data.size) + ceil32(32 * mem[_15550 + mem[_15550]]) + 1
                                                                    mem[_15550 + ceil32(return_data.size)] = _15962
                                                                    require return_data.size >= _15768 + (32 * _15962) + 32
                                                                    t = _15550 + _15768 + 32
                                                                    u = _15550 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15962:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3169 + 164] = 2
                                                                    mem[64] = _3169 + 260
                                                                    mem[_3169 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + 228] = address(cd[36])
                                                                    mem[_3169 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + 296] = 0
                                                                    mem[_3169 + 328] = 160
                                                                    mem[_3169 + 424] = 2
                                                                    s = 0
                                                                    t = _3169 + 456
                                                                    u = _3169 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + 360] = this.address
                                                                    mem[_3169 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3169 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15551 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15769 = mem[_15551]
                                                                    require mem[_15551] <= test266151307()
                                                                    require _15551 + mem[_15551] + 31 < _15551 + return_data.size
                                                                    _15963 = mem[_15551 + mem[_15551]]
                                                                    if mem[_15551 + mem[_15551]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15551 + ceil32(return_data.size) + ceil32(32 * mem[_15551 + mem[_15551]]) + 1 > test266151307() or ceil32(32 * mem[_15551 + mem[_15551]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15551 + ceil32(return_data.size) + ceil32(32 * mem[_15551 + mem[_15551]]) + 1
                                                                    mem[_15551 + ceil32(return_data.size)] = _15963
                                                                    require return_data.size >= _15769 + (32 * _15963) + 32
                                                                    t = _15551 + _15769 + 32
                                                                    u = _15551 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15963:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_3169 + 164] = return_data.size
                                                                mem[_3169 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3169 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3169 + ceil32(return_data.size) + 233] = mem[idx + _3169 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3169 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_3169 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3169 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3169 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3169 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3169 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3169 + ceil32(return_data.size) + 457
                                                                    u = _3169 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3169 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3169 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3169 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15770 = mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3169 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15964 = mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15964
                                                                    require return_data.size >= _15770 + (32 * _15964) + 32
                                                                    t = _3169 + ceil32(return_data.size) + _15770 + 293
                                                                    u = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15964:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_3169 + 196] == bool(mem[_3169 + 196])
                                                                    if not mem[_3169 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3169 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3169 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3169 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3169 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3169 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3169 + ceil32(return_data.size) + 457
                                                                    u = _3169 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3169 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3169 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3169 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15771 = mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3169 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15965 = mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15965
                                                                    require return_data.size >= _15771 + (32 * _15965) + 32
                                                                    t = _3169 + ceil32(return_data.size) + _15771 + 293
                                                                    u = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15965:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_3409 + _3169 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_3169 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_3169 + 168 len _3409 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_3169 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3169 + 232] = mem[idx + _3169 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3169 + 232]
                                                                if not mem[96]:
                                                                    mem[_3169 + 164] = 2
                                                                    mem[64] = _3169 + 260
                                                                    mem[_3169 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + 228] = address(cd[36])
                                                                    mem[_3169 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + 296] = 0
                                                                    mem[_3169 + 328] = 160
                                                                    mem[_3169 + 424] = 2
                                                                    s = 0
                                                                    t = _3169 + 456
                                                                    u = _3169 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + 360] = this.address
                                                                    mem[_3169 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3169 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15558 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15772 = mem[_15558]
                                                                    require mem[_15558] <= test266151307()
                                                                    require _15558 + mem[_15558] + 31 < _15558 + return_data.size
                                                                    _15966 = mem[_15558 + mem[_15558]]
                                                                    if mem[_15558 + mem[_15558]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15558 + ceil32(return_data.size) + ceil32(32 * mem[_15558 + mem[_15558]]) + 1 > test266151307() or ceil32(32 * mem[_15558 + mem[_15558]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15558 + ceil32(return_data.size) + ceil32(32 * mem[_15558 + mem[_15558]]) + 1
                                                                    mem[_15558 + ceil32(return_data.size)] = _15966
                                                                    require return_data.size >= _15772 + (32 * _15966) + 32
                                                                    t = _15558 + _15772 + 32
                                                                    u = _15558 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15966:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3169 + 164] = 2
                                                                    mem[64] = _3169 + 260
                                                                    mem[_3169 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + 228] = address(cd[36])
                                                                    mem[_3169 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + 296] = 0
                                                                    mem[_3169 + 328] = 160
                                                                    mem[_3169 + 424] = 2
                                                                    s = 0
                                                                    t = _3169 + 456
                                                                    u = _3169 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + 360] = this.address
                                                                    mem[_3169 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _3169 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _15559 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _15773 = mem[_15559]
                                                                    require mem[_15559] <= test266151307()
                                                                    require _15559 + mem[_15559] + 31 < _15559 + return_data.size
                                                                    _15967 = mem[_15559 + mem[_15559]]
                                                                    if mem[_15559 + mem[_15559]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _15559 + ceil32(return_data.size) + ceil32(32 * mem[_15559 + mem[_15559]]) + 1 > test266151307() or ceil32(32 * mem[_15559 + mem[_15559]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _15559 + ceil32(return_data.size) + ceil32(32 * mem[_15559 + mem[_15559]]) + 1
                                                                    mem[_15559 + ceil32(return_data.size)] = _15967
                                                                    require return_data.size >= _15773 + (32 * _15967) + 32
                                                                    t = _15559 + _15773 + 32
                                                                    u = _15559 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _15967:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_3169 + 164] = return_data.size
                                                                mem[_3169 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3169 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _3169 + ceil32(return_data.size) + 233] = mem[idx + _3169 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_3169 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_3169 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3169 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3169 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3169 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3169 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3169 + ceil32(return_data.size) + 457
                                                                    u = _3169 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3169 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3169 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3169 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15774 = mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3169 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15968 = mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15968
                                                                    require return_data.size >= _15774 + (32 * _15968) + 32
                                                                    t = _3169 + ceil32(return_data.size) + _15774 + 293
                                                                    u = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15968:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_3169 + 196] == bool(mem[_3169 + 196])
                                                                    if not mem[_3169 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_3169 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_3169 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_3169 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_3169 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_3169 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_3169 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_3169 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_3169 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _3169 + ceil32(return_data.size) + 457
                                                                    u = _3169 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_3169 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_3169 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_3169 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_3169 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _15775 = mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _3169 + ceil32(return_data.size) + return_data.size + 261
                                                                    _15969 = mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_3169 + ceil32(return_data.size) + mem[_3169 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_2836) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_3169 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _15969
                                                                    require return_data.size >= _15775 + (32 * _15969) + 32
                                                                    t = _3169 + ceil32(return_data.size) + _15775 + 293
                                                                    u = _3169 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _15969:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                else:
                                                    t = 10
                                                    u = 1
                                                    s = mem[_2830 + 31 len 1]
                                                    while s > 1:
                                                        if t > -1 / t:
                                                            revert with 0, 17
                                                        if not bool(s):
                                                            t = t * t
                                                            u = u
                                                            s = uint255(s) * 0.5
                                                            continue 
                                                        t = t * t
                                                        u = t * u
                                                        s = uint255(s) * 0.5
                                                        continue 
                                                    if u > -1 / t:
                                                        revert with 0, 17
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and t * u > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]:
                                                        _9549 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _9550 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_9550 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_9550 + 36 len 28]
                                                        mem[64] = _9549 + 164
                                                        mem[_9549 + 100] = 32
                                                        mem[_9549 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _10233 = mem[_9550]
                                                        s = 0
                                                        while s < _10233:
                                                            mem[s + _9549 + 164] = mem[s + _9550 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_10233) <= _10233:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9549 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_9549 + 168 len _10233 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_9549 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9549 + 232] = mem[idx + _9549 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9549 + 232]
                                                                if not mem[96]:
                                                                    mem[_9549 + 164] = 2
                                                                    mem[64] = _9549 + 260
                                                                    mem[_9549 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + 228] = address(cd[36])
                                                                    mem[_9549 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + 296] = 0
                                                                    mem[_9549 + 328] = 160
                                                                    mem[_9549 + 424] = 2
                                                                    s = 0
                                                                    t = _9549 + 456
                                                                    u = _9549 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9549 + 360] = this.address
                                                                    mem[_9549 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9549 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20222 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20428 = mem[_20222]
                                                                    require mem[_20222] <= test266151307()
                                                                    require _20222 + mem[_20222] + 31 < _20222 + return_data.size
                                                                    _20572 = mem[_20222 + mem[_20222]]
                                                                    if mem[_20222 + mem[_20222]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20222 + ceil32(return_data.size) + ceil32(32 * mem[_20222 + mem[_20222]]) + 1 > test266151307() or ceil32(32 * mem[_20222 + mem[_20222]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20222 + ceil32(return_data.size) + ceil32(32 * mem[_20222 + mem[_20222]]) + 1
                                                                    mem[_20222 + ceil32(return_data.size)] = _20572
                                                                    require return_data.size >= _20428 + (32 * _20572) + 32
                                                                    t = _20222 + _20428 + 32
                                                                    u = _20222 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20572:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9549 + 164] = 2
                                                                    mem[64] = _9549 + 260
                                                                    mem[_9549 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + 228] = address(cd[36])
                                                                    mem[_9549 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + 296] = 0
                                                                    mem[_9549 + 328] = 160
                                                                    mem[_9549 + 424] = 2
                                                                    s = 0
                                                                    t = _9549 + 456
                                                                    u = _9549 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9549 + 360] = this.address
                                                                    mem[_9549 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9549 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20223 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20429 = mem[_20223]
                                                                    require mem[_20223] <= test266151307()
                                                                    require _20223 + mem[_20223] + 31 < _20223 + return_data.size
                                                                    _20573 = mem[_20223 + mem[_20223]]
                                                                    if mem[_20223 + mem[_20223]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20223 + ceil32(return_data.size) + ceil32(32 * mem[_20223 + mem[_20223]]) + 1 > test266151307() or ceil32(32 * mem[_20223 + mem[_20223]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20223 + ceil32(return_data.size) + ceil32(32 * mem[_20223 + mem[_20223]]) + 1
                                                                    mem[_20223 + ceil32(return_data.size)] = _20573
                                                                    require return_data.size >= _20429 + (32 * _20573) + 32
                                                                    t = _20223 + _20429 + 32
                                                                    u = _20223 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20573:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_9549 + 164] = return_data.size
                                                                mem[_9549 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9549 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9549 + ceil32(return_data.size) + 233] = mem[idx + _9549 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9549 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_9549 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9549 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9549 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9549 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9549 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9549 + ceil32(return_data.size) + 457
                                                                    w = _9549 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9549 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9549 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9549 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9549 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20430 = mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9549 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20574 = mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20574
                                                                    require return_data.size >= _20430 + (32 * _20574) + 32
                                                                    t = _9549 + ceil32(return_data.size) + _20430 + 293
                                                                    u = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20574:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_9549 + 196] == bool(mem[_9549 + 196])
                                                                    if not mem[_9549 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9549 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9549 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9549 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9549 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9549 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9549 + ceil32(return_data.size) + 457
                                                                    w = _9549 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9549 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9549 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9549 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9549 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20431 = mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9549 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20575 = mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20575
                                                                    require return_data.size >= _20431 + (32 * _20575) + 32
                                                                    t = _9549 + ceil32(return_data.size) + _20431 + 293
                                                                    u = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20575:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_10233 + _9549 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_9549 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_9549 + 168 len _10233 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_9549 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9549 + 232] = mem[idx + _9549 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9549 + 232]
                                                                if not mem[96]:
                                                                    mem[_9549 + 164] = 2
                                                                    mem[64] = _9549 + 260
                                                                    mem[_9549 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + 228] = address(cd[36])
                                                                    mem[_9549 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + 296] = 0
                                                                    mem[_9549 + 328] = 160
                                                                    mem[_9549 + 424] = 2
                                                                    s = 0
                                                                    t = _9549 + 456
                                                                    u = _9549 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9549 + 360] = this.address
                                                                    mem[_9549 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9549 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20230 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20432 = mem[_20230]
                                                                    require mem[_20230] <= test266151307()
                                                                    require _20230 + mem[_20230] + 31 < _20230 + return_data.size
                                                                    _20576 = mem[_20230 + mem[_20230]]
                                                                    if mem[_20230 + mem[_20230]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20230 + ceil32(return_data.size) + ceil32(32 * mem[_20230 + mem[_20230]]) + 1 > test266151307() or ceil32(32 * mem[_20230 + mem[_20230]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20230 + ceil32(return_data.size) + ceil32(32 * mem[_20230 + mem[_20230]]) + 1
                                                                    mem[_20230 + ceil32(return_data.size)] = _20576
                                                                    require return_data.size >= _20432 + (32 * _20576) + 32
                                                                    t = _20230 + _20432 + 32
                                                                    u = _20230 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20576:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9549 + 164] = 2
                                                                    mem[64] = _9549 + 260
                                                                    mem[_9549 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + 228] = address(cd[36])
                                                                    mem[_9549 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + 296] = 0
                                                                    mem[_9549 + 328] = 160
                                                                    mem[_9549 + 424] = 2
                                                                    s = 0
                                                                    t = _9549 + 456
                                                                    u = _9549 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_9549 + 360] = this.address
                                                                    mem[_9549 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _9549 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20231 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20433 = mem[_20231]
                                                                    require mem[_20231] <= test266151307()
                                                                    require _20231 + mem[_20231] + 31 < _20231 + return_data.size
                                                                    _20577 = mem[_20231 + mem[_20231]]
                                                                    if mem[_20231 + mem[_20231]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20231 + ceil32(return_data.size) + ceil32(32 * mem[_20231 + mem[_20231]]) + 1 > test266151307() or ceil32(32 * mem[_20231 + mem[_20231]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20231 + ceil32(return_data.size) + ceil32(32 * mem[_20231 + mem[_20231]]) + 1
                                                                    mem[_20231 + ceil32(return_data.size)] = _20577
                                                                    require return_data.size >= _20433 + (32 * _20577) + 32
                                                                    t = _20231 + _20433 + 32
                                                                    u = _20231 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20577:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_9549 + 164] = return_data.size
                                                                mem[_9549 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9549 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _9549 + ceil32(return_data.size) + 233] = mem[idx + _9549 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_9549 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_9549 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9549 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9549 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9549 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9549 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9549 + ceil32(return_data.size) + 457
                                                                    w = _9549 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9549 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9549 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9549 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9549 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20434 = mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9549 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20578 = mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20578
                                                                    require return_data.size >= _20434 + (32 * _20578) + 32
                                                                    t = _9549 + ceil32(return_data.size) + _20434 + 293
                                                                    u = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20578:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_9549 + 196] == bool(mem[_9549 + 196])
                                                                    if not mem[_9549 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_9549 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_9549 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_9549 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_9549 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_9549 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_9549 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_9549 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_9549 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _9549 + ceil32(return_data.size) + 457
                                                                    w = _9549 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_9549 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_9549 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_9549 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_9549 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20435 = mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _9549 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20579 = mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_9549 + ceil32(return_data.size) + mem[_9549 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_9549 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _20579
                                                                    require return_data.size >= _20435 + (32 * _20579) + 32
                                                                    t = _9549 + ceil32(return_data.size) + _20435 + 293
                                                                    u = _9549 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20579:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9655 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_9655]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _10395 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _10396 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_10396 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_10396 + 36 len 28]
                                                        mem[64] = _10395 + 164
                                                        mem[_10395 + 100] = 32
                                                        mem[_10395 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _10959 = mem[_10396]
                                                        s = 0
                                                        while s < _10959:
                                                            mem[s + _10395 + 164] = mem[s + _10396 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_10959) <= _10959:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10395 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_10395 + 168 len _10959 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_10395 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10395 + 232] = mem[idx + _10395 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10395 + 232]
                                                                if not mem[96]:
                                                                    mem[_10395 + 164] = 2
                                                                    mem[64] = _10395 + 260
                                                                    mem[_10395 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + 228] = address(cd[36])
                                                                    mem[_10395 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + 296] = 0
                                                                    mem[_10395 + 328] = 160
                                                                    mem[_10395 + 424] = 2
                                                                    s = 0
                                                                    t = _10395 + 456
                                                                    u = _10395 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10395 + 360] = this.address
                                                                    mem[_10395 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10395 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20238 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20436 = mem[_20238]
                                                                    require mem[_20238] <= test266151307()
                                                                    require _20238 + mem[_20238] + 31 < _20238 + return_data.size
                                                                    _20580 = mem[_20238 + mem[_20238]]
                                                                    if mem[_20238 + mem[_20238]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20238 + ceil32(return_data.size) + ceil32(32 * mem[_20238 + mem[_20238]]) + 1 > test266151307() or ceil32(32 * mem[_20238 + mem[_20238]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20238 + ceil32(return_data.size) + ceil32(32 * mem[_20238 + mem[_20238]]) + 1
                                                                    mem[_20238 + ceil32(return_data.size)] = _20580
                                                                    require return_data.size >= _20436 + (32 * _20580) + 32
                                                                    t = _20238 + _20436 + 32
                                                                    u = _20238 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20580:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10395 + 164] = 2
                                                                    mem[64] = _10395 + 260
                                                                    mem[_10395 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + 228] = address(cd[36])
                                                                    mem[_10395 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + 296] = 0
                                                                    mem[_10395 + 328] = 160
                                                                    mem[_10395 + 424] = 2
                                                                    s = 0
                                                                    t = _10395 + 456
                                                                    u = _10395 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10395 + 360] = this.address
                                                                    mem[_10395 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10395 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20239 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20437 = mem[_20239]
                                                                    require mem[_20239] <= test266151307()
                                                                    require _20239 + mem[_20239] + 31 < _20239 + return_data.size
                                                                    _20581 = mem[_20239 + mem[_20239]]
                                                                    if mem[_20239 + mem[_20239]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20239 + ceil32(return_data.size) + ceil32(32 * mem[_20239 + mem[_20239]]) + 1 > test266151307() or ceil32(32 * mem[_20239 + mem[_20239]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20239 + ceil32(return_data.size) + ceil32(32 * mem[_20239 + mem[_20239]]) + 1
                                                                    mem[_20239 + ceil32(return_data.size)] = _20581
                                                                    require return_data.size >= _20437 + (32 * _20581) + 32
                                                                    t = _20239 + _20437 + 32
                                                                    u = _20239 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20581:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_10395 + 164] = return_data.size
                                                                mem[_10395 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10395 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10395 + ceil32(return_data.size) + 233] = mem[idx + _10395 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10395 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_10395 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10395 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10395 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10395 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10395 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10395 + ceil32(return_data.size) + 457
                                                                    w = _10395 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10395 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10395 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10395 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10395 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20438 = mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10395 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20582 = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20438 + (32 * _20582) + 32
                                                                    t = _10395 + ceil32(return_data.size) + _20438 + 293
                                                                    u = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20582:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_10395 + 196] == bool(mem[_10395 + 196])
                                                                    if not mem[_10395 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10395 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10395 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10395 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10395 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10395 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10395 + ceil32(return_data.size) + 457
                                                                    w = _10395 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10395 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10395 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10395 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10395 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20439 = mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10395 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20583 = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20439 + (32 * _20583) + 32
                                                                    t = _10395 + ceil32(return_data.size) + _20439 + 293
                                                                    u = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20583:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_10959 + _10395 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_10395 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_10395 + 168 len _10959 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_10395 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10395 + 232] = mem[idx + _10395 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10395 + 232]
                                                                if not mem[96]:
                                                                    mem[_10395 + 164] = 2
                                                                    mem[64] = _10395 + 260
                                                                    mem[_10395 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + 228] = address(cd[36])
                                                                    mem[_10395 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + 296] = 0
                                                                    mem[_10395 + 328] = 160
                                                                    mem[_10395 + 424] = 2
                                                                    s = 0
                                                                    t = _10395 + 456
                                                                    u = _10395 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10395 + 360] = this.address
                                                                    mem[_10395 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10395 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20246 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20440 = mem[_20246]
                                                                    require mem[_20246] <= test266151307()
                                                                    require _20246 + mem[_20246] + 31 < _20246 + return_data.size
                                                                    _20584 = mem[_20246 + mem[_20246]]
                                                                    if mem[_20246 + mem[_20246]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20246 + ceil32(return_data.size) + ceil32(32 * mem[_20246 + mem[_20246]]) + 1 > test266151307() or ceil32(32 * mem[_20246 + mem[_20246]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20246 + ceil32(return_data.size) + ceil32(32 * mem[_20246 + mem[_20246]]) + 1
                                                                    mem[_20246 + ceil32(return_data.size)] = _20584
                                                                    require return_data.size >= _20440 + (32 * _20584) + 32
                                                                    t = _20246 + _20440 + 32
                                                                    u = _20246 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20584:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10395 + 164] = 2
                                                                    mem[64] = _10395 + 260
                                                                    mem[_10395 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + 228] = address(cd[36])
                                                                    mem[_10395 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + 296] = 0
                                                                    mem[_10395 + 328] = 160
                                                                    mem[_10395 + 424] = 2
                                                                    s = 0
                                                                    t = _10395 + 456
                                                                    u = _10395 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_10395 + 360] = this.address
                                                                    mem[_10395 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _10395 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20247 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20441 = mem[_20247]
                                                                    require mem[_20247] <= test266151307()
                                                                    require _20247 + mem[_20247] + 31 < _20247 + return_data.size
                                                                    _20585 = mem[_20247 + mem[_20247]]
                                                                    if mem[_20247 + mem[_20247]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20247 + ceil32(return_data.size) + ceil32(32 * mem[_20247 + mem[_20247]]) + 1 > test266151307() or ceil32(32 * mem[_20247 + mem[_20247]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20247 + ceil32(return_data.size) + ceil32(32 * mem[_20247 + mem[_20247]]) + 1
                                                                    mem[_20247 + ceil32(return_data.size)] = _20585
                                                                    require return_data.size >= _20441 + (32 * _20585) + 32
                                                                    t = _20247 + _20441 + 32
                                                                    u = _20247 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20585:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_10395 + 164] = return_data.size
                                                                mem[_10395 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10395 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _10395 + ceil32(return_data.size) + 233] = mem[idx + _10395 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_10395 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_10395 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10395 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10395 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10395 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10395 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10395 + ceil32(return_data.size) + 457
                                                                    w = _10395 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10395 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10395 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10395 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10395 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20442 = mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10395 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20586 = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20442 + (32 * _20586) + 32
                                                                    t = _10395 + ceil32(return_data.size) + _20442 + 293
                                                                    u = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20586:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_10395 + 196] == bool(mem[_10395 + 196])
                                                                    if not mem[_10395 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_10395 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_10395 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_10395 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_10395 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_10395 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_10395 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_10395 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_10395 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _10395 + ceil32(return_data.size) + 457
                                                                    w = _10395 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_10395 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_10395 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_10395 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_10395 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20443 = mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _10395 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20587 = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_10395 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_10395 + ceil32(return_data.size) + mem[_10395 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20443 + (32 * _20587) + 32
                                                                    t = _10395 + ceil32(return_data.size) + _20443 + 293
                                                                    u = _10395 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20587:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[32] = 1
                                            sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])] = 1
                                            if sub_8cf086ad > -2:
                                                revert with 0, 17
                                            sub_8cf086ad++
                                    else:
                                        t = 10
                                        u = 1
                                        s = mem[_2814 + 31 len 1]
                                        while s > 1:
                                            if t > -1 / t:
                                                revert with 0, 17
                                            if not bool(s):
                                                t = t * t
                                                u = u
                                                s = uint255(s) * 0.5
                                                continue 
                                            t = t * t
                                            u = t * u
                                            s = uint255(s) * 0.5
                                            continue 
                                        if u > -1 / t:
                                            revert with 0, 17
                                        if Mask(112, 0, _2803) and cd[((32 * idx) + cd[100] + 36)] > -1 / Mask(112, 0, _2803):
                                            revert with 0, 17
                                        if not t * u:
                                            revert with 0, 18
                                        if cd[196] <= Mask(112, 0, _2803) * cd[((32 * idx) + cd[100] + 36)] / t * u:
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            if idx >= ('cd', 100).length:
                                                revert with 0, 50
                                            if idx >= ('cd', 132).length:
                                                revert with 0, 50
                                            if cd[164] and cd[((32 * idx) + cd[132] + 36)] > -1 / cd[164]:
                                                revert with 0, 17
                                            require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                            staticcall address(cd[((32 * idx) + cd[68] + 36)]).0x313ce567 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _11426 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _11616 = mem[_11426]
                                            require mem[_11426] == mem[_11426 + 31 len 1]
                                            if not mem[_11426 + 31 len 1]:
                                                if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 1 > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                    revert with 0, 17
                                                if not cd[((32 * idx) + cd[100] + 36)]:
                                                    revert with 0, 18
                                                if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]:
                                                    _12617 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _12618 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_12618 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12618 + 36 len 28]
                                                    mem[64] = _12617 + 164
                                                    mem[_12617 + 100] = 32
                                                    mem[_12617 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _12815 = mem[_12618]
                                                    s = 0
                                                    while s < _12815:
                                                        mem[s + _12617 + 164] = mem[s + _12618 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_12815) <= _12815:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12617 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12617 + 168 len _12815 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12617 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12617 + 232] = mem[idx + _12617 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12617 + 232]
                                                            if not mem[96]:
                                                                mem[_12617 + 164] = 2
                                                                mem[64] = _12617 + 260
                                                                mem[_12617 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + 228] = address(cd[36])
                                                                mem[_12617 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + 296] = 0
                                                                mem[_12617 + 328] = 160
                                                                mem[_12617 + 424] = 2
                                                                s = 0
                                                                t = _12617 + 456
                                                                u = _12617 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + 360] = this.address
                                                                mem[_12617 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12617 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20190 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20412 = mem[_20190]
                                                                require mem[_20190] <= test266151307()
                                                                require _20190 + mem[_20190] + 31 < _20190 + return_data.size
                                                                _20556 = mem[_20190 + mem[_20190]]
                                                                if mem[_20190 + mem[_20190]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20190 + ceil32(return_data.size) + ceil32(32 * mem[_20190 + mem[_20190]]) + 1 > test266151307() or ceil32(32 * mem[_20190 + mem[_20190]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20190 + ceil32(return_data.size) + ceil32(32 * mem[_20190 + mem[_20190]]) + 1
                                                                mem[_20190 + ceil32(return_data.size)] = _20556
                                                                require return_data.size >= _20412 + (32 * _20556) + 32
                                                                t = _20190 + _20412 + 32
                                                                u = _20190 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20556:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12617 + 164] = 2
                                                                mem[64] = _12617 + 260
                                                                mem[_12617 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + 228] = address(cd[36])
                                                                mem[_12617 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + 296] = 0
                                                                mem[_12617 + 328] = 160
                                                                mem[_12617 + 424] = 2
                                                                s = 0
                                                                t = _12617 + 456
                                                                u = _12617 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + 360] = this.address
                                                                mem[_12617 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12617 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20191 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20413 = mem[_20191]
                                                                require mem[_20191] <= test266151307()
                                                                require _20191 + mem[_20191] + 31 < _20191 + return_data.size
                                                                _20557 = mem[_20191 + mem[_20191]]
                                                                if mem[_20191 + mem[_20191]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20191 + ceil32(return_data.size) + ceil32(32 * mem[_20191 + mem[_20191]]) + 1 > test266151307() or ceil32(32 * mem[_20191 + mem[_20191]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20191 + ceil32(return_data.size) + ceil32(32 * mem[_20191 + mem[_20191]]) + 1
                                                                mem[_20191 + ceil32(return_data.size)] = _20557
                                                                require return_data.size >= _20413 + (32 * _20557) + 32
                                                                t = _20191 + _20413 + 32
                                                                u = _20191 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20557:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12617 + 164] = return_data.size
                                                            mem[_12617 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12617 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12617 + ceil32(return_data.size) + 233] = mem[idx + _12617 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12617 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12617 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12617 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12617 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12617 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12617 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12617 + ceil32(return_data.size) + 457
                                                                u = _12617 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12617 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12617 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12617 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20414 = mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12617 + ceil32(return_data.size) + return_data.size + 261
                                                                _20558 = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20414 + (32 * _20558) + 32
                                                                t = _12617 + ceil32(return_data.size) + _20414 + 293
                                                                u = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20558:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12617 + 196] == bool(mem[_12617 + 196])
                                                                if not mem[_12617 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12617 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12617 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12617 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12617 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12617 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12617 + ceil32(return_data.size) + 457
                                                                u = _12617 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12617 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12617 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12617 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20415 = mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12617 + ceil32(return_data.size) + return_data.size + 261
                                                                _20559 = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20415 + (32 * _20559) + 32
                                                                t = _12617 + ceil32(return_data.size) + _20415 + 293
                                                                u = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20559:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_12815 + _12617 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12617 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12617 + 168 len _12815 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12617 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12617 + 232] = mem[idx + _12617 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12617 + 232]
                                                            if not mem[96]:
                                                                mem[_12617 + 164] = 2
                                                                mem[64] = _12617 + 260
                                                                mem[_12617 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + 228] = address(cd[36])
                                                                mem[_12617 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + 296] = 0
                                                                mem[_12617 + 328] = 160
                                                                mem[_12617 + 424] = 2
                                                                s = 0
                                                                t = _12617 + 456
                                                                u = _12617 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + 360] = this.address
                                                                mem[_12617 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12617 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20198 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20416 = mem[_20198]
                                                                require mem[_20198] <= test266151307()
                                                                require _20198 + mem[_20198] + 31 < _20198 + return_data.size
                                                                _20560 = mem[_20198 + mem[_20198]]
                                                                if mem[_20198 + mem[_20198]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20198 + ceil32(return_data.size) + ceil32(32 * mem[_20198 + mem[_20198]]) + 1 > test266151307() or ceil32(32 * mem[_20198 + mem[_20198]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20198 + ceil32(return_data.size) + ceil32(32 * mem[_20198 + mem[_20198]]) + 1
                                                                mem[_20198 + ceil32(return_data.size)] = _20560
                                                                require return_data.size >= _20416 + (32 * _20560) + 32
                                                                t = _20198 + _20416 + 32
                                                                u = _20198 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20560:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12617 + 164] = 2
                                                                mem[64] = _12617 + 260
                                                                mem[_12617 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + 228] = address(cd[36])
                                                                mem[_12617 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + 296] = 0
                                                                mem[_12617 + 328] = 160
                                                                mem[_12617 + 424] = 2
                                                                s = 0
                                                                t = _12617 + 456
                                                                u = _12617 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + 360] = this.address
                                                                mem[_12617 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12617 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20199 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20417 = mem[_20199]
                                                                require mem[_20199] <= test266151307()
                                                                require _20199 + mem[_20199] + 31 < _20199 + return_data.size
                                                                _20561 = mem[_20199 + mem[_20199]]
                                                                if mem[_20199 + mem[_20199]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20199 + ceil32(return_data.size) + ceil32(32 * mem[_20199 + mem[_20199]]) + 1 > test266151307() or ceil32(32 * mem[_20199 + mem[_20199]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20199 + ceil32(return_data.size) + ceil32(32 * mem[_20199 + mem[_20199]]) + 1
                                                                mem[_20199 + ceil32(return_data.size)] = _20561
                                                                require return_data.size >= _20417 + (32 * _20561) + 32
                                                                t = _20199 + _20417 + 32
                                                                u = _20199 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20561:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12617 + 164] = return_data.size
                                                            mem[_12617 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12617 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12617 + ceil32(return_data.size) + 233] = mem[idx + _12617 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12617 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12617 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12617 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12617 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12617 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12617 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12617 + ceil32(return_data.size) + 457
                                                                u = _12617 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12617 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12617 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12617 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20418 = mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12617 + ceil32(return_data.size) + return_data.size + 261
                                                                _20562 = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20418 + (32 * _20562) + 32
                                                                t = _12617 + ceil32(return_data.size) + _20418 + 293
                                                                u = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20562:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12617 + 196] == bool(mem[_12617 + 196])
                                                                if not mem[_12617 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12617 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12617 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12617 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12617 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12617 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12617 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12617 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12617 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12617 + ceil32(return_data.size) + 457
                                                                u = _12617 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12617 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12617 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12617 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12617 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20419 = mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12617 + ceil32(return_data.size) + return_data.size + 261
                                                                _20563 = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12617 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12617 + ceil32(return_data.size) + mem[_12617 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20419 + (32 * _20563) + 32
                                                                t = _12617 + ceil32(return_data.size) + _20419 + 293
                                                                u = _12617 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20563:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                else:
                                                    mem[mem[64] + 4] = this.address
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                    staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                            gas gas_remaining wei
                                                           args this.address, address(cd[4])
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _12662 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if mem[_12662]:
                                                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                    _12856 = mem[64]
                                                    mem[mem[64] + 36] = address(cd[4])
                                                    mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                    _12857 = mem[64]
                                                    mem[mem[64]] = 68
                                                    mem[64] = mem[64] + 100
                                                    mem[_12857 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12857 + 36 len 28]
                                                    mem[64] = _12856 + 164
                                                    mem[_12856 + 100] = 32
                                                    mem[_12856 + 132] = 'SafeERC20: low-level call failed'
                                                    if eth.balance(this.address) < 0:
                                                        revert with 0, 'Address: insufficient balance for call'
                                                    if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                        revert with 0, 'Address: call to non-contract'
                                                    _13005 = mem[_12857]
                                                    s = 0
                                                    while s < _13005:
                                                        mem[s + _12856 + 164] = mem[s + _12857 + 32]
                                                        s = s + 32
                                                        continue 
                                                    if ceil32(_13005) <= _13005:
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12856 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12856 + 168 len _13005 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12856 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12856 + 232] = mem[idx + _12856 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12856 + 232]
                                                            if not mem[96]:
                                                                mem[_12856 + 164] = 2
                                                                mem[64] = _12856 + 260
                                                                mem[_12856 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + 228] = address(cd[36])
                                                                mem[_12856 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + 296] = 0
                                                                mem[_12856 + 328] = 160
                                                                mem[_12856 + 424] = 2
                                                                s = 0
                                                                t = _12856 + 456
                                                                u = _12856 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + 360] = this.address
                                                                mem[_12856 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12856 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20206 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20420 = mem[_20206]
                                                                require mem[_20206] <= test266151307()
                                                                require _20206 + mem[_20206] + 31 < _20206 + return_data.size
                                                                _20564 = mem[_20206 + mem[_20206]]
                                                                if mem[_20206 + mem[_20206]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20206 + ceil32(return_data.size) + ceil32(32 * mem[_20206 + mem[_20206]]) + 1 > test266151307() or ceil32(32 * mem[_20206 + mem[_20206]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20206 + ceil32(return_data.size) + ceil32(32 * mem[_20206 + mem[_20206]]) + 1
                                                                mem[_20206 + ceil32(return_data.size)] = _20564
                                                                require return_data.size >= _20420 + (32 * _20564) + 32
                                                                t = _20206 + _20420 + 32
                                                                u = _20206 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20564:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12856 + 164] = 2
                                                                mem[64] = _12856 + 260
                                                                mem[_12856 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + 228] = address(cd[36])
                                                                mem[_12856 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + 296] = 0
                                                                mem[_12856 + 328] = 160
                                                                mem[_12856 + 424] = 2
                                                                s = 0
                                                                t = _12856 + 456
                                                                u = _12856 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + 360] = this.address
                                                                mem[_12856 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12856 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20207 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20421 = mem[_20207]
                                                                require mem[_20207] <= test266151307()
                                                                require _20207 + mem[_20207] + 31 < _20207 + return_data.size
                                                                _20565 = mem[_20207 + mem[_20207]]
                                                                if mem[_20207 + mem[_20207]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20207 + ceil32(return_data.size) + ceil32(32 * mem[_20207 + mem[_20207]]) + 1 > test266151307() or ceil32(32 * mem[_20207 + mem[_20207]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20207 + ceil32(return_data.size) + ceil32(32 * mem[_20207 + mem[_20207]]) + 1
                                                                mem[_20207 + ceil32(return_data.size)] = _20565
                                                                require return_data.size >= _20421 + (32 * _20565) + 32
                                                                t = _20207 + _20421 + 32
                                                                u = _20207 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20565:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12856 + 164] = return_data.size
                                                            mem[_12856 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12856 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12856 + ceil32(return_data.size) + 233] = mem[idx + _12856 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12856 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12856 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12856 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12856 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12856 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12856 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12856 + ceil32(return_data.size) + 457
                                                                u = _12856 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12856 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12856 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12856 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20422 = mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12856 + ceil32(return_data.size) + return_data.size + 261
                                                                _20566 = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20422 + (32 * _20566) + 32
                                                                t = _12856 + ceil32(return_data.size) + _20422 + 293
                                                                u = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20566:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12856 + 196] == bool(mem[_12856 + 196])
                                                                if not mem[_12856 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12856 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12856 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12856 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12856 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12856 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12856 + ceil32(return_data.size) + 457
                                                                u = _12856 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12856 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12856 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12856 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20423 = mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12856 + ceil32(return_data.size) + return_data.size + 261
                                                                _20567 = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20423 + (32 * _20567) + 32
                                                                t = _12856 + ceil32(return_data.size) + _20423 + 293
                                                                u = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20567:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                    else:
                                                        mem[_13005 + _12856 + 164] = 0
                                                        call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12856 + 164 len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[_12856 + 168 len _13005 - 4]
                                                        if not return_data.size:
                                                            if not ext_call.success:
                                                                if mem[96]:
                                                                    revert with memory
                                                                      from 128
                                                                       len mem[96]
                                                                mem[_12856 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + 168] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12856 + 232] = mem[idx + _12856 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12856 + 232]
                                                            if not mem[96]:
                                                                mem[_12856 + 164] = 2
                                                                mem[64] = _12856 + 260
                                                                mem[_12856 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + 228] = address(cd[36])
                                                                mem[_12856 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + 296] = 0
                                                                mem[_12856 + 328] = 160
                                                                mem[_12856 + 424] = 2
                                                                s = 0
                                                                t = _12856 + 456
                                                                u = _12856 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + 360] = this.address
                                                                mem[_12856 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12856 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20214 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20424 = mem[_20214]
                                                                require mem[_20214] <= test266151307()
                                                                require _20214 + mem[_20214] + 31 < _20214 + return_data.size
                                                                _20568 = mem[_20214 + mem[_20214]]
                                                                if mem[_20214 + mem[_20214]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20214 + ceil32(return_data.size) + ceil32(32 * mem[_20214 + mem[_20214]]) + 1 > test266151307() or ceil32(32 * mem[_20214 + mem[_20214]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20214 + ceil32(return_data.size) + ceil32(32 * mem[_20214 + mem[_20214]]) + 1
                                                                mem[_20214 + ceil32(return_data.size)] = _20568
                                                                require return_data.size >= _20424 + (32 * _20568) + 32
                                                                t = _20214 + _20424 + 32
                                                                u = _20214 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20568:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require mem[96] >= 32
                                                                require mem[128] == bool(mem[128])
                                                                if not mem[128]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12856 + 164] = 2
                                                                mem[64] = _12856 + 260
                                                                mem[_12856 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + 228] = address(cd[36])
                                                                mem[_12856 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + 296] = 0
                                                                mem[_12856 + 328] = 160
                                                                mem[_12856 + 424] = 2
                                                                s = 0
                                                                t = _12856 + 456
                                                                u = _12856 + 196
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + 360] = this.address
                                                                mem[_12856 + 392] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12856 + -mem[64] + 516]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _20215 = mem[64]
                                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                _20425 = mem[_20215]
                                                                require mem[_20215] <= test266151307()
                                                                require _20215 + mem[_20215] + 31 < _20215 + return_data.size
                                                                _20569 = mem[_20215 + mem[_20215]]
                                                                if mem[_20215 + mem[_20215]] > test266151307():
                                                                    revert with 0, 65
                                                                if _20215 + ceil32(return_data.size) + ceil32(32 * mem[_20215 + mem[_20215]]) + 1 > test266151307() or ceil32(32 * mem[_20215 + mem[_20215]]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _20215 + ceil32(return_data.size) + ceil32(32 * mem[_20215 + mem[_20215]]) + 1
                                                                mem[_20215 + ceil32(return_data.size)] = _20569
                                                                require return_data.size >= _20425 + (32 * _20569) + 32
                                                                t = _20215 + _20425 + 32
                                                                u = _20215 + ceil32(return_data.size) + 32
                                                                s = 0
                                                                while s < _20569:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                        else:
                                                            mem[_12856 + 164] = return_data.size
                                                            mem[_12856 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                            if not ext_call.success:
                                                                if return_data.size:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12856 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + ceil32(return_data.size) + 169] = 32
                                                                idx = 0
                                                                while idx < 32:
                                                                    mem[idx + _12856 + ceil32(return_data.size) + 233] = mem[idx + _12856 + 132]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 32, mem[_12856 + ceil32(return_data.size) + 233]
                                                            if not return_data.size:
                                                                mem[_12856 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12856 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12856 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12856 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12856 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12856 + ceil32(return_data.size) + 457
                                                                u = _12856 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12856 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12856 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12856 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20426 = mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12856 + ceil32(return_data.size) + return_data.size + 261
                                                                _20570 = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20426 + (32 * _20570) + 32
                                                                t = _12856 + ceil32(return_data.size) + _20426 + 293
                                                                u = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20570:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                                            else:
                                                                require return_data.size >= 32
                                                                require mem[_12856 + 196] == bool(mem[_12856 + 196])
                                                                if not mem[_12856 + 196]:
                                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                mem[_12856 + ceil32(return_data.size) + 165] = 2
                                                                mem[_12856 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                mem[_12856 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                mem[_12856 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                mem[_12856 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]
                                                                mem[_12856 + ceil32(return_data.size) + 297] = 0
                                                                mem[_12856 + ceil32(return_data.size) + 329] = 160
                                                                mem[_12856 + ceil32(return_data.size) + 425] = 2
                                                                s = 0
                                                                t = _12856 + ceil32(return_data.size) + 457
                                                                u = _12856 + ceil32(return_data.size) + 197
                                                                while s < 2:
                                                                    mem[t] = mem[u + 12 len 20]
                                                                    s = s + 1
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    continue 
                                                                mem[_12856 + ceil32(return_data.size) + 361] = this.address
                                                                mem[_12856 + ceil32(return_data.size) + 393] = cd[228]
                                                                require ext_code.size(address(cd[4]))
                                                                call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12856 + ceil32(return_data.size) + 457 len 64]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_12856 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                require return_data.size >= 32
                                                                _20427 = mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                require mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                require _12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12856 + ceil32(return_data.size) + return_data.size + 261
                                                                _20571 = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                if mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                    revert with 0, 65
                                                                if _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                    revert with 0, 65
                                                                mem[64] = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                mem[_12856 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12856 + ceil32(return_data.size) + mem[_12856 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                require return_data.size >= _20427 + (32 * _20571) + 32
                                                                t = _12856 + ceil32(return_data.size) + _20427 + 293
                                                                u = _12856 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                s = 0
                                                                while s < _20571:
                                                                    mem[u] = mem[t]
                                                                    t = t + 32
                                                                    u = u + 32
                                                                    s = s + 1
                                                                    continue 
                                            else:
                                                if bool(bool(mem[_11426 + 31 len 1] < 78)) or bool(bool(mem[_11426 + 31 len 1] < 32)):
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and 10^mem[_11426 + 31 len 1] > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^mem[_11426 + 31 len 1] / cd[((32 * idx) + cd[100] + 36)]:
                                                        _12811 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                        _12812 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_12812 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12812 + 36 len 28]
                                                        mem[64] = _12811 + 164
                                                        mem[_12811 + 100] = 32
                                                        mem[_12811 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _12960 = mem[_12812]
                                                        s = 0
                                                        while s < _12960:
                                                            mem[s + _12811 + 164] = mem[s + _12812 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_12960) <= _12960:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12811 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12811 + 168 len _12960 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12811 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12811 + 232] = mem[idx + _12811 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12811 + 232]
                                                                if not mem[96]:
                                                                    mem[_12811 + 164] = 2
                                                                    mem[64] = _12811 + 260
                                                                    mem[_12811 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + 228] = address(cd[36])
                                                                    mem[_12811 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + 296] = 0
                                                                    mem[_12811 + 328] = 160
                                                                    mem[_12811 + 424] = 2
                                                                    s = 0
                                                                    t = _12811 + 456
                                                                    u = _12811 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + 360] = this.address
                                                                    mem[_12811 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12811 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20158 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20396 = mem[_20158]
                                                                    require mem[_20158] <= test266151307()
                                                                    require _20158 + mem[_20158] + 31 < _20158 + return_data.size
                                                                    _20540 = mem[_20158 + mem[_20158]]
                                                                    if mem[_20158 + mem[_20158]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20158 + ceil32(return_data.size) + ceil32(32 * mem[_20158 + mem[_20158]]) + 1 > test266151307() or ceil32(32 * mem[_20158 + mem[_20158]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20158 + ceil32(return_data.size) + ceil32(32 * mem[_20158 + mem[_20158]]) + 1
                                                                    mem[_20158 + ceil32(return_data.size)] = _20540
                                                                    require return_data.size >= _20396 + (32 * _20540) + 32
                                                                    t = _20158 + _20396 + 32
                                                                    u = _20158 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20540:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12811 + 164] = 2
                                                                    mem[64] = _12811 + 260
                                                                    mem[_12811 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + 228] = address(cd[36])
                                                                    mem[_12811 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + 296] = 0
                                                                    mem[_12811 + 328] = 160
                                                                    mem[_12811 + 424] = 2
                                                                    s = 0
                                                                    t = _12811 + 456
                                                                    u = _12811 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + 360] = this.address
                                                                    mem[_12811 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12811 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20159 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20397 = mem[_20159]
                                                                    require mem[_20159] <= test266151307()
                                                                    require _20159 + mem[_20159] + 31 < _20159 + return_data.size
                                                                    _20541 = mem[_20159 + mem[_20159]]
                                                                    if mem[_20159 + mem[_20159]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20159 + ceil32(return_data.size) + ceil32(32 * mem[_20159 + mem[_20159]]) + 1 > test266151307() or ceil32(32 * mem[_20159 + mem[_20159]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20159 + ceil32(return_data.size) + ceil32(32 * mem[_20159 + mem[_20159]]) + 1
                                                                    mem[_20159 + ceil32(return_data.size)] = _20541
                                                                    require return_data.size >= _20397 + (32 * _20541) + 32
                                                                    t = _20159 + _20397 + 32
                                                                    u = _20159 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20541:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12811 + 164] = return_data.size
                                                                mem[_12811 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12811 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12811 + ceil32(return_data.size) + 233] = mem[idx + _12811 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12811 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12811 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12811 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12811 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12811 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12811 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12811 + ceil32(return_data.size) + 457
                                                                    u = _12811 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12811 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12811 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12811 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20398 = mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12811 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20542 = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20398 + (32 * _20542) + 32
                                                                    t = _12811 + ceil32(return_data.size) + _20398 + 293
                                                                    u = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20542:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12811 + 196] == bool(mem[_12811 + 196])
                                                                    if not mem[_12811 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12811 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12811 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12811 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12811 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12811 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12811 + ceil32(return_data.size) + 457
                                                                    u = _12811 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12811 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12811 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12811 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20399 = mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12811 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20543 = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20399 + (32 * _20543) + 32
                                                                    t = _12811 + ceil32(return_data.size) + _20399 + 293
                                                                    u = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20543:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_12960 + _12811 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12811 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12811 + 168 len _12960 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12811 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12811 + 232] = mem[idx + _12811 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12811 + 232]
                                                                if not mem[96]:
                                                                    mem[_12811 + 164] = 2
                                                                    mem[64] = _12811 + 260
                                                                    mem[_12811 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + 228] = address(cd[36])
                                                                    mem[_12811 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + 296] = 0
                                                                    mem[_12811 + 328] = 160
                                                                    mem[_12811 + 424] = 2
                                                                    s = 0
                                                                    t = _12811 + 456
                                                                    u = _12811 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + 360] = this.address
                                                                    mem[_12811 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12811 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20166 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20400 = mem[_20166]
                                                                    require mem[_20166] <= test266151307()
                                                                    require _20166 + mem[_20166] + 31 < _20166 + return_data.size
                                                                    _20544 = mem[_20166 + mem[_20166]]
                                                                    if mem[_20166 + mem[_20166]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20166 + ceil32(return_data.size) + ceil32(32 * mem[_20166 + mem[_20166]]) + 1 > test266151307() or ceil32(32 * mem[_20166 + mem[_20166]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20166 + ceil32(return_data.size) + ceil32(32 * mem[_20166 + mem[_20166]]) + 1
                                                                    mem[_20166 + ceil32(return_data.size)] = _20544
                                                                    require return_data.size >= _20400 + (32 * _20544) + 32
                                                                    t = _20166 + _20400 + 32
                                                                    u = _20166 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20544:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12811 + 164] = 2
                                                                    mem[64] = _12811 + 260
                                                                    mem[_12811 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + 228] = address(cd[36])
                                                                    mem[_12811 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + 296] = 0
                                                                    mem[_12811 + 328] = 160
                                                                    mem[_12811 + 424] = 2
                                                                    s = 0
                                                                    t = _12811 + 456
                                                                    u = _12811 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + 360] = this.address
                                                                    mem[_12811 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12811 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20167 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20401 = mem[_20167]
                                                                    require mem[_20167] <= test266151307()
                                                                    require _20167 + mem[_20167] + 31 < _20167 + return_data.size
                                                                    _20545 = mem[_20167 + mem[_20167]]
                                                                    if mem[_20167 + mem[_20167]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20167 + ceil32(return_data.size) + ceil32(32 * mem[_20167 + mem[_20167]]) + 1 > test266151307() or ceil32(32 * mem[_20167 + mem[_20167]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20167 + ceil32(return_data.size) + ceil32(32 * mem[_20167 + mem[_20167]]) + 1
                                                                    mem[_20167 + ceil32(return_data.size)] = _20545
                                                                    require return_data.size >= _20401 + (32 * _20545) + 32
                                                                    t = _20167 + _20401 + 32
                                                                    u = _20167 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20545:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12811 + 164] = return_data.size
                                                                mem[_12811 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12811 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12811 + ceil32(return_data.size) + 233] = mem[idx + _12811 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12811 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12811 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12811 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12811 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12811 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12811 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12811 + ceil32(return_data.size) + 457
                                                                    u = _12811 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12811 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12811 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12811 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20402 = mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12811 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20546 = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20402 + (32 * _20546) + 32
                                                                    t = _12811 + ceil32(return_data.size) + _20402 + 293
                                                                    u = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20546:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12811 + 196] == bool(mem[_12811 + 196])
                                                                    if not mem[_12811 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12811 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12811 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12811 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12811 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12811 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12811 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12811 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12811 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12811 + ceil32(return_data.size) + 457
                                                                    u = _12811 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12811 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12811 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12811 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12811 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20403 = mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12811 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20547 = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12811 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12811 + ceil32(return_data.size) + mem[_12811 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20403 + (32 * _20547) + 32
                                                                    t = _12811 + ceil32(return_data.size) + _20403 + 293
                                                                    u = _12811 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20547:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _12855 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_12855]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _12998 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                        _12999 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_12999 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12999 + 36 len 28]
                                                        mem[64] = _12998 + 164
                                                        mem[_12998 + 100] = 32
                                                        mem[_12998 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _13113 = mem[_12999]
                                                        s = 0
                                                        while s < _13113:
                                                            mem[s + _12998 + 164] = mem[s + _12999 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_13113) <= _13113:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12998 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12998 + 168 len _13113 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12998 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12998 + 232] = mem[idx + _12998 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12998 + 232]
                                                                if not mem[96]:
                                                                    mem[_12998 + 164] = 2
                                                                    mem[64] = _12998 + 260
                                                                    mem[_12998 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + 228] = address(cd[36])
                                                                    mem[_12998 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + 296] = 0
                                                                    mem[_12998 + 328] = 160
                                                                    mem[_12998 + 424] = 2
                                                                    s = 0
                                                                    t = _12998 + 456
                                                                    u = _12998 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + 360] = this.address
                                                                    mem[_12998 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12998 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20174 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20404 = mem[_20174]
                                                                    require mem[_20174] <= test266151307()
                                                                    require _20174 + mem[_20174] + 31 < _20174 + return_data.size
                                                                    _20548 = mem[_20174 + mem[_20174]]
                                                                    if mem[_20174 + mem[_20174]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20174 + ceil32(return_data.size) + ceil32(32 * mem[_20174 + mem[_20174]]) + 1 > test266151307() or ceil32(32 * mem[_20174 + mem[_20174]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20174 + ceil32(return_data.size) + ceil32(32 * mem[_20174 + mem[_20174]]) + 1
                                                                    mem[_20174 + ceil32(return_data.size)] = _20548
                                                                    require return_data.size >= _20404 + (32 * _20548) + 32
                                                                    t = _20174 + _20404 + 32
                                                                    u = _20174 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20548:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12998 + 164] = 2
                                                                    mem[64] = _12998 + 260
                                                                    mem[_12998 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + 228] = address(cd[36])
                                                                    mem[_12998 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + 296] = 0
                                                                    mem[_12998 + 328] = 160
                                                                    mem[_12998 + 424] = 2
                                                                    s = 0
                                                                    t = _12998 + 456
                                                                    u = _12998 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + 360] = this.address
                                                                    mem[_12998 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12998 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20175 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20405 = mem[_20175]
                                                                    require mem[_20175] <= test266151307()
                                                                    require _20175 + mem[_20175] + 31 < _20175 + return_data.size
                                                                    _20549 = mem[_20175 + mem[_20175]]
                                                                    if mem[_20175 + mem[_20175]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20175 + ceil32(return_data.size) + ceil32(32 * mem[_20175 + mem[_20175]]) + 1 > test266151307() or ceil32(32 * mem[_20175 + mem[_20175]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20175 + ceil32(return_data.size) + ceil32(32 * mem[_20175 + mem[_20175]]) + 1
                                                                    mem[_20175 + ceil32(return_data.size)] = _20549
                                                                    require return_data.size >= _20405 + (32 * _20549) + 32
                                                                    t = _20175 + _20405 + 32
                                                                    u = _20175 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20549:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12998 + 164] = return_data.size
                                                                mem[_12998 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12998 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12998 + ceil32(return_data.size) + 233] = mem[idx + _12998 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12998 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12998 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12998 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12998 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12998 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12998 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12998 + ceil32(return_data.size) + 457
                                                                    u = _12998 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12998 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12998 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12998 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20406 = mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12998 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20550 = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20406 + (32 * _20550) + 32
                                                                    t = _12998 + ceil32(return_data.size) + _20406 + 293
                                                                    u = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20550:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12998 + 196] == bool(mem[_12998 + 196])
                                                                    if not mem[_12998 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12998 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12998 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12998 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12998 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12998 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12998 + ceil32(return_data.size) + 457
                                                                    u = _12998 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12998 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12998 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12998 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20407 = mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12998 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20551 = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20407 + (32 * _20551) + 32
                                                                    t = _12998 + ceil32(return_data.size) + _20407 + 293
                                                                    u = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20551:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_13113 + _12998 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_12998 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_12998 + 168 len _13113 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_12998 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12998 + 232] = mem[idx + _12998 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12998 + 232]
                                                                if not mem[96]:
                                                                    mem[_12998 + 164] = 2
                                                                    mem[64] = _12998 + 260
                                                                    mem[_12998 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + 228] = address(cd[36])
                                                                    mem[_12998 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + 296] = 0
                                                                    mem[_12998 + 328] = 160
                                                                    mem[_12998 + 424] = 2
                                                                    s = 0
                                                                    t = _12998 + 456
                                                                    u = _12998 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + 360] = this.address
                                                                    mem[_12998 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12998 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20182 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20408 = mem[_20182]
                                                                    require mem[_20182] <= test266151307()
                                                                    require _20182 + mem[_20182] + 31 < _20182 + return_data.size
                                                                    _20552 = mem[_20182 + mem[_20182]]
                                                                    if mem[_20182 + mem[_20182]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20182 + ceil32(return_data.size) + ceil32(32 * mem[_20182 + mem[_20182]]) + 1 > test266151307() or ceil32(32 * mem[_20182 + mem[_20182]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20182 + ceil32(return_data.size) + ceil32(32 * mem[_20182 + mem[_20182]]) + 1
                                                                    mem[_20182 + ceil32(return_data.size)] = _20552
                                                                    require return_data.size >= _20408 + (32 * _20552) + 32
                                                                    t = _20182 + _20408 + 32
                                                                    u = _20182 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20552:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12998 + 164] = 2
                                                                    mem[64] = _12998 + 260
                                                                    mem[_12998 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + 228] = address(cd[36])
                                                                    mem[_12998 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + 296] = 0
                                                                    mem[_12998 + 328] = 160
                                                                    mem[_12998 + 424] = 2
                                                                    s = 0
                                                                    t = _12998 + 456
                                                                    u = _12998 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + 360] = this.address
                                                                    mem[_12998 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _12998 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _20183 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _20409 = mem[_20183]
                                                                    require mem[_20183] <= test266151307()
                                                                    require _20183 + mem[_20183] + 31 < _20183 + return_data.size
                                                                    _20553 = mem[_20183 + mem[_20183]]
                                                                    if mem[_20183 + mem[_20183]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _20183 + ceil32(return_data.size) + ceil32(32 * mem[_20183 + mem[_20183]]) + 1 > test266151307() or ceil32(32 * mem[_20183 + mem[_20183]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _20183 + ceil32(return_data.size) + ceil32(32 * mem[_20183 + mem[_20183]]) + 1
                                                                    mem[_20183 + ceil32(return_data.size)] = _20553
                                                                    require return_data.size >= _20409 + (32 * _20553) + 32
                                                                    t = _20183 + _20409 + 32
                                                                    u = _20183 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _20553:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_12998 + 164] = return_data.size
                                                                mem[_12998 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12998 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _12998 + ceil32(return_data.size) + 233] = mem[idx + _12998 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_12998 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_12998 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12998 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12998 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12998 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12998 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12998 + ceil32(return_data.size) + 457
                                                                    u = _12998 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12998 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12998 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12998 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20410 = mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12998 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20554 = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20410 + (32 * _20554) + 32
                                                                    t = _12998 + ceil32(return_data.size) + _20410 + 293
                                                                    u = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20554:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_12998 + 196] == bool(mem[_12998 + 196])
                                                                    if not mem[_12998 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_12998 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_12998 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_12998 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_12998 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_12998 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_12998 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_12998 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_12998 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    t = _12998 + ceil32(return_data.size) + 457
                                                                    u = _12998 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_12998 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_12998 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_12998 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_12998 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _20411 = mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _12998 + ceil32(return_data.size) + return_data.size + 261
                                                                    _20555 = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_12998 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = mem[_12998 + ceil32(return_data.size) + mem[_12998 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * 10^uint8(_11616) / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    require return_data.size >= _20411 + (32 * _20555) + 32
                                                                    t = _12998 + ceil32(return_data.size) + _20411 + 293
                                                                    u = _12998 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _20555:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                else:
                                                    t = 10
                                                    u = 1
                                                    s = mem[_11426 + 31 len 1]
                                                    while s > 1:
                                                        if t > -1 / t:
                                                            revert with 0, 17
                                                        if not bool(s):
                                                            t = t * t
                                                            u = u
                                                            s = uint255(s) * 0.5
                                                            continue 
                                                        t = t * t
                                                        u = t * u
                                                        s = uint255(s) * 0.5
                                                        continue 
                                                    if u > -1 / t:
                                                        revert with 0, 17
                                                    if cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 and t * u > -1 / cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100:
                                                        revert with 0, 17
                                                    if not cd[((32 * idx) + cd[100] + 36)]:
                                                        revert with 0, 18
                                                    if not cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]:
                                                        _16734 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _16735 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_16735 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_16735 + 36 len 28]
                                                        mem[64] = _16734 + 164
                                                        mem[_16734 + 100] = 32
                                                        mem[_16734 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _17400 = mem[_16735]
                                                        s = 0
                                                        while s < _17400:
                                                            mem[s + _16734 + 164] = mem[s + _16735 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_17400) <= _17400:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_16734 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_16734 + 168 len _17400 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_16734 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16734 + 232] = mem[idx + _16734 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16734 + 232]
                                                                if not mem[96]:
                                                                    mem[_16734 + 164] = 2
                                                                    mem[64] = _16734 + 260
                                                                    mem[_16734 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + 228] = address(cd[36])
                                                                    mem[_16734 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + 296] = 0
                                                                    mem[_16734 + 328] = 160
                                                                    mem[_16734 + 424] = 2
                                                                    s = 0
                                                                    t = _16734 + 456
                                                                    u = _16734 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16734 + 360] = this.address
                                                                    mem[_16734 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16734 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22030 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22116 = mem[_22030]
                                                                    require mem[_22030] <= test266151307()
                                                                    require _22030 + mem[_22030] + 31 < _22030 + return_data.size
                                                                    _22148 = mem[_22030 + mem[_22030]]
                                                                    if mem[_22030 + mem[_22030]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22030 + ceil32(return_data.size) + ceil32(32 * mem[_22030 + mem[_22030]]) + 1 > test266151307() or ceil32(32 * mem[_22030 + mem[_22030]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22030 + ceil32(return_data.size) + ceil32(32 * mem[_22030 + mem[_22030]]) + 1
                                                                    mem[_22030 + ceil32(return_data.size)] = _22148
                                                                    require return_data.size >= _22116 + (32 * _22148) + 32
                                                                    t = _22030 + _22116 + 32
                                                                    u = _22030 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22148:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16734 + 164] = 2
                                                                    mem[64] = _16734 + 260
                                                                    mem[_16734 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + 228] = address(cd[36])
                                                                    mem[_16734 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + 296] = 0
                                                                    mem[_16734 + 328] = 160
                                                                    mem[_16734 + 424] = 2
                                                                    s = 0
                                                                    t = _16734 + 456
                                                                    u = _16734 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16734 + 360] = this.address
                                                                    mem[_16734 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16734 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22031 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22117 = mem[_22031]
                                                                    require mem[_22031] <= test266151307()
                                                                    require _22031 + mem[_22031] + 31 < _22031 + return_data.size
                                                                    _22149 = mem[_22031 + mem[_22031]]
                                                                    if mem[_22031 + mem[_22031]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22031 + ceil32(return_data.size) + ceil32(32 * mem[_22031 + mem[_22031]]) + 1 > test266151307() or ceil32(32 * mem[_22031 + mem[_22031]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22031 + ceil32(return_data.size) + ceil32(32 * mem[_22031 + mem[_22031]]) + 1
                                                                    mem[_22031 + ceil32(return_data.size)] = _22149
                                                                    require return_data.size >= _22117 + (32 * _22149) + 32
                                                                    t = _22031 + _22117 + 32
                                                                    u = _22031 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22149:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_16734 + 164] = return_data.size
                                                                mem[_16734 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16734 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16734 + ceil32(return_data.size) + 233] = mem[idx + _16734 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16734 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_16734 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16734 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16734 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16734 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16734 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16734 + ceil32(return_data.size) + 457
                                                                    w = _16734 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16734 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16734 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16734 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16734 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22118 = mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16734 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22150 = mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22150
                                                                    require return_data.size >= _22118 + (32 * _22150) + 32
                                                                    t = _16734 + ceil32(return_data.size) + _22118 + 293
                                                                    u = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22150:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_16734 + 196] == bool(mem[_16734 + 196])
                                                                    if not mem[_16734 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16734 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16734 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16734 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16734 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16734 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16734 + ceil32(return_data.size) + 457
                                                                    w = _16734 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16734 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16734 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16734 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16734 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22119 = mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16734 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22151 = mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22151
                                                                    require return_data.size >= _22119 + (32 * _22151) + 32
                                                                    t = _16734 + ceil32(return_data.size) + _22119 + 293
                                                                    u = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22151:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_17400 + _16734 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_16734 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_16734 + 168 len _17400 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_16734 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16734 + 232] = mem[idx + _16734 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16734 + 232]
                                                                if not mem[96]:
                                                                    mem[_16734 + 164] = 2
                                                                    mem[64] = _16734 + 260
                                                                    mem[_16734 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + 228] = address(cd[36])
                                                                    mem[_16734 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + 296] = 0
                                                                    mem[_16734 + 328] = 160
                                                                    mem[_16734 + 424] = 2
                                                                    s = 0
                                                                    t = _16734 + 456
                                                                    u = _16734 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16734 + 360] = this.address
                                                                    mem[_16734 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16734 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22038 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22120 = mem[_22038]
                                                                    require mem[_22038] <= test266151307()
                                                                    require _22038 + mem[_22038] + 31 < _22038 + return_data.size
                                                                    _22152 = mem[_22038 + mem[_22038]]
                                                                    if mem[_22038 + mem[_22038]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22038 + ceil32(return_data.size) + ceil32(32 * mem[_22038 + mem[_22038]]) + 1 > test266151307() or ceil32(32 * mem[_22038 + mem[_22038]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22038 + ceil32(return_data.size) + ceil32(32 * mem[_22038 + mem[_22038]]) + 1
                                                                    mem[_22038 + ceil32(return_data.size)] = _22152
                                                                    require return_data.size >= _22120 + (32 * _22152) + 32
                                                                    t = _22038 + _22120 + 32
                                                                    u = _22038 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22152:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16734 + 164] = 2
                                                                    mem[64] = _16734 + 260
                                                                    mem[_16734 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + 228] = address(cd[36])
                                                                    mem[_16734 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + 296] = 0
                                                                    mem[_16734 + 328] = 160
                                                                    mem[_16734 + 424] = 2
                                                                    s = 0
                                                                    t = _16734 + 456
                                                                    u = _16734 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_16734 + 360] = this.address
                                                                    mem[_16734 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _16734 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22039 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22121 = mem[_22039]
                                                                    require mem[_22039] <= test266151307()
                                                                    require _22039 + mem[_22039] + 31 < _22039 + return_data.size
                                                                    _22153 = mem[_22039 + mem[_22039]]
                                                                    if mem[_22039 + mem[_22039]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22039 + ceil32(return_data.size) + ceil32(32 * mem[_22039 + mem[_22039]]) + 1 > test266151307() or ceil32(32 * mem[_22039 + mem[_22039]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22039 + ceil32(return_data.size) + ceil32(32 * mem[_22039 + mem[_22039]]) + 1
                                                                    mem[_22039 + ceil32(return_data.size)] = _22153
                                                                    require return_data.size >= _22121 + (32 * _22153) + 32
                                                                    t = _22039 + _22121 + 32
                                                                    u = _22039 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22153:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_16734 + 164] = return_data.size
                                                                mem[_16734 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16734 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _16734 + ceil32(return_data.size) + 233] = mem[idx + _16734 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_16734 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_16734 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16734 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16734 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16734 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16734 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16734 + ceil32(return_data.size) + 457
                                                                    w = _16734 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16734 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16734 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16734 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16734 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22122 = mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16734 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22154 = mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22154
                                                                    require return_data.size >= _22122 + (32 * _22154) + 32
                                                                    t = _16734 + ceil32(return_data.size) + _22122 + 293
                                                                    u = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22154:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_16734 + 196] == bool(mem[_16734 + 196])
                                                                    if not mem[_16734 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_16734 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_16734 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_16734 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_16734 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_16734 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_16734 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_16734 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_16734 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _16734 + ceil32(return_data.size) + 457
                                                                    w = _16734 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_16734 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_16734 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_16734 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_16734 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22123 = mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _16734 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22155 = mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_16734 + ceil32(return_data.size) + mem[_16734 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_16734 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22155
                                                                    require return_data.size >= _22123 + (32 * _22155) + 32
                                                                    t = _16734 + ceil32(return_data.size) + _22123 + 293
                                                                    u = _16734 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22155:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                    else:
                                                        mem[mem[64] + 4] = this.address
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                                                        staticcall address(cd[((32 * idx) + cd[68] + 36)]).0xdd62ed3e with:
                                                                gas gas_remaining wei
                                                               args this.address, address(cd[4])
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _16835 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if mem[_16835]:
                                                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                                                        _17535 = mem[64]
                                                        mem[mem[64] + 36] = address(cd[4])
                                                        mem[mem[64] + 68] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                        _17536 = mem[64]
                                                        mem[mem[64]] = 68
                                                        mem[64] = mem[64] + 100
                                                        mem[_17536 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_17536 + 36 len 28]
                                                        mem[64] = _17535 + 164
                                                        mem[_17535 + 100] = 32
                                                        mem[_17535 + 132] = 'SafeERC20: low-level call failed'
                                                        if eth.balance(this.address) < 0:
                                                            revert with 0, 'Address: insufficient balance for call'
                                                        if not ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                                                            revert with 0, 'Address: call to non-contract'
                                                        _18166 = mem[_17536]
                                                        s = 0
                                                        while s < _18166:
                                                            mem[s + _17535 + 164] = mem[s + _17536 + 32]
                                                            s = s + 32
                                                            continue 
                                                        if ceil32(_18166) <= _18166:
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_17535 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_17535 + 168 len _18166 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_17535 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17535 + 232] = mem[idx + _17535 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17535 + 232]
                                                                if not mem[96]:
                                                                    mem[_17535 + 164] = 2
                                                                    mem[64] = _17535 + 260
                                                                    mem[_17535 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + 228] = address(cd[36])
                                                                    mem[_17535 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + 296] = 0
                                                                    mem[_17535 + 328] = 160
                                                                    mem[_17535 + 424] = 2
                                                                    s = 0
                                                                    t = _17535 + 456
                                                                    u = _17535 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17535 + 360] = this.address
                                                                    mem[_17535 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17535 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22046 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22124 = mem[_22046]
                                                                    require mem[_22046] <= test266151307()
                                                                    require _22046 + mem[_22046] + 31 < _22046 + return_data.size
                                                                    _22156 = mem[_22046 + mem[_22046]]
                                                                    if mem[_22046 + mem[_22046]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22046 + ceil32(return_data.size) + ceil32(32 * mem[_22046 + mem[_22046]]) + 1 > test266151307() or ceil32(32 * mem[_22046 + mem[_22046]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22046 + ceil32(return_data.size) + ceil32(32 * mem[_22046 + mem[_22046]]) + 1
                                                                    mem[_22046 + ceil32(return_data.size)] = _22156
                                                                    require return_data.size >= _22124 + (32 * _22156) + 32
                                                                    t = _22046 + _22124 + 32
                                                                    u = _22046 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22156:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17535 + 164] = 2
                                                                    mem[64] = _17535 + 260
                                                                    mem[_17535 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + 228] = address(cd[36])
                                                                    mem[_17535 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + 296] = 0
                                                                    mem[_17535 + 328] = 160
                                                                    mem[_17535 + 424] = 2
                                                                    s = 0
                                                                    t = _17535 + 456
                                                                    u = _17535 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17535 + 360] = this.address
                                                                    mem[_17535 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17535 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22047 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22125 = mem[_22047]
                                                                    require mem[_22047] <= test266151307()
                                                                    require _22047 + mem[_22047] + 31 < _22047 + return_data.size
                                                                    _22157 = mem[_22047 + mem[_22047]]
                                                                    if mem[_22047 + mem[_22047]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22047 + ceil32(return_data.size) + ceil32(32 * mem[_22047 + mem[_22047]]) + 1 > test266151307() or ceil32(32 * mem[_22047 + mem[_22047]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22047 + ceil32(return_data.size) + ceil32(32 * mem[_22047 + mem[_22047]]) + 1
                                                                    mem[_22047 + ceil32(return_data.size)] = _22157
                                                                    require return_data.size >= _22125 + (32 * _22157) + 32
                                                                    t = _22047 + _22125 + 32
                                                                    u = _22047 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22157:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_17535 + 164] = return_data.size
                                                                mem[_17535 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17535 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17535 + ceil32(return_data.size) + 233] = mem[idx + _17535 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17535 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_17535 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17535 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17535 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17535 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17535 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17535 + ceil32(return_data.size) + 457
                                                                    w = _17535 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17535 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17535 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17535 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17535 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22126 = mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17535 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22158 = mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22158
                                                                    require return_data.size >= _22126 + (32 * _22158) + 32
                                                                    t = _17535 + ceil32(return_data.size) + _22126 + 293
                                                                    u = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22158:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_17535 + 196] == bool(mem[_17535 + 196])
                                                                    if not mem[_17535 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17535 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17535 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17535 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17535 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17535 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17535 + ceil32(return_data.size) + 457
                                                                    w = _17535 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17535 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17535 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17535 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17535 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22127 = mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17535 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22159 = mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22159
                                                                    require return_data.size >= _22127 + (32 * _22159) + 32
                                                                    t = _17535 + ceil32(return_data.size) + _22127 + 293
                                                                    u = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22159:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                        else:
                                                            mem[_18166 + _17535 + 164] = 0
                                                            call address(cd[((32 * idx) + cd[68] + 36)]).mem[_17535 + 164 len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[_17535 + 168 len _18166 - 4]
                                                            if not return_data.size:
                                                                if not ext_call.success:
                                                                    if mem[96]:
                                                                        revert with memory
                                                                          from 128
                                                                           len mem[96]
                                                                    mem[_17535 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + 168] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17535 + 232] = mem[idx + _17535 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17535 + 232]
                                                                if not mem[96]:
                                                                    mem[_17535 + 164] = 2
                                                                    mem[64] = _17535 + 260
                                                                    mem[_17535 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + 228] = address(cd[36])
                                                                    mem[_17535 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + 296] = 0
                                                                    mem[_17535 + 328] = 160
                                                                    mem[_17535 + 424] = 2
                                                                    s = 0
                                                                    t = _17535 + 456
                                                                    u = _17535 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17535 + 360] = this.address
                                                                    mem[_17535 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17535 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22054 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22128 = mem[_22054]
                                                                    require mem[_22054] <= test266151307()
                                                                    require _22054 + mem[_22054] + 31 < _22054 + return_data.size
                                                                    _22160 = mem[_22054 + mem[_22054]]
                                                                    if mem[_22054 + mem[_22054]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22054 + ceil32(return_data.size) + ceil32(32 * mem[_22054 + mem[_22054]]) + 1 > test266151307() or ceil32(32 * mem[_22054 + mem[_22054]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22054 + ceil32(return_data.size) + ceil32(32 * mem[_22054 + mem[_22054]]) + 1
                                                                    mem[_22054 + ceil32(return_data.size)] = _22160
                                                                    require return_data.size >= _22128 + (32 * _22160) + 32
                                                                    t = _22054 + _22128 + 32
                                                                    u = _22054 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22160:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require mem[96] >= 32
                                                                    require mem[128] == bool(mem[128])
                                                                    if not mem[128]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17535 + 164] = 2
                                                                    mem[64] = _17535 + 260
                                                                    mem[_17535 + 196] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + 228] = address(cd[36])
                                                                    mem[_17535 + 260] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + 264] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + 296] = 0
                                                                    mem[_17535 + 328] = 160
                                                                    mem[_17535 + 424] = 2
                                                                    s = 0
                                                                    t = _17535 + 456
                                                                    u = _17535 + 196
                                                                    while s < 2:
                                                                        mem[t] = mem[u + 12 len 20]
                                                                        s = s + 1
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        continue 
                                                                    mem[_17535 + 360] = this.address
                                                                    mem[_17535 + 392] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _17535 + -mem[64] + 516]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _22055 = mem[64]
                                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 32
                                                                    _22129 = mem[_22055]
                                                                    require mem[_22055] <= test266151307()
                                                                    require _22055 + mem[_22055] + 31 < _22055 + return_data.size
                                                                    _22161 = mem[_22055 + mem[_22055]]
                                                                    if mem[_22055 + mem[_22055]] > test266151307():
                                                                        revert with 0, 65
                                                                    if _22055 + ceil32(return_data.size) + ceil32(32 * mem[_22055 + mem[_22055]]) + 1 > test266151307() or ceil32(32 * mem[_22055 + mem[_22055]]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _22055 + ceil32(return_data.size) + ceil32(32 * mem[_22055 + mem[_22055]]) + 1
                                                                    mem[_22055 + ceil32(return_data.size)] = _22161
                                                                    require return_data.size >= _22129 + (32 * _22161) + 32
                                                                    t = _22055 + _22129 + 32
                                                                    u = _22055 + ceil32(return_data.size) + 32
                                                                    s = 0
                                                                    while s < _22161:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                            else:
                                                                mem[_17535 + 164] = return_data.size
                                                                mem[_17535 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                if not ext_call.success:
                                                                    if return_data.size:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17535 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + ceil32(return_data.size) + 169] = 32
                                                                    idx = 0
                                                                    while idx < 32:
                                                                        mem[idx + _17535 + ceil32(return_data.size) + 233] = mem[idx + _17535 + 132]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 32, mem[_17535 + ceil32(return_data.size) + 233]
                                                                if not return_data.size:
                                                                    mem[_17535 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17535 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17535 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17535 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17535 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17535 + ceil32(return_data.size) + 457
                                                                    w = _17535 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17535 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17535 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17535 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17535 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22130 = mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17535 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22162 = mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22162
                                                                    require return_data.size >= _22130 + (32 * _22162) + 32
                                                                    t = _17535 + ceil32(return_data.size) + _22130 + 293
                                                                    u = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22162:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                                                else:
                                                                    require return_data.size >= 32
                                                                    require mem[_17535 + 196] == bool(mem[_17535 + 196])
                                                                    if not mem[_17535 + 196]:
                                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                                    mem[_17535 + ceil32(return_data.size) + 165] = 2
                                                                    mem[_17535 + ceil32(return_data.size) + 197] = address(cd[((32 * idx) + cd[68] + 36)])
                                                                    mem[_17535 + ceil32(return_data.size) + 229] = address(cd[36])
                                                                    mem[_17535 + ceil32(return_data.size) + 261] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                                    mem[_17535 + ceil32(return_data.size) + 265] = cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]
                                                                    mem[_17535 + ceil32(return_data.size) + 297] = 0
                                                                    mem[_17535 + ceil32(return_data.size) + 329] = 160
                                                                    mem[_17535 + ceil32(return_data.size) + 425] = 2
                                                                    s = 0
                                                                    v = _17535 + ceil32(return_data.size) + 457
                                                                    w = _17535 + ceil32(return_data.size) + 197
                                                                    while s < 2:
                                                                        mem[v] = mem[w + 12 len 20]
                                                                        s = s + 1
                                                                        v = v + 32
                                                                        w = w + 32
                                                                        continue 
                                                                    mem[_17535 + ceil32(return_data.size) + 361] = this.address
                                                                    mem[_17535 + ceil32(return_data.size) + 393] = cd[228]
                                                                    require ext_code.size(address(cd[4]))
                                                                    call address(cd[4]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)], 0, 160, address(this.address), cd[228], 2, mem[_17535 + ceil32(return_data.size) + 457 len 64]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[_17535 + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261
                                                                    require return_data.size >= 32
                                                                    _22131 = mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32
                                                                    require mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 <= test266151307()
                                                                    require _17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 292 < _17535 + ceil32(return_data.size) + return_data.size + 261
                                                                    _22163 = mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]
                                                                    if mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261] > test266151307():
                                                                        revert with 0, 65
                                                                    if _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262 > test266151307() or ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 1 < 0:
                                                                        revert with 0, 65
                                                                    mem[64] = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[_17535 + ceil32(return_data.size) + mem[_17535 + ceil32(return_data.size) + 261 len 4], Mask(224, 32, cd[164] * cd[((32 * idx) + cd[132] + 36)] / 100 * t * u / cd[((32 * idx) + cd[100] + 36)]) >> 32 + 261]) + 262
                                                                    mem[_17535 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = _22163
                                                                    require return_data.size >= _22131 + (32 * _22163) + 32
                                                                    t = _17535 + ceil32(return_data.size) + _22131 + 293
                                                                    u = _17535 + ceil32(return_data.size) + ceil32(return_data.size) + 293
                                                                    s = 0
                                                                    while s < _22163:
                                                                        mem[u] = mem[t]
                                                                        t = t + 32
                                                                        u = u + 32
                                                                        s = s + 1
                                                                        continue 
                                            if idx >= ('cd', 68).length:
                                                revert with 0, 50
                                            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                                            mem[32] = 1
                                            sub_26e4baae[address(cd[((32 * idx) + cd[68] + 36)])] = 1
                                            if sub_8cf086ad > -2:
                                                revert with 0, 17
                                            sub_8cf086ad++
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                revert with 0, 'T'
            mem[160 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[256 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[192 len 42], ' is missing role ', mem[320 len 66], 0, 0 >> 928, 0
}



}

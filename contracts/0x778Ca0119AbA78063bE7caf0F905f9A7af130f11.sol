contract main {




// =====================  Runtime code  =====================


#
#  - sub_0886d0df(?)
#  - sub_10fec347(?)
#  - sub_399d71fd(?)
#  - sub_500f1313(?)
#  - sub_9ead80fd(?)
#
mapping of uint8 sub_f119462d;
mapping of uint8 stor1;
mapping of uint256 sub_c40571ec;
address stor3;

function sub_c40571ec(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_c40571ec[arg1]
}

function sub_f119462d(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    return uint256(sub_f119462d[arg1][arg2])
}

function sub_fa847836(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor1[arg1])
}

function _fallback() payable {
  stop
}

function isAllowed() {
    if 0x85a92368ab710a85f57b9872c0fe4361a405e5d != msg.sender:
        require msg.sender == 0xebdef90adcd0cef650afd081375570b391a6880a
    return 1
}

function sub_4e27b7d5(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if address(arg1) != 0xd8aa70f7990dab4a383a0d8a57df7a372916575d:
        if address(arg1) != 0xb9a9bb6cc39387548baa7185fbff51d47eef8771:
            return 0
    return 1
}

function sub_0050648d(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
}

function sub_90c3d203(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    if uint256(sub_f119462d[address(arg1)][address(arg2)]) == uint256(sub_f119462d[address(arg1)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    return uint256(sub_f119462d[address(arg1)][address(arg2)]), uint256(sub_f119462d[address(arg1)][address(arg3)])
}

function sub_02be4f86(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[132] = 0, mem[132 len 28]
    mem[136] = 0
    staticcall address(arg1).mem[132 len 4] with:
            gas gas_remaining wei
    if not return_data.size:
        mem[132] = 0, mem[132 len 4], 0
        return mem[132], 0, mem[168 len 24]
    mem[164 len return_data.size] = ext_call.return_data[0 len return_data.size]
    _41 = mem[196]
    mem[ceil32(return_data.size) + 133] = mem[164]
    return mem[ceil32(return_data.size) + 133], _41
}

function sub_a22da4b2(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    if uint256(sub_f119462d[address(arg5)][address(arg2)]) == uint256(sub_f119462d[address(arg5)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    require ext_code.size(address(arg5))
    staticcall address(arg5).calculateSwap(uint8 arg1, uint8 arg2, uint256 arg3) with:
            gas gas_remaining wei
           args uint8(sub_f119462d[address(arg5)][address(arg2)]), uint8(sub_f119462d[address(arg5)][address(arg3)]), arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] < 1:
        revert with 'NH{q', 17
    return (ext_call.return_data[0] - 1)
}

function withdraw(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] <= 0:
        revert with 0, 'not found'
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args 0x85a92368ab710a85f57b9872c0fe4361a405e5d, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if eth.balance(this.address) > 0:
        call 0x085a92368ab710a85f57b9872c0fe4361a405e5d with:
           value eth.balance(this.address) wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function sub_d80c6821(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    if uint256(sub_f119462d[address(arg5)][address(arg2)]) == uint256(sub_f119462d[address(arg5)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    if address(arg5) == 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
        require ext_code.size(address(arg5))
        call address(arg5).exchange_underlying(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4) with:
             gas gas_remaining wei
            args uint256(sub_f119462d[address(arg5)][address(arg2)]), uint256(sub_f119462d[address(arg5)][address(arg3)]), arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    if address(arg5) == 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
        require ext_code.size(address(arg5))
        call address(arg5).exchange_underlying(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
             gas gas_remaining wei
            args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    if address(arg5) == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
        require ext_code.size(address(arg5))
        call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
             gas gas_remaining wei
            args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        if address(arg5) == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
            require ext_code.size(address(arg5))
            call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
                 gas gas_remaining wei
                args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        else:
            if address(arg5) == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                require ext_code.size(address(arg5))
                call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
                     gas gas_remaining wei
                    args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                if address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                    require ext_code.size(address(arg5))
                    call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
                         gas gas_remaining wei
                        args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
}

function sub_36888411(?) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require ext_code.size(address(arg2))
    staticcall address(arg2).0x313ce567 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_code.size(address(arg3))
    staticcall address(arg3).0x313ce567 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] == ext_call.return_data[0]:
        return arg1
    if not ext_call.return_data[0]:
        if not ext_call.return_data[0]:
            if arg1 and 1 > -1 / arg1:
                revert with 'NH{q', 17
            return arg1
        if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
            if 10^ext_call.return_data[0] > -1:
                revert with 'NH{q', 17
            if arg1 and 10^ext_call.return_data[0] > -1 / arg1:
                revert with 'NH{q', 17
            return (arg1 * 10^ext_call.return_data[0])
        s = 10
        t = 1
        idx = ext_call.return_data[0]
        while idx > 1:
            if s > -1 / s:
                revert with 'NH{q', 17
            if not bool(idx):
                s = s * s
                t = t
                idx = uint255(idx) * 0.5
                continue 
            s = s * s
            t = t * s
            idx = uint255(idx) * 0.5
            continue 
        if t > -1 / s:
            revert with 'NH{q', 17
        if arg1 and t * s > -1 / arg1:
            revert with 'NH{q', 17
        return (arg1 * t * s)
    if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
        if 10^ext_call.return_data[0] > -1:
            revert with 'NH{q', 17
        if not ext_call.return_data[0]:
            if arg1 and 1 > -1 / arg1:
                revert with 'NH{q', 17
            if not 10^ext_call.return_data[0]:
                revert with 'NH{q', 18
            return (arg1 / 10^ext_call.return_data[0])
        if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
            if 10^ext_call.return_data[0] > -1:
                revert with 'NH{q', 17
            if arg1 and 10^ext_call.return_data[0] > -1 / arg1:
                revert with 'NH{q', 17
            if not 10^ext_call.return_data[0]:
                revert with 'NH{q', 18
            return (arg1 * 10^ext_call.return_data[0] / 10^ext_call.return_data[0])
        s = 10
        t = 1
        idx = ext_call.return_data[0]
        while idx > 1:
            if s > -1 / s:
                revert with 'NH{q', 17
            if not bool(idx):
                s = s * s
                t = t
                idx = uint255(idx) * 0.5
                continue 
            s = s * s
            t = t * s
            idx = uint255(idx) * 0.5
            continue 
        if t > -1 / s:
            revert with 'NH{q', 17
        if arg1 and t * s > -1 / arg1:
            revert with 'NH{q', 17
        if not 10^ext_call.return_data[0]:
            revert with 'NH{q', 18
        return (arg1 * t * s / 10^ext_call.return_data[0])
    s = 10
    t = 1
    idx = ext_call.return_data[0]
    while idx > 1:
        if s > -1 / s:
            revert with 'NH{q', 17
        if not bool(idx):
            s = s * s
            t = t
            idx = uint255(idx) * 0.5
            continue 
        s = s * s
        t = t * s
        idx = uint255(idx) * 0.5
        continue 
    if t > -1 / s:
        revert with 'NH{q', 17
    if not ext_call.return_data[0]:
        if arg1 and 1 > -1 / arg1:
            revert with 'NH{q', 17
        if not t * s:
            revert with 'NH{q', 18
        return (arg1 / t * s)
    if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
        if 10^ext_call.return_data[0] > -1:
            revert with 'NH{q', 17
        if arg1 and 10^ext_call.return_data[0] > -1 / arg1:
            revert with 'NH{q', 17
        if not t * s:
            revert with 'NH{q', 18
        return (arg1 * 10^ext_call.return_data[0] / t * s)
    u = 10
    v = 1
    idx = ext_call.return_data[0]
    while idx > 1:
        if u > -1 / u:
            revert with 'NH{q', 17
        if not bool(idx):
            u = u * u
            v = v
            idx = uint255(idx) * 0.5
            continue 
        u = u * u
        v = v * u
        idx = uint255(idx) * 0.5
        continue 
    if v > -1 / u:
        revert with 'NH{q', 17
    if arg1 and v * u > -1 / arg1:
        revert with 'NH{q', 17
    if not t * s:
        revert with 'NH{q', 18
    return (arg1 * v * u / t * s)
}

function sub_2e6595c0(?) {
    require calldata.size - 4 >= 64
    require cd[4] == cd[4]
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 36).length) + 97 > test266151307() or floor32(('cd', 36).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 36).length) + 97
    mem[96] = ('cd', 36).length
    require cd[36] + (192 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require calldata.size - s >= 192
        _286 = mem[64]
        if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 192
        require cd[s] == address(cd[s])
        mem[_286] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_286 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == address(cd[(s + 64)])
        mem[_286 + 64] = cd[(s + 64)]
        require cd[(s + 96)] == address(cd[(s + 96)])
        mem[_286 + 96] = cd[(s + 96)]
        require cd[(s + 128)] == cd[(s + 128)]
        mem[_286 + 128] = cd[(s + 128)]
        require cd[(s + 160)] == cd[(s + 160)]
        mem[_286 + 160] = cd[(s + 160)]
        mem[t] = _286
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    if 0 >= mem[96]:
        revert with 'NH{q', 50
    if mem[96] < 1:
        revert with 'NH{q', 17
    if mem[96] - 1 >= mem[96]:
        revert with 'NH{q', 50
    if stor3:
        if mem[mem[128] + 12 len 20] == mem[mem[(32 * mem[96] - 1) + 128] + 44 len 20]:
            if mem[mem[128] + 160] == 1:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                    if mem[96] == 2:
                        return 1
                    if mem[96] != 3:
                        return 1
                    mem[0] = mem[mem[128] + 44 len 20]
                    mem[32] = 1
                    if stor1[mem[0]]:
                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                        if stor1[mem[0]]:
                            return 1
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                        if mem[96] == 2:
                            return 1
                        if mem[96] != 3:
                            return 1
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if stor1[mem[0]]:
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            if stor1[mem[0]]:
                                return 1
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                            if mem[96] == 2:
                                return 1
                            if mem[96] != 3:
                                return 1
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if stor1[mem[0]]:
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                if stor1[mem[0]]:
                                    return 1
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
            else:
                if mem[mem[128] + 160] == 7:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                        if mem[96] == 2:
                            return 1
                        if mem[96] != 3:
                            return 1
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if stor1[mem[0]]:
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            if stor1[mem[0]]:
                                return 1
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                            if mem[96] == 2:
                                return 1
                            if mem[96] != 3:
                                return 1
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if stor1[mem[0]]:
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                if stor1[mem[0]]:
                                    return 1
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
                            else:
                                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                    if mem[96] == 2:
                                        return 1
                                    if mem[96] != 3:
                                        return 1
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if stor1[mem[0]]:
                                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                        if stor1[mem[0]]:
                                            return 1
                else:
                    if mem[mem[128] + 160] == 13:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                            if mem[96] == 2:
                                return 1
                            if mem[96] != 3:
                                return 1
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if stor1[mem[0]]:
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                if stor1[mem[0]]:
                                    return 1
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
                            else:
                                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                                    if mem[96] == 2:
                                        return 1
                                    if mem[96] != 3:
                                        return 1
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if stor1[mem[0]]:
                                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                        if stor1[mem[0]]:
                                            return 1
                                else:
                                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                        if mem[96] == 2:
                                            return 1
                                        if mem[96] != 3:
                                            return 1
                                        mem[0] = mem[mem[128] + 44 len 20]
                                        mem[32] = 1
                                        if stor1[mem[0]]:
                                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                            if stor1[mem[0]]:
                                                return 1
                    else:
                        if mem[mem[128] + 160] == 14:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
                            else:
                                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                                    if mem[96] == 2:
                                        return 1
                                    if mem[96] != 3:
                                        return 1
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if stor1[mem[0]]:
                                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                        if stor1[mem[0]]:
                                            return 1
                                else:
                                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                                        if mem[96] == 2:
                                            return 1
                                        if mem[96] != 3:
                                            return 1
                                        mem[0] = mem[mem[128] + 44 len 20]
                                        mem[32] = 1
                                        if stor1[mem[0]]:
                                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                            if stor1[mem[0]]:
                                                return 1
                                    else:
                                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                            if mem[96] == 2:
                                                return 1
                                            if mem[96] != 3:
                                                return 1
                                            mem[0] = mem[mem[128] + 44 len 20]
                                            mem[32] = 1
                                            if stor1[mem[0]]:
                                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                                if stor1[mem[0]]:
                                                    return 1
    return 0
}

function sub_5bf03be3(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    if uint256(sub_f119462d[address(arg5)][address(arg2)]) == uint256(sub_f119462d[address(arg5)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    if address(arg5) != 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
        if address(arg5) != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
            if address(arg5) != 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                if address(arg5) != 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    if address(arg5) != 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        if address(arg5) != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            revert with 'NH{q', 17
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
        else:
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if address(arg5) == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                require ext_code.size(address(arg5))
                staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                        gas gas_remaining wei
                       args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
            else:
                if address(arg5) == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    require ext_code.size(address(arg5))
                    staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                            gas gas_remaining wei
                           args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                else:
                    if address(arg5) == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        require ext_code.size(address(arg5))
                        staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                gas gas_remaining wei
                               args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                    else:
                        if address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            require ext_code.size(address(arg5))
                            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                    gas gas_remaining wei
                                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
    else:
        require ext_code.size(address(arg5))
        staticcall address(arg5).get_dy_underlying(uint256 arg1, uint256 arg2, uint256 arg3) with:
                gas gas_remaining wei
               args uint256(sub_f119462d[address(arg5)][address(arg2)]), uint256(sub_f119462d[address(arg5)][address(arg3)]), arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if ext_call.return_data[0] and 9996 > -1 / ext_call.return_data[0]:
            revert with 'NH{q', 17
        if address(arg5) != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
            if address(arg5) != 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                if address(arg5) != 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    if address(arg5) != 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        if address(arg5) != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            if 9996 * ext_call.return_data[0] / 10000 < 1:
                                revert with 'NH{q', 17
                            return ((9996 * ext_call.return_data[0] / 10000) - 1)
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
        else:
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if address(arg5) == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                require ext_code.size(address(arg5))
                staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                        gas gas_remaining wei
                       args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
            else:
                if address(arg5) == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    require ext_code.size(address(arg5))
                    staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                            gas gas_remaining wei
                           args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                else:
                    if address(arg5) == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        require ext_code.size(address(arg5))
                        staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                gas gas_remaining wei
                               args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                    else:
                        if address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            require ext_code.size(address(arg5))
                            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                    gas gas_remaining wei
                                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] < 1:
        revert with 'NH{q', 17
    return (ext_call.return_data[0] - 1)
}

function sub_c54820e8(?) {
    require calldata.size - 4 >= 64
    require cd[4] == cd[4]
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 36).length) + 97 > test266151307() or floor32(('cd', 36).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 36).length) + 97
    mem[96] = ('cd', 36).length
    require cd[36] + (192 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require calldata.size - s >= 192
        _1941 = mem[64]
        if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 192
        require cd[s] == address(cd[s])
        mem[_1941] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_1941 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == address(cd[(s + 64)])
        mem[_1941 + 64] = cd[(s + 64)]
        require cd[(s + 96)] == address(cd[(s + 96)])
        mem[_1941 + 96] = cd[(s + 96)]
        require cd[(s + 128)] == cd[(s + 128)]
        mem[_1941 + 128] = cd[(s + 128)]
        require cd[(s + 160)] == cd[(s + 160)]
        mem[_1941 + 160] = cd[(s + 160)]
        mem[t] = _1941
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    if 0 >= mem[96]:
        revert with 'NH{q', 50
    if mem[96] < 1:
        revert with 'NH{q', 17
    if mem[96] - 1 >= mem[96]:
        revert with 'NH{q', 50
    if not stor3:
        return cd[4]
    if mem[mem[128] + 12 len 20] != mem[mem[(32 * mem[96] - 1) + 128] + 44 len 20]:
        return cd[4]
    if mem[mem[128] + 160] == 1:
        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
            if mem[96] == 2:
                if 0 >= mem[96]:
                    revert with 'NH{q', 50
                _2022 = mem[128]
                if mem[96] < 1:
                    revert with 'NH{q', 17
                if mem[96] - 1 >= mem[96]:
                    revert with 'NH{q', 50
                _2208 = mem[(32 * mem[96] - 1) + 128]
                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = mem[_2022 + 12 len 20]
                mem[mem[64] + 36] = mem[_2022 + 44 len 20]
                mem[mem[64] + 68] = mem[_2022 + 76 len 20]
                mem[mem[64] + 100] = mem[_2022 + 108 len 20]
                mem[mem[64] + 132] = mem[_2022 + 128]
                mem[mem[64] + 164] = mem[_2022 + 160]
                mem[mem[64] + 196] = mem[_2208 + 12 len 20]
                mem[mem[64] + 228] = mem[_2208 + 44 len 20]
                mem[mem[64] + 260] = mem[_2208 + 76 len 20]
                mem[mem[64] + 292] = mem[_2208 + 108 len 20]
                mem[mem[64] + 324] = mem[_2208 + 128]
                mem[mem[64] + 356] = mem[_2208 + 160]
                require ext_code.size(stor3)
                staticcall stor3.0x6fbc9807 with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len 384]
                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2993 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                require mem[_2993] == bool(mem[_2993])
                _3124 = mem[_2993 + 32]
                require mem[_2993 + 32] == mem[_2993 + 32]
                if not mem[_2993]:
                    revert with 0, 'B'
                if 0 >= mem[96]:
                    revert with 'NH{q', 50
                _3188 = mem[mem[128]]
                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                require ext_code.size(address(_3188))
                staticcall address(_3188).0x70a08231 with:
                        gas gas_remaining wei
                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3441 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_3441] == mem[_3441]
                if _3124 < mem[_3441]:
                    if _3124:
                        return _3124
                    return cd[4]
                if not mem[_3441]:
                    return cd[4]
                mem[mem[64]] = mem[_3441]
            else:
                if mem[96] != 3:
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2072 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2257 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2072 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2072 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2072 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2072 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2072 + 128]
                    mem[mem[64] + 164] = mem[_2072 + 160]
                    mem[mem[64] + 196] = mem[_2257 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2257 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2257 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2257 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2257 + 128]
                    mem[mem[64] + 356] = mem[_2257 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3016 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3016] == bool(mem[_3016])
                    _3139 = mem[_3016 + 32]
                    require mem[_3016 + 32] == mem[_3016 + 32]
                    if not mem[_3016]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3229 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3229))
                    staticcall address(_3229).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3474 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3474] == mem[_3474]
                    if _3139 < mem[_3474]:
                        if _3139:
                            return _3139
                        return cd[4]
                    if not mem[_3474]:
                        return cd[4]
                    mem[mem[64]] = mem[_3474]
                else:
                    mem[0] = mem[mem[128] + 44 len 20]
                    mem[32] = 1
                    if not stor1[mem[0]]:
                        return cd[4]
                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                    mem[32] = 1
                    if not stor1[mem[0]]:
                        return cd[4]
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2142 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2344 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2142 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2142 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2142 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2142 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2142 + 128]
                    mem[mem[64] + 164] = mem[_2142 + 160]
                    mem[mem[64] + 196] = mem[_2344 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2344 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2344 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2344 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2344 + 128]
                    mem[mem[64] + 356] = mem[_2344 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3061 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3061] == bool(mem[_3061])
                    _3161 = mem[_3061 + 32]
                    require mem[_3061 + 32] == mem[_3061 + 32]
                    if not mem[_3061]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3324 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3324))
                    staticcall address(_3324).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3535 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3535] == mem[_3535]
                    if _3161 < mem[_3535]:
                        if _3161:
                            return _3161
                        return cd[4]
                    if not mem[_3535]:
                        return cd[4]
                    mem[mem[64]] = mem[_3535]
        else:
            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                if mem[96] == 2:
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2046 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2231 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2046 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2046 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2046 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2046 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2046 + 128]
                    mem[mem[64] + 164] = mem[_2046 + 160]
                    mem[mem[64] + 196] = mem[_2231 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2231 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2231 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2231 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2231 + 128]
                    mem[mem[64] + 356] = mem[_2231 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3004 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3004] == bool(mem[_3004])
                    _3132 = mem[_3004 + 32]
                    require mem[_3004 + 32] == mem[_3004 + 32]
                    if not mem[_3004]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3202 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3202))
                    staticcall address(_3202).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3458 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3458] == mem[_3458]
                    if _3132 < mem[_3458]:
                        if _3132:
                            return _3132
                        return cd[4]
                    if not mem[_3458]:
                        return cd[4]
                    mem[mem[64]] = mem[_3458]
                else:
                    if mem[96] != 3:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2097 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2283 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2097 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2097 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2097 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2097 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2097 + 128]
                        mem[mem[64] + 164] = mem[_2097 + 160]
                        mem[mem[64] + 196] = mem[_2283 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2283 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2283 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2283 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2283 + 128]
                        mem[mem[64] + 356] = mem[_2283 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3029 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3029] == bool(mem[_3029])
                        _3147 = mem[_3029 + 32]
                        require mem[_3029 + 32] == mem[_3029 + 32]
                        if not mem[_3029]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3259 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3259))
                        staticcall address(_3259).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3492 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3492] == mem[_3492]
                        if _3147 < mem[_3492]:
                            if _3147:
                                return _3147
                            return cd[4]
                        if not mem[_3492]:
                            return cd[4]
                        mem[mem[64]] = mem[_3492]
                    else:
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2162 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2374 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2162 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2162 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2162 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2162 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2162 + 128]
                        mem[mem[64] + 164] = mem[_2162 + 160]
                        mem[mem[64] + 196] = mem[_2374 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2374 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2374 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2374 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2374 + 128]
                        mem[mem[64] + 356] = mem[_2374 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3078 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3078] == bool(mem[_3078])
                        _3167 = mem[_3078 + 32]
                        require mem[_3078 + 32] == mem[_3078 + 32]
                        if not mem[_3078]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3352 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3352))
                        staticcall address(_3352).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3555 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3555] == mem[_3555]
                        if _3167 < mem[_3555]:
                            if _3167:
                                return _3167
                            return cd[4]
                        if not mem[_3555]:
                            return cd[4]
                        mem[mem[64]] = mem[_3555]
            else:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2069 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2254 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2069 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2069 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2069 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2069 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2069 + 128]
                        mem[mem[64] + 164] = mem[_2069 + 160]
                        mem[mem[64] + 196] = mem[_2254 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2254 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2254 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2254 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2254 + 128]
                        mem[mem[64] + 356] = mem[_2254 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3015 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3015] == bool(mem[_3015])
                        _3138 = mem[_3015 + 32]
                        require mem[_3015 + 32] == mem[_3015 + 32]
                        if not mem[_3015]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3224 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3224))
                        staticcall address(_3224).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3473 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3473] == mem[_3473]
                        if _3138 < mem[_3473]:
                            if _3138:
                                return _3138
                            return cd[4]
                        if not mem[_3473]:
                            return cd[4]
                        mem[mem[64]] = mem[_3473]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2119 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2308 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2119 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2119 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2119 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2119 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2119 + 128]
                            mem[mem[64] + 164] = mem[_2119 + 160]
                            mem[mem[64] + 196] = mem[_2308 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2308 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2308 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2308 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2308 + 128]
                            mem[mem[64] + 356] = mem[_2308 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3043 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3043] == bool(mem[_3043])
                            _3154 = mem[_3043 + 32]
                            require mem[_3043 + 32] == mem[_3043 + 32]
                            if not mem[_3043]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3289 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3289))
                            staticcall address(_3289).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3511 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3511] == mem[_3511]
                            if _3154 < mem[_3511]:
                                if _3154:
                                    return _3154
                                return cd[4]
                            if not mem[_3511]:
                                return cd[4]
                            mem[mem[64]] = mem[_3511]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2182 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2402 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2182 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2182 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2182 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2182 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2182 + 128]
                            mem[mem[64] + 164] = mem[_2182 + 160]
                            mem[mem[64] + 196] = mem[_2402 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2402 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2402 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2402 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2402 + 128]
                            mem[mem[64] + 356] = mem[_2402 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3092 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3092] == bool(mem[_3092])
                            _3172 = mem[_3092 + 32]
                            require mem[_3092 + 32] == mem[_3092 + 32]
                            if not mem[_3092]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3377 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3377))
                            staticcall address(_3377).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3571 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3571] == mem[_3571]
                            if _3172 < mem[_3571]:
                                if _3172:
                                    return _3172
                                return cd[4]
                            if not mem[_3571]:
                                return cd[4]
                            mem[mem[64]] = mem[_3571]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                        return cd[4]
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2094 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2280 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2094 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2094 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2094 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2094 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2094 + 128]
                        mem[mem[64] + 164] = mem[_2094 + 160]
                        mem[mem[64] + 196] = mem[_2280 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2280 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2280 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2280 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2280 + 128]
                        mem[mem[64] + 356] = mem[_2280 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3028 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3028] == bool(mem[_3028])
                        _3146 = mem[_3028 + 32]
                        require mem[_3028 + 32] == mem[_3028 + 32]
                        if not mem[_3028]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3254 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3254))
                        staticcall address(_3254).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3491 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3491] == mem[_3491]
                        if _3146 < mem[_3491]:
                            if _3146:
                                return _3146
                            return cd[4]
                        if not mem[_3491]:
                            return cd[4]
                        mem[mem[64]] = mem[_3491]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2138 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2337 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2138 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2138 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2138 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2138 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2138 + 128]
                            mem[mem[64] + 164] = mem[_2138 + 160]
                            mem[mem[64] + 196] = mem[_2337 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2337 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2337 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2337 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2337 + 128]
                            mem[mem[64] + 356] = mem[_2337 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3057 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3057] == bool(mem[_3057])
                            _3160 = mem[_3057 + 32]
                            require mem[_3057 + 32] == mem[_3057 + 32]
                            if not mem[_3057]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3319 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3319))
                            staticcall address(_3319).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3530 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3530] == mem[_3530]
                            if _3160 < mem[_3530]:
                                if _3160:
                                    return _3160
                                return cd[4]
                            if not mem[_3530]:
                                return cd[4]
                            mem[mem[64]] = mem[_3530]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2204 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2426 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2204 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2204 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2204 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2204 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2204 + 128]
                            mem[mem[64] + 164] = mem[_2204 + 160]
                            mem[mem[64] + 196] = mem[_2426 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2426 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2426 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2426 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2426 + 128]
                            mem[mem[64] + 356] = mem[_2426 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3105 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3105] == bool(mem[_3105])
                            _3177 = mem[_3105 + 32]
                            require mem[_3105 + 32] == mem[_3105 + 32]
                            if not mem[_3105]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3400 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3400))
                            staticcall address(_3400).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3585 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3585] == mem[_3585]
                            if _3177 < mem[_3585]:
                                if _3177:
                                    return _3177
                                return cd[4]
                            if not mem[_3585]:
                                return cd[4]
                            mem[mem[64]] = mem[_3585]
    else:
        if mem[mem[128] + 160] == 7:
            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                if mem[96] == 2:
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2041 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2226 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2041 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2041 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2041 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2041 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2041 + 128]
                    mem[mem[64] + 164] = mem[_2041 + 160]
                    mem[mem[64] + 196] = mem[_2226 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2226 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2226 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2226 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2226 + 128]
                    mem[mem[64] + 356] = mem[_2226 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3001 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3001] == bool(mem[_3001])
                    _3130 = mem[_3001 + 32]
                    require mem[_3001 + 32] == mem[_3001 + 32]
                    if not mem[_3001]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3197 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3197))
                    staticcall address(_3197).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3454 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3454] == mem[_3454]
                    if _3130 < mem[_3454]:
                        if _3130:
                            return _3130
                        return cd[4]
                    if not mem[_3454]:
                        return cd[4]
                    mem[mem[64]] = mem[_3454]
                else:
                    if mem[96] != 3:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2091 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2277 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2091 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2091 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2091 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2091 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2091 + 128]
                        mem[mem[64] + 164] = mem[_2091 + 160]
                        mem[mem[64] + 196] = mem[_2277 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2277 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2277 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2277 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2277 + 128]
                        mem[mem[64] + 356] = mem[_2277 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3026 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3026] == bool(mem[_3026])
                        _3145 = mem[_3026 + 32]
                        require mem[_3026 + 32] == mem[_3026 + 32]
                        if not mem[_3026]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3251 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3251))
                        staticcall address(_3251).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3488 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3488] == mem[_3488]
                        if _3145 < mem[_3488]:
                            if _3145:
                                return _3145
                            return cd[4]
                        if not mem[_3488]:
                            return cd[4]
                        mem[mem[64]] = mem[_3488]
                    else:
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2158 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2368 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2158 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2158 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2158 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2158 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2158 + 128]
                        mem[mem[64] + 164] = mem[_2158 + 160]
                        mem[mem[64] + 196] = mem[_2368 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2368 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2368 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2368 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2368 + 128]
                        mem[mem[64] + 356] = mem[_2368 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3074 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3074] == bool(mem[_3074])
                        _3166 = mem[_3074 + 32]
                        require mem[_3074 + 32] == mem[_3074 + 32]
                        if not mem[_3074]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3347 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3347))
                        staticcall address(_3347).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3551 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3551] == mem[_3551]
                        if _3166 < mem[_3551]:
                            if _3166:
                                return _3166
                            return cd[4]
                        if not mem[_3551]:
                            return cd[4]
                        mem[mem[64]] = mem[_3551]
            else:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2065 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2250 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2065 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2065 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2065 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2065 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2065 + 128]
                        mem[mem[64] + 164] = mem[_2065 + 160]
                        mem[mem[64] + 196] = mem[_2250 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2250 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2250 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2250 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2250 + 128]
                        mem[mem[64] + 356] = mem[_2250 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3013 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3013] == bool(mem[_3013])
                        _3137 = mem[_3013 + 32]
                        require mem[_3013 + 32] == mem[_3013 + 32]
                        if not mem[_3013]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3217 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3217))
                        staticcall address(_3217).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3470 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3470] == mem[_3470]
                        if _3137 < mem[_3470]:
                            if _3137:
                                return _3137
                            return cd[4]
                        if not mem[_3470]:
                            return cd[4]
                        mem[mem[64]] = mem[_3470]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2116 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2303 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2116 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2116 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2116 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2116 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2116 + 128]
                            mem[mem[64] + 164] = mem[_2116 + 160]
                            mem[mem[64] + 196] = mem[_2303 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2303 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2303 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2303 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2303 + 128]
                            mem[mem[64] + 356] = mem[_2303 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3040 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3040] == bool(mem[_3040])
                            _3153 = mem[_3040 + 32]
                            require mem[_3040 + 32] == mem[_3040 + 32]
                            if not mem[_3040]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3284 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3284))
                            staticcall address(_3284).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3507 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3507] == mem[_3507]
                            if _3153 < mem[_3507]:
                                if _3153:
                                    return _3153
                                return cd[4]
                            if not mem[_3507]:
                                return cd[4]
                            mem[mem[64]] = mem[_3507]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2177 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2397 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2177 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2177 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2177 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2177 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2177 + 128]
                            mem[mem[64] + 164] = mem[_2177 + 160]
                            mem[mem[64] + 196] = mem[_2397 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2397 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2397 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2397 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2397 + 128]
                            mem[mem[64] + 356] = mem[_2397 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3090 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3090] == bool(mem[_3090])
                            _3171 = mem[_3090 + 32]
                            require mem[_3090 + 32] == mem[_3090 + 32]
                            if not mem[_3090]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3372 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3372))
                            staticcall address(_3372).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3569 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3569] == mem[_3569]
                            if _3171 < mem[_3569]:
                                if _3171:
                                    return _3171
                                return cd[4]
                            if not mem[_3569]:
                                return cd[4]
                            mem[mem[64]] = mem[_3569]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2088 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2274 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2088 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2088 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2088 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2088 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2088 + 128]
                            mem[mem[64] + 164] = mem[_2088 + 160]
                            mem[mem[64] + 196] = mem[_2274 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2274 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2274 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2274 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2274 + 128]
                            mem[mem[64] + 356] = mem[_2274 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3025 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3025] == bool(mem[_3025])
                            _3144 = mem[_3025 + 32]
                            require mem[_3025 + 32] == mem[_3025 + 32]
                            if not mem[_3025]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3246 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3246))
                            staticcall address(_3246).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3487 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3487] == mem[_3487]
                            if _3144 < mem[_3487]:
                                if _3144:
                                    return _3144
                                return cd[4]
                            if not mem[_3487]:
                                return cd[4]
                            mem[mem[64]] = mem[_3487]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2135 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2330 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2135 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2135 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2135 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2135 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2135 + 128]
                                mem[mem[64] + 164] = mem[_2135 + 160]
                                mem[mem[64] + 196] = mem[_2330 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2330 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2330 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2330 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2330 + 128]
                                mem[mem[64] + 356] = mem[_2330 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3054 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3054] == bool(mem[_3054])
                                _3159 = mem[_3054 + 32]
                                require mem[_3054 + 32] == mem[_3054 + 32]
                                if not mem[_3054]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3314 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3314))
                                staticcall address(_3314).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3526 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3526] == mem[_3526]
                                if _3159 < mem[_3526]:
                                    if _3159:
                                        return _3159
                                    return cd[4]
                                if not mem[_3526]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3526]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2199 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2423 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2199 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2199 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2199 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2199 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2199 + 128]
                                mem[mem[64] + 164] = mem[_2199 + 160]
                                mem[mem[64] + 196] = mem[_2423 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2423 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2423 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2423 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2423 + 128]
                                mem[mem[64] + 356] = mem[_2423 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3103 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3103] == bool(mem[_3103])
                                _3176 = mem[_3103 + 32]
                                require mem[_3103 + 32] == mem[_3103 + 32]
                                if not mem[_3103]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3396 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3396))
                                staticcall address(_3396).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3583 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3583] == mem[_3583]
                                if _3176 < mem[_3583]:
                                    if _3176:
                                        return _3176
                                    return cd[4]
                                if not mem[_3583]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3583]
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                            return cd[4]
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2113 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2300 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2113 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2113 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2113 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2113 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2113 + 128]
                            mem[mem[64] + 164] = mem[_2113 + 160]
                            mem[mem[64] + 196] = mem[_2300 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2300 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2300 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2300 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2300 + 128]
                            mem[mem[64] + 356] = mem[_2300 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3039 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3039] == bool(mem[_3039])
                            _3152 = mem[_3039 + 32]
                            require mem[_3039 + 32] == mem[_3039 + 32]
                            if not mem[_3039]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3279 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3279))
                            staticcall address(_3279).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3506 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3506] == mem[_3506]
                            if _3152 < mem[_3506]:
                                if _3152:
                                    return _3152
                                return cd[4]
                            if not mem[_3506]:
                                return cd[4]
                            mem[mem[64]] = mem[_3506]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2154 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2361 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2154 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2154 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2154 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2154 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2154 + 128]
                                mem[mem[64] + 164] = mem[_2154 + 160]
                                mem[mem[64] + 196] = mem[_2361 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2361 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2361 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2361 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2361 + 128]
                                mem[mem[64] + 356] = mem[_2361 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3070 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3070] == bool(mem[_3070])
                                _3165 = mem[_3070 + 32]
                                require mem[_3070 + 32] == mem[_3070 + 32]
                                if not mem[_3070]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3342 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3342))
                                staticcall address(_3342).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3546 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3546] == mem[_3546]
                                if _3165 < mem[_3546]:
                                    if _3165:
                                        return _3165
                                    return cd[4]
                                if not mem[_3546]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3546]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2222 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2442 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2222 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2222 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2222 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2222 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2222 + 128]
                                mem[mem[64] + 164] = mem[_2222 + 160]
                                mem[mem[64] + 196] = mem[_2442 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2442 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2442 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2442 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2442 + 128]
                                mem[mem[64] + 356] = mem[_2442 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3114 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3114] == bool(mem[_3114])
                                _3182 = mem[_3114 + 32]
                                require mem[_3114 + 32] == mem[_3114 + 32]
                                if not mem[_3114]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3416 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3416))
                                staticcall address(_3416).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3594 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3594] == mem[_3594]
                                if _3182 < mem[_3594]:
                                    if _3182:
                                        return _3182
                                    return cd[4]
                                if not mem[_3594]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3594]
        else:
            if mem[mem[128] + 160] == 13:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2060 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2245 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2060 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2060 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2060 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2060 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2060 + 128]
                        mem[mem[64] + 164] = mem[_2060 + 160]
                        mem[mem[64] + 196] = mem[_2245 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2245 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2245 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2245 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2245 + 128]
                        mem[mem[64] + 356] = mem[_2245 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3010 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3010] == bool(mem[_3010])
                        _3135 = mem[_3010 + 32]
                        require mem[_3010 + 32] == mem[_3010 + 32]
                        if not mem[_3010]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3212 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3212))
                        staticcall address(_3212).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3466 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3466] == mem[_3466]
                        if _3135 < mem[_3466]:
                            if _3135:
                                return _3135
                            return cd[4]
                        if not mem[_3466]:
                            return cd[4]
                        mem[mem[64]] = mem[_3466]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2110 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2297 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2110 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2110 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2110 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2110 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2110 + 128]
                            mem[mem[64] + 164] = mem[_2110 + 160]
                            mem[mem[64] + 196] = mem[_2297 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2297 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2297 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2297 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2297 + 128]
                            mem[mem[64] + 356] = mem[_2297 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3037 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3037] == bool(mem[_3037])
                            _3151 = mem[_3037 + 32]
                            require mem[_3037 + 32] == mem[_3037 + 32]
                            if not mem[_3037]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3276 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3276))
                            staticcall address(_3276).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3503 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3503] == mem[_3503]
                            if _3151 < mem[_3503]:
                                if _3151:
                                    return _3151
                                return cd[4]
                            if not mem[_3503]:
                                return cd[4]
                            mem[mem[64]] = mem[_3503]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2173 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2391 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2173 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2173 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2173 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2173 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2173 + 128]
                            mem[mem[64] + 164] = mem[_2173 + 160]
                            mem[mem[64] + 196] = mem[_2391 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2391 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2391 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2391 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2391 + 128]
                            mem[mem[64] + 356] = mem[_2391 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3086 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3086] == bool(mem[_3086])
                            _3170 = mem[_3086 + 32]
                            require mem[_3086 + 32] == mem[_3086 + 32]
                            if not mem[_3086]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3367 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3367))
                            staticcall address(_3367).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3565 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3565] == mem[_3565]
                            if _3170 < mem[_3565]:
                                if _3170:
                                    return _3170
                                return cd[4]
                            if not mem[_3565]:
                                return cd[4]
                            mem[mem[64]] = mem[_3565]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2084 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2270 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2084 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2084 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2084 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2084 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2084 + 128]
                            mem[mem[64] + 164] = mem[_2084 + 160]
                            mem[mem[64] + 196] = mem[_2270 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2270 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2270 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2270 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2270 + 128]
                            mem[mem[64] + 356] = mem[_2270 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3023 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3023] == bool(mem[_3023])
                            _3143 = mem[_3023 + 32]
                            require mem[_3023 + 32] == mem[_3023 + 32]
                            if not mem[_3023]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3239 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3239))
                            staticcall address(_3239).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3484 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3484] == mem[_3484]
                            if _3143 < mem[_3484]:
                                if _3143:
                                    return _3143
                                return cd[4]
                            if not mem[_3484]:
                                return cd[4]
                            mem[mem[64]] = mem[_3484]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2132 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2325 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2132 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2132 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2132 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2132 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2132 + 128]
                                mem[mem[64] + 164] = mem[_2132 + 160]
                                mem[mem[64] + 196] = mem[_2325 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2325 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2325 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2325 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2325 + 128]
                                mem[mem[64] + 356] = mem[_2325 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3051 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3051] == bool(mem[_3051])
                                _3158 = mem[_3051 + 32]
                                require mem[_3051 + 32] == mem[_3051 + 32]
                                if not mem[_3051]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3309 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3309))
                                staticcall address(_3309).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3522 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3522] == mem[_3522]
                                if _3158 < mem[_3522]:
                                    if _3158:
                                        return _3158
                                    return cd[4]
                                if not mem[_3522]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3522]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2194 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2418 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2194 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2194 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2194 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2194 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2194 + 128]
                                mem[mem[64] + 164] = mem[_2194 + 160]
                                mem[mem[64] + 196] = mem[_2418 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2418 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2418 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2418 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2418 + 128]
                                mem[mem[64] + 356] = mem[_2418 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3101 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3101] == bool(mem[_3101])
                                _3175 = mem[_3101 + 32]
                                require mem[_3101 + 32] == mem[_3101 + 32]
                                if not mem[_3101]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3391 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3391))
                                staticcall address(_3391).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3581 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3581] == mem[_3581]
                                if _3175 < mem[_3581]:
                                    if _3175:
                                        return _3175
                                    return cd[4]
                                if not mem[_3581]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3581]
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2107 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2294 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2107 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2107 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2107 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2107 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2107 + 128]
                                mem[mem[64] + 164] = mem[_2107 + 160]
                                mem[mem[64] + 196] = mem[_2294 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2294 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2294 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2294 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2294 + 128]
                                mem[mem[64] + 356] = mem[_2294 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3036 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3036] == bool(mem[_3036])
                                _3150 = mem[_3036 + 32]
                                require mem[_3036 + 32] == mem[_3036 + 32]
                                if not mem[_3036]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3271 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3271))
                                staticcall address(_3271).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3502 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3502] == mem[_3502]
                                if _3150 < mem[_3502]:
                                    if _3150:
                                        return _3150
                                    return cd[4]
                                if not mem[_3502]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3502]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2151 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2354 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2151 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2151 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2151 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2151 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2151 + 128]
                                    mem[mem[64] + 164] = mem[_2151 + 160]
                                    mem[mem[64] + 196] = mem[_2354 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2354 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2354 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2354 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2354 + 128]
                                    mem[mem[64] + 356] = mem[_2354 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3067 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3067] == bool(mem[_3067])
                                    _3164 = mem[_3067 + 32]
                                    require mem[_3067 + 32] == mem[_3067 + 32]
                                    if not mem[_3067]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3337 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3337))
                                    staticcall address(_3337).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3542 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3542] == mem[_3542]
                                    if _3164 < mem[_3542]:
                                        if _3164:
                                            return _3164
                                        return cd[4]
                                    if not mem[_3542]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3542]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2217 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2439 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2217 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2217 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2217 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2217 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2217 + 128]
                                    mem[mem[64] + 164] = mem[_2217 + 160]
                                    mem[mem[64] + 196] = mem[_2439 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2439 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2439 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2439 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2439 + 128]
                                    mem[mem[64] + 356] = mem[_2439 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3112 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3112] == bool(mem[_3112])
                                    _3181 = mem[_3112 + 32]
                                    require mem[_3112 + 32] == mem[_3112 + 32]
                                    if not mem[_3112]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3412 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3412))
                                    staticcall address(_3412).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3592 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3592] == mem[_3592]
                                    if _3181 < mem[_3592]:
                                        if _3181:
                                            return _3181
                                        return cd[4]
                                    if not mem[_3592]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3592]
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                                return cd[4]
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2129 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2322 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2129 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2129 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2129 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2129 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2129 + 128]
                                mem[mem[64] + 164] = mem[_2129 + 160]
                                mem[mem[64] + 196] = mem[_2322 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2322 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2322 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2322 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2322 + 128]
                                mem[mem[64] + 356] = mem[_2322 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3050 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3050] == bool(mem[_3050])
                                _3157 = mem[_3050 + 32]
                                require mem[_3050 + 32] == mem[_3050 + 32]
                                if not mem[_3050]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3304 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3304))
                                staticcall address(_3304).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3521 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3521] == mem[_3521]
                                if _3157 < mem[_3521]:
                                    if _3157:
                                        return _3157
                                    return cd[4]
                                if not mem[_3521]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3521]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2169 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2384 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2169 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2169 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2169 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2169 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2169 + 128]
                                    mem[mem[64] + 164] = mem[_2169 + 160]
                                    mem[mem[64] + 196] = mem[_2384 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2384 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2384 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2384 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2384 + 128]
                                    mem[mem[64] + 356] = mem[_2384 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3082 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3082] == bool(mem[_3082])
                                    _3169 = mem[_3082 + 32]
                                    require mem[_3082 + 32] == mem[_3082 + 32]
                                    if not mem[_3082]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3362 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3362))
                                    staticcall address(_3362).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3560] == mem[_3560]
                                    if _3169 < mem[_3560]:
                                        if _3169:
                                            return _3169
                                        return cd[4]
                                    if not mem[_3560]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3560]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2241 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2454 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2241 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2241 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2241 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2241 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2241 + 128]
                                    mem[mem[64] + 164] = mem[_2241 + 160]
                                    mem[mem[64] + 196] = mem[_2454 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2454 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2454 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2454 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2454 + 128]
                                    mem[mem[64] + 356] = mem[_2454 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3120 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3120] == bool(mem[_3120])
                                    _3191 = mem[_3120 + 32]
                                    require mem[_3120 + 32] == mem[_3120 + 32]
                                    if not mem[_3120]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3430 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3430))
                                    staticcall address(_3430).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3600 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3600] == mem[_3600]
                                    if _3191 < mem[_3600]:
                                        if _3191:
                                            return _3191
                                        return cd[4]
                                    if not mem[_3600]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3600]
            else:
                if mem[mem[128] + 160] != 14:
                    return cd[4]
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2079 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2265 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2079 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2079 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2079 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2079 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2079 + 128]
                        mem[mem[64] + 164] = mem[_2079 + 160]
                        mem[mem[64] + 196] = mem[_2265 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2265 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2265 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2265 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2265 + 128]
                        mem[mem[64] + 356] = mem[_2265 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3020 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3020] == bool(mem[_3020])
                        _3141 = mem[_3020 + 32]
                        require mem[_3020 + 32] == mem[_3020 + 32]
                        if not mem[_3020]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3234 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3234))
                        staticcall address(_3234).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3480 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3480] == mem[_3480]
                        if _3141 < mem[_3480]:
                            if _3141:
                                return _3141
                            return cd[4]
                        if not mem[_3480]:
                            return cd[4]
                        mem[mem[64]] = mem[_3480]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2126 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2319 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2126 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2126 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2126 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2126 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2126 + 128]
                            mem[mem[64] + 164] = mem[_2126 + 160]
                            mem[mem[64] + 196] = mem[_2319 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2319 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2319 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2319 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2319 + 128]
                            mem[mem[64] + 356] = mem[_2319 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3048 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3048] == bool(mem[_3048])
                            _3156 = mem[_3048 + 32]
                            require mem[_3048 + 32] == mem[_3048 + 32]
                            if not mem[_3048]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3301 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3301))
                            staticcall address(_3301).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3518 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3518] == mem[_3518]
                            if _3156 < mem[_3518]:
                                if _3156:
                                    return _3156
                                return cd[4]
                            if not mem[_3518]:
                                return cd[4]
                            mem[mem[64]] = mem[_3518]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2190 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2412 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2190 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2190 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2190 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2190 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2190 + 128]
                            mem[mem[64] + 164] = mem[_2190 + 160]
                            mem[mem[64] + 196] = mem[_2412 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2412 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2412 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2412 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2412 + 128]
                            mem[mem[64] + 356] = mem[_2412 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3097 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3097] == bool(mem[_3097])
                            _3174 = mem[_3097 + 32]
                            require mem[_3097 + 32] == mem[_3097 + 32]
                            if not mem[_3097]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3386 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3386))
                            staticcall address(_3386).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3577 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3577] == mem[_3577]
                            if _3174 < mem[_3577]:
                                if _3174:
                                    return _3174
                                return cd[4]
                            if not mem[_3577]:
                                return cd[4]
                            mem[mem[64]] = mem[_3577]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2103 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2290 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2103 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2103 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2103 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2103 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2103 + 128]
                            mem[mem[64] + 164] = mem[_2103 + 160]
                            mem[mem[64] + 196] = mem[_2290 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2290 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2290 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2290 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2290 + 128]
                            mem[mem[64] + 356] = mem[_2290 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3034 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3034] == bool(mem[_3034])
                            _3149 = mem[_3034 + 32]
                            require mem[_3034 + 32] == mem[_3034 + 32]
                            if not mem[_3034]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3264 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3264))
                            staticcall address(_3264).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3499 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3499] == mem[_3499]
                            if _3149 < mem[_3499]:
                                if _3149:
                                    return _3149
                                return cd[4]
                            if not mem[_3499]:
                                return cd[4]
                            mem[mem[64]] = mem[_3499]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2148 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2349 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2148 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2148 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2148 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2148 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2148 + 128]
                                mem[mem[64] + 164] = mem[_2148 + 160]
                                mem[mem[64] + 196] = mem[_2349 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2349 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2349 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2349 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2349 + 128]
                                mem[mem[64] + 356] = mem[_2349 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3064 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3064] == bool(mem[_3064])
                                _3163 = mem[_3064 + 32]
                                require mem[_3064 + 32] == mem[_3064 + 32]
                                if not mem[_3064]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3332 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3332))
                                staticcall address(_3332).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3538 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3538] == mem[_3538]
                                if _3163 < mem[_3538]:
                                    if _3163:
                                        return _3163
                                    return cd[4]
                                if not mem[_3538]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3538]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2212 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2434 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2212 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2212 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2212 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2212 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2212 + 128]
                                mem[mem[64] + 164] = mem[_2212 + 160]
                                mem[mem[64] + 196] = mem[_2434 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2434 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2434 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2434 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2434 + 128]
                                mem[mem[64] + 356] = mem[_2434 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3110 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3110] == bool(mem[_3110])
                                _3180 = mem[_3110 + 32]
                                require mem[_3110 + 32] == mem[_3110 + 32]
                                if not mem[_3110]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3407 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3407))
                                staticcall address(_3407).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3590 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3590] == mem[_3590]
                                if _3180 < mem[_3590]:
                                    if _3180:
                                        return _3180
                                    return cd[4]
                                if not mem[_3590]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3590]
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2123 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2316 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2123 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2123 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2123 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2123 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2123 + 128]
                                mem[mem[64] + 164] = mem[_2123 + 160]
                                mem[mem[64] + 196] = mem[_2316 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2316 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2316 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2316 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2316 + 128]
                                mem[mem[64] + 356] = mem[_2316 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3047 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3047] == bool(mem[_3047])
                                _3155 = mem[_3047 + 32]
                                require mem[_3047 + 32] == mem[_3047 + 32]
                                if not mem[_3047]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3296 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3296))
                                staticcall address(_3296).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3517 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3517] == mem[_3517]
                                if _3155 < mem[_3517]:
                                    if _3155:
                                        return _3155
                                    return cd[4]
                                if not mem[_3517]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3517]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2166 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2377 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2166 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2166 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2166 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2166 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2166 + 128]
                                    mem[mem[64] + 164] = mem[_2166 + 160]
                                    mem[mem[64] + 196] = mem[_2377 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2377 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2377 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2377 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2377 + 128]
                                    mem[mem[64] + 356] = mem[_2377 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3079 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3079] == bool(mem[_3079])
                                    _3168 = mem[_3079 + 32]
                                    require mem[_3079 + 32] == mem[_3079 + 32]
                                    if not mem[_3079]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3357 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3357))
                                    staticcall address(_3357).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3556 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3556] == mem[_3556]
                                    if _3168 < mem[_3556]:
                                        if _3168:
                                            return _3168
                                        return cd[4]
                                    if not mem[_3556]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3556]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2236 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2451 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2236 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2236 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2236 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2236 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2236 + 128]
                                    mem[mem[64] + 164] = mem[_2236 + 160]
                                    mem[mem[64] + 196] = mem[_2451 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2451 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2451 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2451 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2451 + 128]
                                    mem[mem[64] + 356] = mem[_2451 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3118 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3118] == bool(mem[_3118])
                                    _3190 = mem[_3118 + 32]
                                    require mem[_3118 + 32] == mem[_3118 + 32]
                                    if not mem[_3118]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3426 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3426))
                                    staticcall address(_3426).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3598 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3598] == mem[_3598]
                                    if _3190 < mem[_3598]:
                                        if _3190:
                                            return _3190
                                        return cd[4]
                                    if not mem[_3598]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3598]
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                                return cd[4]
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2145 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2346 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2145 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2145 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2145 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2145 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2145 + 128]
                                mem[mem[64] + 164] = mem[_2145 + 160]
                                mem[mem[64] + 196] = mem[_2346 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2346 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2346 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2346 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2346 + 128]
                                mem[mem[64] + 356] = mem[_2346 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3063 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3063] == bool(mem[_3063])
                                _3162 = mem[_3063 + 32]
                                require mem[_3063 + 32] == mem[_3063 + 32]
                                if not mem[_3063]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3327 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3327))
                                staticcall address(_3327).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3537 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3537] == mem[_3537]
                                if _3162 < mem[_3537]:
                                    if _3162:
                                        return _3162
                                    return cd[4]
                                if not mem[_3537]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3537]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2186 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2405 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2186 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2186 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2186 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2186 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2186 + 128]
                                    mem[mem[64] + 164] = mem[_2186 + 160]
                                    mem[mem[64] + 196] = mem[_2405 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2405 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2405 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2405 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2405 + 128]
                                    mem[mem[64] + 356] = mem[_2405 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3093 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3093] == bool(mem[_3093])
                                    _3173 = mem[_3093 + 32]
                                    require mem[_3093 + 32] == mem[_3093 + 32]
                                    if not mem[_3093]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3381 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3381))
                                    staticcall address(_3381).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3572] == mem[_3572]
                                    if _3173 < mem[_3572]:
                                        if _3173:
                                            return _3173
                                        return cd[4]
                                    if not mem[_3572]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3572]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2261 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2463 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2261 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2261 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2261 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2261 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2261 + 128]
                                    mem[mem[64] + 164] = mem[_2261 + 160]
                                    mem[mem[64] + 196] = mem[_2463 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2463 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2463 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2463 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2463 + 128]
                                    mem[mem[64] + 356] = mem[_2463 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3126 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3126] == bool(mem[_3126])
                                    _3206 = mem[_3126 + 32]
                                    require mem[_3126 + 32] == mem[_3126 + 32]
                                    if not mem[_3126]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3443 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3443))
                                    staticcall address(_3443).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3605 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3605] == mem[_3605]
                                    if _3206 < mem[_3605]:
                                        if _3206:
                                            return _3206
                                        return cd[4]
                                    if not mem[_3605]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3605]
    return memory
      from mem[64]
       len 32
}

function sub_407045a8(?) {
    require calldata.size - 4 >= 64
    require cd[4] == cd[4]
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 36).length) + 97 > test266151307() or floor32(('cd', 36).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 36).length) + 97
    mem[96] = ('cd', 36).length
    require cd[36] + (192 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require calldata.size - s >= 192
        _4096 = mem[64]
        if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 192
        require cd[s] == address(cd[s])
        mem[_4096] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_4096 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == address(cd[(s + 64)])
        mem[_4096 + 64] = cd[(s + 64)]
        require cd[(s + 96)] == address(cd[(s + 96)])
        mem[_4096 + 96] = cd[(s + 96)]
        require cd[(s + 128)] == cd[(s + 128)]
        mem[_4096 + 128] = cd[(s + 128)]
        require cd[(s + 160)] == cd[(s + 160)]
        mem[_4096 + 160] = cd[(s + 160)]
        mem[t] = _4096
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    _4095 = mem[96]
    if mem[96] > -2:
        revert with 'NH{q', 17
    if mem[96] + 1 > test266151307():
        revert with 'NH{q', 65
    _4097 = mem[64]
    mem[mem[64]] = mem[96] + 1
    mem[64] = mem[64] + (32 * _4095 + 1) + 32
    if not _4095 + 1:
        if 0 >= mem[_4097]:
            revert with 'NH{q', 50
        mem[_4097 + 32] = cd[4]
        _8188 = mem[96]
        idx = 0
        while idx < _8188:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            _8193 = mem[(32 * idx) + 128]
            if mem[mem[(32 * idx) + 128] + 160] == 1:
                _8200 = mem[mem[(32 * idx) + 128]]
                _8201 = mem[mem[(32 * idx) + 128] + 32]
                if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                    _8206 = mem[mem[(32 * idx) + 128] + 64]
                    _8210 = mem[64]
                    _8211 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8211 + 32] = mem[_8211 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8247 = mem[_8211]
                    s = 0
                    while s < _8247:
                        mem[_8210 + s + 36] = mem[_8211 + s + 32]
                        _8188 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8247) <= _8247:
                        staticcall address(_8206).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8210 + _8247 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8200):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12310 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12310] = return_data.size
                            mem[_12310 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8200):
                                if mem[_12310 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12310 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12310 + 64]:
                                        if False and mem[_12310 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12310 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12310 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12310 + 32] and 10000 > -1 / mem[_12310 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12310 + 32] / 10000 != mem[_12310 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12310 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12310 + 32] < 10000 * mem[_12310 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12310 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12310 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12310 + 64]:
                                        if mem[_12310 + 32] and 10000 > -1 / mem[_12310 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12310 + 32] / 10000 != mem[_12310 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12310 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12310 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12310 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12310 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12310 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12310 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12310 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 64]) / mem[_12310 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12310 + 32] and 10000 > -1 / mem[_12310 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12310 + 32] / 10000 != mem[_12310 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12310 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12310 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12310 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12310 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 64]) / (10000 * mem[_12310 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12310 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12310 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12310 + 32]:
                                        if False and mem[_12310 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12310 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12310 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12310 + 64] and 10000 > -1 / mem[_12310 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12310 + 64] / 10000 != mem[_12310 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12310 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12310 + 64] < 10000 * mem[_12310 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12310 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12310 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12310 + 32]:
                                        if mem[_12310 + 64] and 10000 > -1 / mem[_12310 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12310 + 64] / 10000 != mem[_12310 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12310 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12310 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12310 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12310 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12310 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12310 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12310 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 32]) / mem[_12310 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12310 + 64] and 10000 > -1 / mem[_12310 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12310 + 64] / 10000 != mem[_12310 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12310 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12310 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12310 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12310 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12310 + 32]) / (10000 * mem[_12310 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        mem[_8210 + _8247 + 36] = 0
                        staticcall address(_8206).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8210 + _8247 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8200):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12338 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12338] = return_data.size
                            mem[_12338 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8200):
                                if mem[_12338 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12338 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12338 + 64]:
                                        if False and mem[_12338 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12338 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12338 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12338 + 32] and 10000 > -1 / mem[_12338 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12338 + 32] / 10000 != mem[_12338 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12338 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12338 + 32] < 10000 * mem[_12338 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12338 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12338 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12338 + 64]:
                                        if mem[_12338 + 32] and 10000 > -1 / mem[_12338 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12338 + 32] / 10000 != mem[_12338 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12338 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12338 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12338 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12338 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12338 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12338 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12338 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 64]) / mem[_12338 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12338 + 32] and 10000 > -1 / mem[_12338 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12338 + 32] / 10000 != mem[_12338 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12338 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12338 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12338 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12338 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 64]) / (10000 * mem[_12338 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12338 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12338 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12338 + 32]:
                                        if False and mem[_12338 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12338 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12338 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12338 + 64] and 10000 > -1 / mem[_12338 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12338 + 64] / 10000 != mem[_12338 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12338 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12338 + 64] < 10000 * mem[_12338 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12338 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12338 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12338 + 32]:
                                        if mem[_12338 + 64] and 10000 > -1 / mem[_12338 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12338 + 64] / 10000 != mem[_12338 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12338 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12338 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12338 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12338 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12338 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12338 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12338 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 32]) / mem[_12338 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12338 + 64] and 10000 > -1 / mem[_12338 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12338 + 64] / 10000 != mem[_12338 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12338 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12338 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12338 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12338 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12338 + 32]) / (10000 * mem[_12338 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                else:
                    _8207 = mem[mem[(32 * idx) + 128] + 64]
                    _8214 = mem[64]
                    _8215 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8215 + 32] = mem[_8215 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8248 = mem[_8215]
                    s = 0
                    while s < _8248:
                        mem[_8214 + s + 36] = mem[_8215 + s + 32]
                        _8188 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8248) <= _8248:
                        staticcall address(_8207).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8214 + _8248 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8201):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12312 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12312] = return_data.size
                            mem[_12312 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8201):
                                if mem[_12312 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12312 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12312 + 64]:
                                        if False and mem[_12312 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12312 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12312 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12312 + 32] and 10000 > -1 / mem[_12312 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12312 + 32] / 10000 != mem[_12312 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12312 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12312 + 32] < 10000 * mem[_12312 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12312 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12312 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12312 + 64]:
                                        if mem[_12312 + 32] and 10000 > -1 / mem[_12312 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12312 + 32] / 10000 != mem[_12312 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12312 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12312 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12312 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12312 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12312 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12312 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12312 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 64]) / mem[_12312 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12312 + 32] and 10000 > -1 / mem[_12312 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12312 + 32] / 10000 != mem[_12312 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12312 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12312 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12312 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12312 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 64]) / (10000 * mem[_12312 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12312 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12312 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12312 + 32]:
                                        if False and mem[_12312 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12312 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12312 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12312 + 64] and 10000 > -1 / mem[_12312 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12312 + 64] / 10000 != mem[_12312 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12312 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12312 + 64] < 10000 * mem[_12312 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12312 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12312 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12312 + 32]:
                                        if mem[_12312 + 64] and 10000 > -1 / mem[_12312 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12312 + 64] / 10000 != mem[_12312 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12312 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12312 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12312 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12312 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12312 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12312 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12312 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 32]) / mem[_12312 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12312 + 64] and 10000 > -1 / mem[_12312 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12312 + 64] / 10000 != mem[_12312 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12312 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12312 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12312 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12312 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12312 + 32]) / (10000 * mem[_12312 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        mem[_8214 + _8248 + 36] = 0
                        staticcall address(_8207).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8214 + _8248 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8201):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12343 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12343] = return_data.size
                            mem[_12343 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8193 + 12 len 20] == address(_8201):
                                if mem[_12343 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12343 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12343 + 64]:
                                        if False and mem[_12343 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12343 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12343 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12343 + 32] and 10000 > -1 / mem[_12343 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12343 + 32] / 10000 != mem[_12343 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12343 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12343 + 32] < 10000 * mem[_12343 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12343 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12343 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12343 + 64]:
                                        if mem[_12343 + 32] and 10000 > -1 / mem[_12343 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12343 + 32] / 10000 != mem[_12343 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12343 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12343 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12343 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12343 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12343 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12343 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12343 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 64]) / mem[_12343 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12343 + 32] and 10000 > -1 / mem[_12343 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12343 + 32] / 10000 != mem[_12343 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12343 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12343 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12343 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12343 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 64]) / (10000 * mem[_12343 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12343 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12343 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8193 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8193 + 128] + 10000:
                                    if mem[_12343 + 32]:
                                        if False and mem[_12343 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12343 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12343 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12343 + 64] and 10000 > -1 / mem[_12343 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12343 + 64] / 10000 != mem[_12343 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12343 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12343 + 64] < 10000 * mem[_12343 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12343 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12343 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12343 + 32]:
                                        if mem[_12343 + 64] and 10000 > -1 / mem[_12343 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12343 + 64] / 10000 != mem[_12343 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12343 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12343 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12343 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12343 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12343 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12343 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12343 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 32]) / mem[_12343 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12343 + 64] and 10000 > -1 / mem[_12343 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12343 + 64] / 10000 != mem[_12343 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12343 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12343 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12343 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12343 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12343 + 32]) / (10000 * mem[_12343 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
            else:
                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xd8aa70f7990dab4a383a0d8a57df7a372916575d:
                    _8218 = mem[mem[(32 * idx) + 128]]
                    _8219 = mem[mem[(32 * idx) + 128] + 32]
                    if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                        _8260 = mem[mem[(32 * idx) + 128] + 64]
                        _8274 = mem[64]
                        _8275 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8275 + 32] = mem[_8275 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8370 = mem[_8275]
                        s = 0
                        while s < _8370:
                            mem[_8274 + s + 36] = mem[_8275 + s + 32]
                            _8188 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8370) <= _8370:
                            staticcall address(_8260).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8274 + _8370 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8218):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12318 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12318] = return_data.size
                                mem[_12318 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8218):
                                    if mem[_12318 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12318 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12318 + 64]:
                                            if False and mem[_12318 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12318 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12318 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12318 + 32] and 10000 > -1 / mem[_12318 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12318 + 32] / 10000 != mem[_12318 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12318 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12318 + 32] < 10000 * mem[_12318 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12318 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12318 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12318 + 64]:
                                            if mem[_12318 + 32] and 10000 > -1 / mem[_12318 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12318 + 32] / 10000 != mem[_12318 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12318 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12318 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12318 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12318 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12318 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12318 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12318 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 64]) / mem[_12318 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12318 + 32] and 10000 > -1 / mem[_12318 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12318 + 32] / 10000 != mem[_12318 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12318 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12318 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12318 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12318 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 64]) / (10000 * mem[_12318 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12318 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12318 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12318 + 32]:
                                            if False and mem[_12318 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12318 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12318 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12318 + 64] and 10000 > -1 / mem[_12318 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12318 + 64] / 10000 != mem[_12318 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12318 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12318 + 64] < 10000 * mem[_12318 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12318 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12318 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12318 + 32]:
                                            if mem[_12318 + 64] and 10000 > -1 / mem[_12318 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12318 + 64] / 10000 != mem[_12318 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12318 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12318 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12318 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12318 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12318 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12318 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12318 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 32]) / mem[_12318 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12318 + 64] and 10000 > -1 / mem[_12318 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12318 + 64] / 10000 != mem[_12318 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12318 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12318 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12318 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12318 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12318 + 32]) / (10000 * mem[_12318 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            mem[_8274 + _8370 + 36] = 0
                            staticcall address(_8260).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8274 + _8370 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8218):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12359 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12359] = return_data.size
                                mem[_12359 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8218):
                                    if mem[_12359 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12359 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12359 + 64]:
                                            if False and mem[_12359 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12359 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12359 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12359 + 32] and 10000 > -1 / mem[_12359 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12359 + 32] / 10000 != mem[_12359 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12359 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12359 + 32] < 10000 * mem[_12359 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12359 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12359 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12359 + 64]:
                                            if mem[_12359 + 32] and 10000 > -1 / mem[_12359 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12359 + 32] / 10000 != mem[_12359 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12359 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12359 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12359 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12359 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12359 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12359 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12359 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 64]) / mem[_12359 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12359 + 32] and 10000 > -1 / mem[_12359 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12359 + 32] / 10000 != mem[_12359 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12359 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12359 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12359 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12359 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 64]) / (10000 * mem[_12359 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12359 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12359 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12359 + 32]:
                                            if False and mem[_12359 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12359 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12359 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12359 + 64] and 10000 > -1 / mem[_12359 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12359 + 64] / 10000 != mem[_12359 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12359 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12359 + 64] < 10000 * mem[_12359 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12359 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12359 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12359 + 32]:
                                            if mem[_12359 + 64] and 10000 > -1 / mem[_12359 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12359 + 64] / 10000 != mem[_12359 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12359 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12359 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12359 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12359 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12359 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12359 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12359 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 32]) / mem[_12359 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12359 + 64] and 10000 > -1 / mem[_12359 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12359 + 64] / 10000 != mem[_12359 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12359 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12359 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12359 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12359 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12359 + 32]) / (10000 * mem[_12359 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        _8261 = mem[mem[(32 * idx) + 128] + 64]
                        _8278 = mem[64]
                        _8279 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8279 + 32] = mem[_8279 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8371 = mem[_8279]
                        s = 0
                        while s < _8371:
                            mem[_8278 + s + 36] = mem[_8279 + s + 32]
                            _8188 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8371) <= _8371:
                            staticcall address(_8261).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8278 + _8371 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8219):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12320 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12320] = return_data.size
                                mem[_12320 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8219):
                                    if mem[_12320 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12320 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12320 + 64]:
                                            if False and mem[_12320 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12320 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12320 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12320 + 32] and 10000 > -1 / mem[_12320 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12320 + 32] / 10000 != mem[_12320 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12320 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12320 + 32] < 10000 * mem[_12320 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12320 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12320 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12320 + 64]:
                                            if mem[_12320 + 32] and 10000 > -1 / mem[_12320 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12320 + 32] / 10000 != mem[_12320 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12320 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12320 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12320 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12320 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12320 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12320 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12320 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 64]) / mem[_12320 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12320 + 32] and 10000 > -1 / mem[_12320 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12320 + 32] / 10000 != mem[_12320 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12320 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12320 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12320 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12320 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 64]) / (10000 * mem[_12320 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12320 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12320 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12320 + 32]:
                                            if False and mem[_12320 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12320 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12320 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12320 + 64] and 10000 > -1 / mem[_12320 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12320 + 64] / 10000 != mem[_12320 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12320 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12320 + 64] < 10000 * mem[_12320 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12320 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12320 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12320 + 32]:
                                            if mem[_12320 + 64] and 10000 > -1 / mem[_12320 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12320 + 64] / 10000 != mem[_12320 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12320 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12320 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12320 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12320 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12320 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12320 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12320 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 32]) / mem[_12320 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12320 + 64] and 10000 > -1 / mem[_12320 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12320 + 64] / 10000 != mem[_12320 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12320 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12320 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12320 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12320 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12320 + 32]) / (10000 * mem[_12320 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            mem[_8278 + _8371 + 36] = 0
                            staticcall address(_8261).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8278 + _8371 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8219):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12364 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12364] = return_data.size
                                mem[_12364 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8193 + 12 len 20] == address(_8219):
                                    if mem[_12364 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12364 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12364 + 64]:
                                            if False and mem[_12364 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12364 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12364 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12364 + 32] and 10000 > -1 / mem[_12364 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12364 + 32] / 10000 != mem[_12364 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12364 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12364 + 32] < 10000 * mem[_12364 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12364 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12364 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12364 + 64]:
                                            if mem[_12364 + 32] and 10000 > -1 / mem[_12364 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12364 + 32] / 10000 != mem[_12364 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12364 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12364 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12364 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12364 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12364 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12364 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12364 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 64]) / mem[_12364 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12364 + 32] and 10000 > -1 / mem[_12364 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12364 + 32] / 10000 != mem[_12364 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12364 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12364 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12364 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12364 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 64]) / (10000 * mem[_12364 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12364 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12364 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8193 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8193 + 128] + 10000:
                                        if mem[_12364 + 32]:
                                            if False and mem[_12364 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12364 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12364 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12364 + 64] and 10000 > -1 / mem[_12364 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12364 + 64] / 10000 != mem[_12364 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12364 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12364 + 64] < 10000 * mem[_12364 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12364 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12364 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12364 + 32]:
                                            if mem[_12364 + 64] and 10000 > -1 / mem[_12364 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12364 + 64] / 10000 != mem[_12364 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12364 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12364 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12364 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12364 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12364 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12364 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12364 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 32]) / mem[_12364 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12364 + 64] and 10000 > -1 / mem[_12364 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12364 + 64] / 10000 != mem[_12364 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12364 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12364 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12364 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12364 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12364 + 32]) / (10000 * mem[_12364 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                else:
                    if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xb9a9bb6cc39387548baa7185fbff51d47eef8771:
                        _8231 = mem[mem[(32 * idx) + 128]]
                        _8232 = mem[mem[(32 * idx) + 128] + 32]
                        if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                            _8272 = mem[mem[(32 * idx) + 128] + 64]
                            _8306 = mem[64]
                            _8307 = mem[64]
                            mem[mem[64]] = 4
                            mem[64] = mem[64] + 36
                            mem[_8307 + 32] = mem[_8307 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                            _8389 = mem[_8307]
                            s = 0
                            while s < _8389:
                                mem[_8306 + s + 36] = mem[_8307 + s + 32]
                                _8188 = mem[96]
                                s = s + 32
                                continue 
                            if ceil32(_8389) <= _8389:
                                staticcall address(_8272).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8306 + _8389 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8231):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    _12314 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12314] = return_data.size
                                    mem[_12314 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8231):
                                        if mem[_12314 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12314 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12314 + 64]:
                                                if False and mem[_12314 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12314 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12314 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12314 + 32] and 10000 > -1 / mem[_12314 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12314 + 32] / 10000 != mem[_12314 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12314 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12314 + 32] < 10000 * mem[_12314 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12314 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12314 + 32]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12314 + 64]:
                                                if mem[_12314 + 32] and 10000 > -1 / mem[_12314 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12314 + 32] / 10000 != mem[_12314 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12314 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12314 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12314 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12314 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12314 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12314 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12314 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 64]) / mem[_12314 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12314 + 32] and 10000 > -1 / mem[_12314 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12314 + 32] / 10000 != mem[_12314 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12314 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12314 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12314 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12314 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 64]) / (10000 * mem[_12314 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[_12314 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12314 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12314 + 32]:
                                                if False and mem[_12314 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12314 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12314 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12314 + 64] and 10000 > -1 / mem[_12314 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12314 + 64] / 10000 != mem[_12314 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12314 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12314 + 64] < 10000 * mem[_12314 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12314 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12314 + 64]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12314 + 32]:
                                                if mem[_12314 + 64] and 10000 > -1 / mem[_12314 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12314 + 64] / 10000 != mem[_12314 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12314 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12314 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12314 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12314 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12314 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12314 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12314 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 32]) / mem[_12314 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12314 + 64] and 10000 > -1 / mem[_12314 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12314 + 64] / 10000 != mem[_12314 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12314 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12314 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12314 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12314 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12314 + 32]) / (10000 * mem[_12314 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                mem[_8306 + _8389 + 36] = 0
                                staticcall address(_8272).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8306 + _8389 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8231):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    _12349 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12349] = return_data.size
                                    mem[_12349 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8231):
                                        if mem[_12349 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12349 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12349 + 64]:
                                                if False and mem[_12349 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12349 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12349 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12349 + 32] and 10000 > -1 / mem[_12349 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12349 + 32] / 10000 != mem[_12349 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12349 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12349 + 32] < 10000 * mem[_12349 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12349 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12349 + 32]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12349 + 64]:
                                                if mem[_12349 + 32] and 10000 > -1 / mem[_12349 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12349 + 32] / 10000 != mem[_12349 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12349 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12349 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12349 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12349 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12349 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12349 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12349 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 64]) / mem[_12349 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12349 + 32] and 10000 > -1 / mem[_12349 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12349 + 32] / 10000 != mem[_12349 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12349 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12349 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12349 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12349 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 64]) / (10000 * mem[_12349 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[_12349 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12349 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12349 + 32]:
                                                if False and mem[_12349 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12349 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12349 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12349 + 64] and 10000 > -1 / mem[_12349 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12349 + 64] / 10000 != mem[_12349 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12349 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12349 + 64] < 10000 * mem[_12349 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12349 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12349 + 64]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12349 + 32]:
                                                if mem[_12349 + 64] and 10000 > -1 / mem[_12349 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12349 + 64] / 10000 != mem[_12349 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12349 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12349 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12349 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12349 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12349 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12349 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12349 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 32]) / mem[_12349 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12349 + 64] and 10000 > -1 / mem[_12349 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12349 + 64] / 10000 != mem[_12349 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12349 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12349 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12349 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12349 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12349 + 32]) / (10000 * mem[_12349 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _8273 = mem[mem[(32 * idx) + 128] + 64]
                            _8310 = mem[64]
                            _8311 = mem[64]
                            mem[mem[64]] = 4
                            mem[64] = mem[64] + 36
                            mem[_8311 + 32] = mem[_8311 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                            _8390 = mem[_8311]
                            s = 0
                            while s < _8390:
                                mem[_8310 + s + 36] = mem[_8311 + s + 32]
                                _8188 = mem[96]
                                s = s + 32
                                continue 
                            if ceil32(_8390) <= _8390:
                                staticcall address(_8273).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8310 + _8390 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8232):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    _12316 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12316] = return_data.size
                                    mem[_12316 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8232):
                                        if mem[_12316 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12316 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12316 + 64]:
                                                if False and mem[_12316 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12316 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12316 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12316 + 32] and 10000 > -1 / mem[_12316 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12316 + 32] / 10000 != mem[_12316 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12316 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12316 + 32] < 10000 * mem[_12316 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12316 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12316 + 32]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12316 + 64]:
                                                if mem[_12316 + 32] and 10000 > -1 / mem[_12316 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12316 + 32] / 10000 != mem[_12316 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12316 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12316 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12316 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12316 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12316 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12316 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12316 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 64]) / mem[_12316 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12316 + 32] and 10000 > -1 / mem[_12316 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12316 + 32] / 10000 != mem[_12316 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12316 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12316 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12316 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12316 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 64]) / (10000 * mem[_12316 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[_12316 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12316 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12316 + 32]:
                                                if False and mem[_12316 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12316 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12316 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12316 + 64] and 10000 > -1 / mem[_12316 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12316 + 64] / 10000 != mem[_12316 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12316 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12316 + 64] < 10000 * mem[_12316 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12316 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12316 + 64]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12316 + 32]:
                                                if mem[_12316 + 64] and 10000 > -1 / mem[_12316 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12316 + 64] / 10000 != mem[_12316 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12316 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12316 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12316 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12316 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12316 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12316 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12316 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 32]) / mem[_12316 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12316 + 64] and 10000 > -1 / mem[_12316 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12316 + 64] / 10000 != mem[_12316 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12316 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12316 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12316 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12316 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12316 + 32]) / (10000 * mem[_12316 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                mem[_8310 + _8390 + 36] = 0
                                staticcall address(_8273).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8310 + _8390 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8232):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    _12354 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12354] = return_data.size
                                    mem[_12354 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4097 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8193 + 12 len 20] == address(_8232):
                                        if mem[_12354 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12354 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12354 + 64]:
                                                if False and mem[_12354 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12354 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12354 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12354 + 32] and 10000 > -1 / mem[_12354 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12354 + 32] / 10000 != mem[_12354 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12354 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12354 + 32] < 10000 * mem[_12354 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12354 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12354 + 32]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12354 + 64]:
                                                if mem[_12354 + 32] and 10000 > -1 / mem[_12354 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12354 + 32] / 10000 != mem[_12354 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12354 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12354 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12354 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12354 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12354 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12354 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12354 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 64]) / mem[_12354 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12354 + 32] and 10000 > -1 / mem[_12354 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12354 + 32] / 10000 != mem[_12354 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12354 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12354 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12354 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12354 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 64]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 64]) / (10000 * mem[_12354 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if mem[_12354 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12354 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8193 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8193 + 128] + 10000:
                                            if mem[_12354 + 32]:
                                                if False and mem[_12354 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12354 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12354 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12354 + 64] and 10000 > -1 / mem[_12354 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12354 + 64] / 10000 != mem[_12354 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12354 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12354 + 64] < 10000 * mem[_12354 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12354 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12354 + 64]
                                        else:
                                            if mem[(32 * idx) + _4097 + 32] and -mem[_8193 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8193 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8193 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12354 + 32]:
                                                if mem[_12354 + 64] and 10000 > -1 / mem[_12354 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12354 + 64] / 10000 != mem[_12354 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12354 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12354 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12354 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12354 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12354 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12354 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12354 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 32]) / mem[_12354 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12354 + 64] and 10000 > -1 / mem[_12354 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12354 + 64] / 10000 != mem[_12354 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12354 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12354 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12354 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12354 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12354 + 32]) / (10000 * mem[_12354 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8193 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        if mem[mem[(32 * idx) + 128] + 160] == 3:
                            _8237 = mem[mem[(32 * idx) + 128] + 64]
                            _8238 = mem[mem[(32 * idx) + 128]]
                            require ext_code.size(mem[mem[(32 * idx) + 128] + 76 len 20])
                            staticcall mem[mem[(32 * idx) + 128] + 76 len 20]._BASE_TOKEN_() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8259 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8259] == mem[_8259 + 12 len 20]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[_8259 + 12 len 20] != address(_8238):
                                _8513 = mem[(32 * idx) + _4097 + 32]
                                mem[mem[64] + 36] = mem[(32 * idx) + _4097 + 32]
                                require ext_code.size(address(_8237))
                                staticcall address(_8237).querySellQuote(address arg1, uint256 arg2) with:
                                        gas gas_remaining wei
                                       args address(this.address), _8513
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9329 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_9329] == mem[_9329]
                                require mem[_9329 + 32] == mem[_9329 + 32]
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = mem[_9329]
                            else:
                                _8515 = mem[(32 * idx) + _4097 + 32]
                                mem[mem[64] + 36] = mem[(32 * idx) + _4097 + 32]
                                require ext_code.size(address(_8237))
                                staticcall address(_8237).querySellBase(address arg1, uint256 arg2) with:
                                        gas gas_remaining wei
                                       args address(this.address), _8515
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9330 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_9330] == mem[_9330]
                                require mem[_9330 + 32] == mem[_9330 + 32]
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = mem[_9330]
                        else:
                            if mem[mem[(32 * idx) + 128] + 160] == 5:
                                _8250 = mem[mem[(32 * idx) + 128] + 96]
                                _8258 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_8258 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_8258]:
                                    revert with 'NH{q', 50
                                mem[_8258 + 32] = mem[_8193 + 12 len 20]
                                if 1 >= mem[_8258]:
                                    revert with 'NH{q', 50
                                mem[_8258 + 64] = mem[_8193 + 44 len 20]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                _8387 = mem[(32 * idx) + _4097 + 32]
                                mem[_8258 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_8258 + 100] = _8387
                                mem[_8258 + 132] = 64
                                mem[_8258 + 164] = mem[_8258]
                                s = 0
                                t = _8258 + 32
                                u = _8258 + 196
                                while s < mem[_8258]:
                                    mem[u] = mem[t + 12 len 20]
                                    _8188 = mem[96]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(address(_8250))
                                staticcall address(_8250).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8258 + (32 * mem[_8258]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12298 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _12344 = mem[_12298]
                                require mem[_12298] <= test266151307()
                                require _12298 + mem[_12298] + 31 < _12298 + return_data.size
                                _12500 = mem[_12298 + mem[_12298]]
                                if mem[_12298 + mem[_12298]] > test266151307():
                                    revert with 'NH{q', 65
                                if _12298 + ceil32(return_data.size) + floor32(mem[_12298 + mem[_12298]]) + 1 > test266151307() or floor32(mem[_12298 + mem[_12298]]) + 1 < 0:
                                    revert with 'NH{q', 65
                                mem[64] = _12298 + ceil32(return_data.size) + floor32(mem[_12298 + mem[_12298]]) + 1
                                mem[_12298 + ceil32(return_data.size)] = _12500
                                require _12344 + (32 * _12500) + 32 <= return_data.size
                                s = 0
                                t = _12298 + _12344 + 32
                                u = _12298 + ceil32(return_data.size) + 32
                                while s < _12500:
                                    require mem[t] == mem[t]
                                    mem[u] = mem[t]
                                    _8188 = mem[96]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                if _12500 < 1:
                                    revert with 'NH{q', 17
                                if _12500 - 1 >= _12500:
                                    revert with 'NH{q', 50
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = mem[(32 * _12500 - 1) + _12298 + ceil32(return_data.size) + 32]
                            else:
                                if mem[mem[(32 * idx) + 128] + 160] == 7:
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    _8271 = mem[(32 * idx) + _4097 + 32]
                                    _8303 = mem[mem[(32 * idx) + 128] + 32]
                                    _8341 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                    mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                    mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                    _8343 = sha3(address(_8303), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                    if uint256(stor[_8341]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8303)]):
                                        revert with 0, 'BAD CURVE'
                                    _8385 = mem[mem[(32 * idx) + 128] + 96]
                                    mem[mem[64] + 4] = uint8(stor[_8341])
                                    mem[mem[64] + 36] = uint8(stor[_8343])
                                    mem[mem[64] + 68] = _8271
                                    require ext_code.size(address(_8385))
                                    staticcall address(_8385).calculateSwap(uint8 arg1, uint8 arg2, uint256 arg3) with:
                                            gas gas_remaining wei
                                           args uint8(stor[_8341]), uint8(stor[_8343]), _8271
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8913 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8913] == mem[_8913]
                                    if mem[_8913] < 1:
                                        revert with 'NH{q', 17
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_8913] - 1
                                else:
                                    if mem[mem[(32 * idx) + 128] + 160] != 8:
                                        if mem[mem[(32 * idx) + 128] + 160] != 13:
                                            require mem[mem[(32 * idx) + 128] + 160] == 14
                                            _8333 = mem[mem[(32 * idx) + 128] + 32]
                                            if idx >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            _8362 = mem[(32 * idx) + _4097 + 32]
                                            mem[mem[64] + 4] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                            mem[mem[64] + 36] = address(_8333)
                                            mem[mem[64] + 68] = _8362
                                            require ext_code.size(0x66357dcace80431aee0a7507e2e361b7e2402370)
                                            staticcall 0x66357dcace80431aee0a7507e2e361b7e2402370.quotePotentialSwap(address arg1, address arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8333), _8362
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9094 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9094] == mem[_9094]
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9094]
                                        else:
                                            _8297 = mem[mem[(32 * idx) + 128]]
                                            _8298 = mem[mem[(32 * idx) + 128] + 32]
                                            if idx >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            _8335 = mem[(32 * idx) + _4097 + 32]
                                            mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                            mem[mem[64] + 68] = address(_8298)
                                            mem[mem[64] + 100] = _8335
                                            require ext_code.size(0x9e372b445723e71117b59393aaba05ad3b54ad3f)
                                            staticcall 0x9e372b445723e71117b59393aaba05ad3b54ad3f.0xd7176ca9 with:
                                                    gas gas_remaining wei
                                                   args 0x9ab2de34a33fb459b538c43f251eb825645e8595, address(_8297), address(_8298), _8335
                                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9360 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 64
                                            require mem[_9360] == mem[_9360]
                                            require mem[_9360 + 32] == mem[_9360 + 32]
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9360]
                                    else:
                                        if idx >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        _8300 = mem[(32 * idx) + _4097 + 32]
                                        _8339 = mem[mem[(32 * idx) + 128] + 32]
                                        _8365 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                        mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                        mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                        _8367 = sha3(address(_8339), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                        if uint256(stor[_8365]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8339)]):
                                            revert with 0, 'BAD CURVE'
                                        _8400 = mem[mem[(32 * idx) + 128] + 96]
                                        if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
                                            if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                    mem[mem[64] + 68] = _8300
                                                    require ext_code.size(address(_8400))
                                                    staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9326 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9326] == mem[_9326]
                                                    if mem[_9326] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_9326] - 1
                                                else:
                                                    if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                        mem[mem[64] + 68] = _8300
                                                        require ext_code.size(address(_8400))
                                                        staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9361 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9361] == mem[_9361]
                                                        if mem[_9361] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9361] - 1
                                                    else:
                                                        if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                            mem[mem[64] + 68] = _8300
                                                            require ext_code.size(address(_8400))
                                                            staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9374 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_9374] == mem[_9374]
                                                            if mem[_9374] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9374] - 1
                                                        else:
                                                            if mem[mem[(32 * idx) + 128] + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                revert with 'NH{q', 17
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                            mem[mem[64] + 68] = _8300
                                                            require ext_code.size(address(_8400))
                                                            staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9393 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_9393] == mem[_9393]
                                                            if mem[_9393] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9393] - 1
                                            else:
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                mem[mem[64] + 68] = _8300
                                                require ext_code.size(address(_8400))
                                                staticcall address(_8400).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9095 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9095] == mem[_9095]
                                                if mem[_8193 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                    mem[mem[64] + 68] = _8300
                                                    require ext_code.size(address(_8400))
                                                    staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9855 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9855] == mem[_9855]
                                                    if mem[_9855] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_9855] - 1
                                                else:
                                                    if mem[_8193 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                        mem[mem[64] + 68] = _8300
                                                        require ext_code.size(address(_8400))
                                                        staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9897 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9897] == mem[_9897]
                                                        if mem[_9897] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9897] - 1
                                                    else:
                                                        if mem[_8193 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                            mem[mem[64] + 68] = _8300
                                                            require ext_code.size(address(_8400))
                                                            staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9929 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_9929] == mem[_9929]
                                                            if mem[_9929] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9929] - 1
                                                        else:
                                                            if mem[_8193 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                if mem[_9095] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4097]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_9095] - 1
                                                            else:
                                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                                mem[mem[64] + 68] = _8300
                                                                require ext_code.size(address(_8400))
                                                                staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                        gas gas_remaining wei
                                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _9951 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_9951] == mem[_9951]
                                                                if mem[_9951] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4097]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_9951] - 1
                                        else:
                                            mem[mem[64] + 4] = uint256(stor[_8365])
                                            mem[mem[64] + 36] = uint256(stor[_8367])
                                            mem[mem[64] + 68] = _8300
                                            require ext_code.size(address(_8400))
                                            staticcall address(_8400).get_dy_underlying(uint256 arg1, uint256 arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args uint256(stor[_8365]), uint256(stor[_8367]), _8300
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9058 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9058] == mem[_9058]
                                            if mem[_9058] and 9996 > -1 / mem[_9058]:
                                                revert with 'NH{q', 17
                                            if mem[_8193 + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                                if mem[_8193 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                    mem[mem[64] + 68] = _8300
                                                    require ext_code.size(address(_8400))
                                                    staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10396 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_10396] == mem[_10396]
                                                    if mem[_10396] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_10396] - 1
                                                else:
                                                    if mem[_8193 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                        mem[mem[64] + 68] = _8300
                                                        require ext_code.size(address(_8400))
                                                        staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10464 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_10464] == mem[_10464]
                                                        if mem[_10464] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_10464] - 1
                                                    else:
                                                        if mem[_8193 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                            mem[mem[64] + 68] = _8300
                                                            require ext_code.size(address(_8400))
                                                            staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _10524 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_10524] == mem[_10524]
                                                            if mem[_10524] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_10524] - 1
                                                        else:
                                                            if mem[_8193 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                if 9996 * mem[_9058] / 10000 < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4097]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4097 + 32] = (9996 * mem[_9058] / 10000) - 1
                                                            else:
                                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                                mem[mem[64] + 68] = _8300
                                                                require ext_code.size(address(_8400))
                                                                staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                        gas gas_remaining wei
                                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _10569 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_10569] == mem[_10569]
                                                                if mem[_10569] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4097]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_10569] - 1
                                            else:
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                mem[mem[64] + 68] = _8300
                                                require ext_code.size(address(_8400))
                                                staticcall address(_8400).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10252 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_10252] == mem[_10252]
                                                if mem[_8193 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                    mem[mem[64] + 68] = _8300
                                                    require ext_code.size(address(_8400))
                                                    staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _11793 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_11793] == mem[_11793]
                                                    if mem[_11793] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_11793] - 1
                                                else:
                                                    if mem[_8193 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                        mem[mem[64] + 68] = _8300
                                                        require ext_code.size(address(_8400))
                                                        staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _11815 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_11815] == mem[_11815]
                                                        if mem[_11815] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_11815] - 1
                                                    else:
                                                        if mem[_8193 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                            mem[mem[64] + 68] = _8300
                                                            require ext_code.size(address(_8400))
                                                            staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _11853 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_11853] == mem[_11853]
                                                            if mem[_11853] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_11853] - 1
                                                        else:
                                                            if mem[_8193 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                if mem[_10252] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4097]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_10252] - 1
                                                            else:
                                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8365'))))
                                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8367'))))
                                                                mem[mem[64] + 68] = _8300
                                                                require ext_code.size(address(_8400))
                                                                staticcall address(_8400).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                        gas gas_remaining wei
                                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8365')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8367')))), _8300
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _11891 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_11891] == mem[_11891]
                                                                if mem[_11891] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4097]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_11891] - 1
            if idx == -1:
                revert with 'NH{q', 17
            _8188 = mem[96]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _8204 = mem[_4097]
        mem[mem[64] + 32] = mem[_4097]
        mem[mem[64] + 64 len 32 * _8204] = mem[_4097 + 32 len 32 * _8204]
        return 32, mem[mem[64] + 32 len (32 * _8204) + 32]
    mem[_4097 + 32 len 32 * _4095 + 1] = call.data[calldata.size len 32 * _4095 + 1]
    if 0 >= mem[_4097]:
        revert with 'NH{q', 50
    mem[_4097 + 32] = cd[4]
    _8189 = mem[96]
    idx = 0
    while idx < _8189:
        if idx >= mem[96]:
            revert with 'NH{q', 50
        _8196 = mem[(32 * idx) + 128]
        if mem[mem[(32 * idx) + 128] + 160] == 1:
            _8202 = mem[mem[(32 * idx) + 128]]
            _8203 = mem[mem[(32 * idx) + 128] + 32]
            if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                _8208 = mem[mem[(32 * idx) + 128] + 64]
                _8220 = mem[64]
                _8221 = mem[64]
                mem[mem[64]] = 4
                mem[64] = mem[64] + 36
                mem[_8221 + 32] = mem[_8221 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                _8252 = mem[_8221]
                s = 0
                while s < _8252:
                    mem[_8220 + s + 36] = mem[_8221 + s + 32]
                    _8189 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_8252) <= _8252:
                    staticcall address(_8208).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8220 + _8252 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8202):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        _12322 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12322] = return_data.size
                        mem[_12322 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8202):
                            if mem[_12322 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12322 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12322 + 64]:
                                    if False and mem[_12322 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12322 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12322 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12322 + 32] and 10000 > -1 / mem[_12322 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12322 + 32] / 10000 != mem[_12322 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12322 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12322 + 32] < 10000 * mem[_12322 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12322 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12322 + 32]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12322 + 64]:
                                    if mem[_12322 + 32] and 10000 > -1 / mem[_12322 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12322 + 32] / 10000 != mem[_12322 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12322 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12322 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12322 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12322 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12322 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12322 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12322 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 64]) / mem[_12322 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12322 + 32] and 10000 > -1 / mem[_12322 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12322 + 32] / 10000 != mem[_12322 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12322 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12322 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12322 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12322 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 64]) / (10000 * mem[_12322 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[_12322 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12322 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12322 + 32]:
                                    if False and mem[_12322 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12322 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12322 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12322 + 64] and 10000 > -1 / mem[_12322 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12322 + 64] / 10000 != mem[_12322 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12322 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12322 + 64] < 10000 * mem[_12322 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12322 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12322 + 64]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12322 + 32]:
                                    if mem[_12322 + 64] and 10000 > -1 / mem[_12322 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12322 + 64] / 10000 != mem[_12322 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12322 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12322 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12322 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12322 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12322 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12322 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12322 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 32]) / mem[_12322 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12322 + 64] and 10000 > -1 / mem[_12322 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12322 + 64] / 10000 != mem[_12322 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12322 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12322 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12322 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12322 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12322 + 32]) / (10000 * mem[_12322 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                else:
                    mem[_8220 + _8252 + 36] = 0
                    staticcall address(_8208).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8220 + _8252 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8202):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        _12369 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12369] = return_data.size
                        mem[_12369 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8202):
                            if mem[_12369 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12369 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12369 + 64]:
                                    if False and mem[_12369 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12369 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12369 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12369 + 32] and 10000 > -1 / mem[_12369 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12369 + 32] / 10000 != mem[_12369 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12369 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12369 + 32] < 10000 * mem[_12369 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12369 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12369 + 32]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12369 + 64]:
                                    if mem[_12369 + 32] and 10000 > -1 / mem[_12369 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12369 + 32] / 10000 != mem[_12369 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12369 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12369 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12369 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12369 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12369 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12369 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12369 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 64]) / mem[_12369 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12369 + 32] and 10000 > -1 / mem[_12369 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12369 + 32] / 10000 != mem[_12369 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12369 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12369 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12369 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12369 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 64]) / (10000 * mem[_12369 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[_12369 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12369 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12369 + 32]:
                                    if False and mem[_12369 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12369 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12369 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12369 + 64] and 10000 > -1 / mem[_12369 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12369 + 64] / 10000 != mem[_12369 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12369 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12369 + 64] < 10000 * mem[_12369 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12369 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12369 + 64]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12369 + 32]:
                                    if mem[_12369 + 64] and 10000 > -1 / mem[_12369 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12369 + 64] / 10000 != mem[_12369 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12369 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12369 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12369 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12369 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12369 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12369 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12369 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 32]) / mem[_12369 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12369 + 64] and 10000 > -1 / mem[_12369 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12369 + 64] / 10000 != mem[_12369 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12369 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12369 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12369 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12369 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12369 + 32]) / (10000 * mem[_12369 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
            else:
                _8209 = mem[mem[(32 * idx) + 128] + 64]
                _8224 = mem[64]
                _8225 = mem[64]
                mem[mem[64]] = 4
                mem[64] = mem[64] + 36
                mem[_8225 + 32] = mem[_8225 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                _8253 = mem[_8225]
                s = 0
                while s < _8253:
                    mem[_8224 + s + 36] = mem[_8225 + s + 32]
                    _8189 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_8253) <= _8253:
                    staticcall address(_8209).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8224 + _8253 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8203):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        _12324 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12324] = return_data.size
                        mem[_12324 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8203):
                            if mem[_12324 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12324 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12324 + 64]:
                                    if False and mem[_12324 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12324 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12324 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12324 + 32] and 10000 > -1 / mem[_12324 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12324 + 32] / 10000 != mem[_12324 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12324 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12324 + 32] < 10000 * mem[_12324 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12324 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12324 + 32]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12324 + 64]:
                                    if mem[_12324 + 32] and 10000 > -1 / mem[_12324 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12324 + 32] / 10000 != mem[_12324 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12324 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12324 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12324 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12324 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12324 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12324 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12324 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 64]) / mem[_12324 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12324 + 32] and 10000 > -1 / mem[_12324 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12324 + 32] / 10000 != mem[_12324 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12324 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12324 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12324 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12324 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 64]) / (10000 * mem[_12324 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[_12324 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12324 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12324 + 32]:
                                    if False and mem[_12324 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12324 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12324 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12324 + 64] and 10000 > -1 / mem[_12324 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12324 + 64] / 10000 != mem[_12324 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12324 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12324 + 64] < 10000 * mem[_12324 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12324 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12324 + 64]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12324 + 32]:
                                    if mem[_12324 + 64] and 10000 > -1 / mem[_12324 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12324 + 64] / 10000 != mem[_12324 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12324 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12324 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12324 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12324 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12324 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12324 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12324 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 32]) / mem[_12324 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12324 + 64] and 10000 > -1 / mem[_12324 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12324 + 64] / 10000 != mem[_12324 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12324 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12324 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12324 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12324 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12324 + 32]) / (10000 * mem[_12324 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                else:
                    mem[_8224 + _8253 + 36] = 0
                    staticcall address(_8209).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8224 + _8253 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8203):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        _12374 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12374] = return_data.size
                        mem[_12374 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4097 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8196 + 12 len 20] == address(_8203):
                            if mem[_12374 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12374 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12374 + 64]:
                                    if False and mem[_12374 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12374 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12374 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12374 + 32] and 10000 > -1 / mem[_12374 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12374 + 32] / 10000 != mem[_12374 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12374 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12374 + 32] < 10000 * mem[_12374 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12374 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12374 + 32]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12374 + 64]:
                                    if mem[_12374 + 32] and 10000 > -1 / mem[_12374 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12374 + 32] / 10000 != mem[_12374 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12374 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12374 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12374 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12374 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12374 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12374 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12374 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 64]) / mem[_12374 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12374 + 32] and 10000 > -1 / mem[_12374 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12374 + 32] / 10000 != mem[_12374 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12374 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12374 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12374 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12374 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 64]) / (10000 * mem[_12374 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            if mem[_12374 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12374 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8196 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8196 + 128] + 10000:
                                if mem[_12374 + 32]:
                                    if False and mem[_12374 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12374 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12374 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12374 + 64] and 10000 > -1 / mem[_12374 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12374 + 64] / 10000 != mem[_12374 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12374 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12374 + 64] < 10000 * mem[_12374 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12374 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12374 + 64]
                            else:
                                if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12374 + 32]:
                                    if mem[_12374 + 64] and 10000 > -1 / mem[_12374 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12374 + 64] / 10000 != mem[_12374 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12374 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12374 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12374 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12374 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12374 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12374 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12374 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 32]) / mem[_12374 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12374 + 64] and 10000 > -1 / mem[_12374 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12374 + 64] / 10000 != mem[_12374 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12374 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12374 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12374 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12374 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12374 + 32]) / (10000 * mem[_12374 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
        else:
            if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xd8aa70f7990dab4a383a0d8a57df7a372916575d:
                _8228 = mem[mem[(32 * idx) + 128]]
                _8229 = mem[mem[(32 * idx) + 128] + 32]
                if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                    _8266 = mem[mem[(32 * idx) + 128] + 64]
                    _8288 = mem[64]
                    _8289 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8289 + 32] = mem[_8289 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8380 = mem[_8289]
                    s = 0
                    while s < _8380:
                        mem[_8288 + s + 36] = mem[_8289 + s + 32]
                        _8189 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8380) <= _8380:
                        staticcall address(_8266).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8288 + _8380 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8228):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12330 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12330] = return_data.size
                            mem[_12330 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8228):
                                if mem[_12330 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12330 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12330 + 64]:
                                        if False and mem[_12330 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12330 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12330 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12330 + 32] and 10000 > -1 / mem[_12330 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12330 + 32] / 10000 != mem[_12330 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12330 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12330 + 32] < 10000 * mem[_12330 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12330 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12330 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12330 + 64]:
                                        if mem[_12330 + 32] and 10000 > -1 / mem[_12330 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12330 + 32] / 10000 != mem[_12330 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12330 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12330 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12330 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12330 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12330 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12330 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12330 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 64]) / mem[_12330 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12330 + 32] and 10000 > -1 / mem[_12330 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12330 + 32] / 10000 != mem[_12330 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12330 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12330 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12330 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12330 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 64]) / (10000 * mem[_12330 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12330 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12330 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12330 + 32]:
                                        if False and mem[_12330 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12330 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12330 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12330 + 64] and 10000 > -1 / mem[_12330 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12330 + 64] / 10000 != mem[_12330 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12330 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12330 + 64] < 10000 * mem[_12330 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12330 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12330 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12330 + 32]:
                                        if mem[_12330 + 64] and 10000 > -1 / mem[_12330 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12330 + 64] / 10000 != mem[_12330 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12330 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12330 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12330 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12330 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12330 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12330 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12330 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 32]) / mem[_12330 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12330 + 64] and 10000 > -1 / mem[_12330 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12330 + 64] / 10000 != mem[_12330 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12330 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12330 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12330 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12330 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12330 + 32]) / (10000 * mem[_12330 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        mem[_8288 + _8380 + 36] = 0
                        staticcall address(_8266).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8288 + _8380 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8228):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12390 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12390] = return_data.size
                            mem[_12390 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8228):
                                if mem[_12390 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12390 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12390 + 64]:
                                        if False and mem[_12390 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12390 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12390 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12390 + 32] and 10000 > -1 / mem[_12390 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12390 + 32] / 10000 != mem[_12390 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12390 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12390 + 32] < 10000 * mem[_12390 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12390 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12390 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12390 + 64]:
                                        if mem[_12390 + 32] and 10000 > -1 / mem[_12390 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12390 + 32] / 10000 != mem[_12390 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12390 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12390 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12390 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12390 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12390 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12390 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12390 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 64]) / mem[_12390 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12390 + 32] and 10000 > -1 / mem[_12390 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12390 + 32] / 10000 != mem[_12390 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12390 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12390 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12390 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12390 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 64]) / (10000 * mem[_12390 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12390 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12390 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12390 + 32]:
                                        if False and mem[_12390 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12390 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12390 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12390 + 64] and 10000 > -1 / mem[_12390 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12390 + 64] / 10000 != mem[_12390 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12390 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12390 + 64] < 10000 * mem[_12390 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12390 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12390 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12390 + 32]:
                                        if mem[_12390 + 64] and 10000 > -1 / mem[_12390 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12390 + 64] / 10000 != mem[_12390 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12390 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12390 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12390 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12390 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12390 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12390 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12390 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 32]) / mem[_12390 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12390 + 64] and 10000 > -1 / mem[_12390 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12390 + 64] / 10000 != mem[_12390 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12390 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12390 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12390 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12390 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12390 + 32]) / (10000 * mem[_12390 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                else:
                    _8267 = mem[mem[(32 * idx) + 128] + 64]
                    _8292 = mem[64]
                    _8293 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8293 + 32] = mem[_8293 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8381 = mem[_8293]
                    s = 0
                    while s < _8381:
                        mem[_8292 + s + 36] = mem[_8293 + s + 32]
                        _8189 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8381) <= _8381:
                        staticcall address(_8267).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8292 + _8381 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8229):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12332 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12332] = return_data.size
                            mem[_12332 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8229):
                                if mem[_12332 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12332 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12332 + 64]:
                                        if False and mem[_12332 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12332 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12332 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12332 + 32] and 10000 > -1 / mem[_12332 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12332 + 32] / 10000 != mem[_12332 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12332 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12332 + 32] < 10000 * mem[_12332 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12332 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12332 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12332 + 64]:
                                        if mem[_12332 + 32] and 10000 > -1 / mem[_12332 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12332 + 32] / 10000 != mem[_12332 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12332 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12332 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12332 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12332 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12332 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12332 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12332 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 64]) / mem[_12332 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12332 + 32] and 10000 > -1 / mem[_12332 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12332 + 32] / 10000 != mem[_12332 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12332 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12332 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12332 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12332 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 64]) / (10000 * mem[_12332 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12332 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12332 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12332 + 32]:
                                        if False and mem[_12332 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12332 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12332 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12332 + 64] and 10000 > -1 / mem[_12332 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12332 + 64] / 10000 != mem[_12332 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12332 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12332 + 64] < 10000 * mem[_12332 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12332 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12332 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12332 + 32]:
                                        if mem[_12332 + 64] and 10000 > -1 / mem[_12332 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12332 + 64] / 10000 != mem[_12332 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12332 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12332 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12332 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12332 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12332 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12332 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12332 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 32]) / mem[_12332 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12332 + 64] and 10000 > -1 / mem[_12332 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12332 + 64] / 10000 != mem[_12332 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12332 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12332 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12332 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12332 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12332 + 32]) / (10000 * mem[_12332 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        mem[_8292 + _8381 + 36] = 0
                        staticcall address(_8267).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8292 + _8381 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8229):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            _12395 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12395] = return_data.size
                            mem[_12395 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4097 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8196 + 12 len 20] == address(_8229):
                                if mem[_12395 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12395 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12395 + 64]:
                                        if False and mem[_12395 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12395 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12395 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12395 + 32] and 10000 > -1 / mem[_12395 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12395 + 32] / 10000 != mem[_12395 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12395 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12395 + 32] < 10000 * mem[_12395 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12395 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12395 + 32]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12395 + 64]:
                                        if mem[_12395 + 32] and 10000 > -1 / mem[_12395 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12395 + 32] / 10000 != mem[_12395 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12395 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12395 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12395 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12395 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12395 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12395 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12395 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 64]) / mem[_12395 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12395 + 32] and 10000 > -1 / mem[_12395 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12395 + 32] / 10000 != mem[_12395 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12395 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12395 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12395 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12395 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 64]) / (10000 * mem[_12395 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                if mem[_12395 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12395 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8196 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8196 + 128] + 10000:
                                    if mem[_12395 + 32]:
                                        if False and mem[_12395 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12395 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12395 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12395 + 64] and 10000 > -1 / mem[_12395 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12395 + 64] / 10000 != mem[_12395 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12395 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12395 + 64] < 10000 * mem[_12395 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12395 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12395 + 64]
                                else:
                                    if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12395 + 32]:
                                        if mem[_12395 + 64] and 10000 > -1 / mem[_12395 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12395 + 64] / 10000 != mem[_12395 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12395 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12395 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12395 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12395 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12395 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12395 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12395 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 32]) / mem[_12395 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12395 + 64] and 10000 > -1 / mem[_12395 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12395 + 64] / 10000 != mem[_12395 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12395 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12395 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12395 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12395 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12395 + 32]) / (10000 * mem[_12395 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
            else:
                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xb9a9bb6cc39387548baa7185fbff51d47eef8771:
                    _8234 = mem[mem[(32 * idx) + 128]]
                    _8235 = mem[mem[(32 * idx) + 128] + 32]
                    if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                        _8286 = mem[mem[(32 * idx) + 128] + 64]
                        _8324 = mem[64]
                        _8325 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8325 + 32] = mem[_8325 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8398 = mem[_8325]
                        s = 0
                        while s < _8398:
                            mem[_8324 + s + 36] = mem[_8325 + s + 32]
                            _8189 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8398) <= _8398:
                            staticcall address(_8286).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8324 + _8398 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8234):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12326 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12326] = return_data.size
                                mem[_12326 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8234):
                                    if mem[_12326 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12326 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12326 + 64]:
                                            if False and mem[_12326 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12326 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12326 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12326 + 32] and 10000 > -1 / mem[_12326 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12326 + 32] / 10000 != mem[_12326 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12326 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12326 + 32] < 10000 * mem[_12326 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12326 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12326 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12326 + 64]:
                                            if mem[_12326 + 32] and 10000 > -1 / mem[_12326 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12326 + 32] / 10000 != mem[_12326 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12326 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12326 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12326 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12326 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12326 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12326 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12326 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 64]) / mem[_12326 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12326 + 32] and 10000 > -1 / mem[_12326 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12326 + 32] / 10000 != mem[_12326 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12326 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12326 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12326 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12326 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 64]) / (10000 * mem[_12326 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12326 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12326 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12326 + 32]:
                                            if False and mem[_12326 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12326 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12326 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12326 + 64] and 10000 > -1 / mem[_12326 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12326 + 64] / 10000 != mem[_12326 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12326 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12326 + 64] < 10000 * mem[_12326 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12326 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12326 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12326 + 32]:
                                            if mem[_12326 + 64] and 10000 > -1 / mem[_12326 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12326 + 64] / 10000 != mem[_12326 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12326 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12326 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12326 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12326 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12326 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12326 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12326 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 32]) / mem[_12326 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12326 + 64] and 10000 > -1 / mem[_12326 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12326 + 64] / 10000 != mem[_12326 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12326 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12326 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12326 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12326 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12326 + 32]) / (10000 * mem[_12326 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            mem[_8324 + _8398 + 36] = 0
                            staticcall address(_8286).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8324 + _8398 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8234):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12380 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12380] = return_data.size
                                mem[_12380 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8234):
                                    if mem[_12380 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12380 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12380 + 64]:
                                            if False and mem[_12380 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12380 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12380 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12380 + 32] and 10000 > -1 / mem[_12380 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12380 + 32] / 10000 != mem[_12380 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12380 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12380 + 32] < 10000 * mem[_12380 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12380 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12380 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12380 + 64]:
                                            if mem[_12380 + 32] and 10000 > -1 / mem[_12380 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12380 + 32] / 10000 != mem[_12380 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12380 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12380 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12380 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12380 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12380 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12380 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12380 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 64]) / mem[_12380 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12380 + 32] and 10000 > -1 / mem[_12380 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12380 + 32] / 10000 != mem[_12380 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12380 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12380 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12380 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12380 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 64]) / (10000 * mem[_12380 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12380 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12380 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12380 + 32]:
                                            if False and mem[_12380 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12380 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12380 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12380 + 64] and 10000 > -1 / mem[_12380 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12380 + 64] / 10000 != mem[_12380 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12380 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12380 + 64] < 10000 * mem[_12380 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12380 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12380 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12380 + 32]:
                                            if mem[_12380 + 64] and 10000 > -1 / mem[_12380 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12380 + 64] / 10000 != mem[_12380 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12380 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12380 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12380 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12380 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12380 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12380 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12380 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 32]) / mem[_12380 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12380 + 64] and 10000 > -1 / mem[_12380 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12380 + 64] / 10000 != mem[_12380 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12380 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12380 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12380 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12380 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12380 + 32]) / (10000 * mem[_12380 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                    else:
                        _8287 = mem[mem[(32 * idx) + 128] + 64]
                        _8328 = mem[64]
                        _8329 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8329 + 32] = mem[_8329 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8399 = mem[_8329]
                        s = 0
                        while s < _8399:
                            mem[_8328 + s + 36] = mem[_8329 + s + 32]
                            _8189 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8399) <= _8399:
                            staticcall address(_8287).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8328 + _8399 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8235):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12328 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12328] = return_data.size
                                mem[_12328 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8235):
                                    if mem[_12328 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12328 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12328 + 64]:
                                            if False and mem[_12328 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12328 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12328 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12328 + 32] and 10000 > -1 / mem[_12328 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12328 + 32] / 10000 != mem[_12328 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12328 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12328 + 32] < 10000 * mem[_12328 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12328 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12328 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12328 + 64]:
                                            if mem[_12328 + 32] and 10000 > -1 / mem[_12328 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12328 + 32] / 10000 != mem[_12328 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12328 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12328 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12328 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12328 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12328 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12328 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12328 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 64]) / mem[_12328 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12328 + 32] and 10000 > -1 / mem[_12328 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12328 + 32] / 10000 != mem[_12328 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12328 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12328 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12328 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12328 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 64]) / (10000 * mem[_12328 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12328 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12328 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12328 + 32]:
                                            if False and mem[_12328 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12328 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12328 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12328 + 64] and 10000 > -1 / mem[_12328 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12328 + 64] / 10000 != mem[_12328 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12328 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12328 + 64] < 10000 * mem[_12328 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12328 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12328 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12328 + 32]:
                                            if mem[_12328 + 64] and 10000 > -1 / mem[_12328 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12328 + 64] / 10000 != mem[_12328 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12328 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12328 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12328 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12328 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12328 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12328 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12328 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 32]) / mem[_12328 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12328 + 64] and 10000 > -1 / mem[_12328 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12328 + 64] / 10000 != mem[_12328 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12328 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12328 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12328 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12328 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12328 + 32]) / (10000 * mem[_12328 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                        else:
                            mem[_8328 + _8399 + 36] = 0
                            staticcall address(_8287).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8328 + _8399 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8235):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[160]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[128]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                            else:
                                _12385 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12385] = return_data.size
                                mem[_12385 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4097 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8196 + 12 len 20] == address(_8235):
                                    if mem[_12385 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12385 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12385 + 64]:
                                            if False and mem[_12385 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12385 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12385 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12385 + 32] and 10000 > -1 / mem[_12385 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12385 + 32] / 10000 != mem[_12385 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12385 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12385 + 32] < 10000 * mem[_12385 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12385 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12385 + 32]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12385 + 64]:
                                            if mem[_12385 + 32] and 10000 > -1 / mem[_12385 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12385 + 32] / 10000 != mem[_12385 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12385 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12385 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12385 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12385 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12385 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12385 + 64] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12385 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 64]) / mem[_12385 + 64] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12385 + 32] and 10000 > -1 / mem[_12385 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12385 + 32] / 10000 != mem[_12385 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12385 + 32] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12385 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12385 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12385 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 64]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 64]) / (10000 * mem[_12385 + 32]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                else:
                                    if mem[_12385 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12385 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8196 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8196 + 128] + 10000:
                                        if mem[_12385 + 32]:
                                            if False and mem[_12385 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12385 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12385 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12385 + 64] and 10000 > -1 / mem[_12385 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12385 + 64] / 10000 != mem[_12385 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12385 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12385 + 64] < 10000 * mem[_12385 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12385 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = 0 / 10000 * mem[_12385 + 64]
                                    else:
                                        if mem[(32 * idx) + _4097 + 32] and -mem[_8196 + 128] + 10000 > -1 / mem[(32 * idx) + _4097 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8196 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) / -mem[_8196 + 128] + 10000 != mem[(32 * idx) + _4097 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12385 + 32]:
                                            if mem[_12385 + 64] and 10000 > -1 / mem[_12385 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12385 + 64] / 10000 != mem[_12385 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12385 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12385 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12385 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12385 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = 0 / (10000 * mem[_12385 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) and mem[_12385 + 32] > -1 / (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12385 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 32]) / mem[_12385 + 32] != (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12385 + 64] and 10000 > -1 / mem[_12385 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12385 + 64] / 10000 != mem[_12385 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12385 + 64] > (-10000 * mem[(32 * idx) + _4097 + 32]) + (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12385 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]) < 10000 * mem[_12385 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12385 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4097]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4097 + 32] = (10000 * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32] * mem[_12385 + 32]) / (10000 * mem[_12385 + 64]) + (10000 * mem[(32 * idx) + _4097 + 32]) - (mem[_8196 + 128] * mem[(32 * idx) + _4097 + 32])
                else:
                    if mem[mem[(32 * idx) + 128] + 160] == 3:
                        _8242 = mem[mem[(32 * idx) + 128] + 64]
                        _8243 = mem[mem[(32 * idx) + 128]]
                        require ext_code.size(mem[mem[(32 * idx) + 128] + 76 len 20])
                        staticcall mem[mem[(32 * idx) + 128] + 76 len 20]._BASE_TOKEN_() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8265 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8265] == mem[_8265 + 12 len 20]
                        if idx >= mem[_4097]:
                            revert with 'NH{q', 50
                        if mem[_8265 + 12 len 20] != address(_8243):
                            _8528 = mem[(32 * idx) + _4097 + 32]
                            mem[mem[64] + 36] = mem[(32 * idx) + _4097 + 32]
                            require ext_code.size(address(_8242))
                            staticcall address(_8242).querySellQuote(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(this.address), _8528
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9350 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_9350] == mem[_9350]
                            require mem[_9350 + 32] == mem[_9350 + 32]
                            if idx > -2:
                                revert with 'NH{q', 17
                            if idx + 1 >= mem[_4097]:
                                revert with 'NH{q', 50
                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9350]
                        else:
                            _8530 = mem[(32 * idx) + _4097 + 32]
                            mem[mem[64] + 36] = mem[(32 * idx) + _4097 + 32]
                            require ext_code.size(address(_8242))
                            staticcall address(_8242).querySellBase(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(this.address), _8530
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9351 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_9351] == mem[_9351]
                            require mem[_9351 + 32] == mem[_9351 + 32]
                            if idx > -2:
                                revert with 'NH{q', 17
                            if idx + 1 >= mem[_4097]:
                                revert with 'NH{q', 50
                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9351]
                    else:
                        if mem[mem[(32 * idx) + 128] + 160] == 5:
                            _8255 = mem[mem[(32 * idx) + 128] + 96]
                            _8264 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_8264 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_8264]:
                                revert with 'NH{q', 50
                            mem[_8264 + 32] = mem[_8196 + 12 len 20]
                            if 1 >= mem[_8264]:
                                revert with 'NH{q', 50
                            mem[_8264 + 64] = mem[_8196 + 44 len 20]
                            if idx >= mem[_4097]:
                                revert with 'NH{q', 50
                            _8396 = mem[(32 * idx) + _4097 + 32]
                            mem[_8264 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_8264 + 100] = _8396
                            mem[_8264 + 132] = 64
                            mem[_8264 + 164] = mem[_8264]
                            s = 0
                            t = _8264 + 32
                            u = _8264 + 196
                            while s < mem[_8264]:
                                mem[u] = mem[t + 12 len 20]
                                _8189 = mem[96]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            require ext_code.size(address(_8255))
                            staticcall address(_8255).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8264 + (32 * mem[_8264]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12305 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _12375 = mem[_12305]
                            require mem[_12305] <= test266151307()
                            require _12305 + mem[_12305] + 31 < _12305 + return_data.size
                            _12525 = mem[_12305 + mem[_12305]]
                            if mem[_12305 + mem[_12305]] > test266151307():
                                revert with 'NH{q', 65
                            if _12305 + ceil32(return_data.size) + floor32(mem[_12305 + mem[_12305]]) + 1 > test266151307() or floor32(mem[_12305 + mem[_12305]]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _12305 + ceil32(return_data.size) + floor32(mem[_12305 + mem[_12305]]) + 1
                            mem[_12305 + ceil32(return_data.size)] = _12525
                            require _12375 + (32 * _12525) + 32 <= return_data.size
                            s = 0
                            t = _12305 + _12375 + 32
                            u = _12305 + ceil32(return_data.size) + 32
                            while s < _12525:
                                require mem[t] == mem[t]
                                mem[u] = mem[t]
                                _8189 = mem[96]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            if _12525 < 1:
                                revert with 'NH{q', 17
                            if _12525 - 1 >= _12525:
                                revert with 'NH{q', 50
                            if idx > -2:
                                revert with 'NH{q', 17
                            if idx + 1 >= mem[_4097]:
                                revert with 'NH{q', 50
                            mem[(32 * idx + 1) + _4097 + 32] = mem[(32 * _12525 - 1) + _12305 + ceil32(return_data.size) + 32]
                        else:
                            if mem[mem[(32 * idx) + 128] + 160] == 7:
                                if idx >= mem[_4097]:
                                    revert with 'NH{q', 50
                                _8285 = mem[(32 * idx) + _4097 + 32]
                                _8321 = mem[mem[(32 * idx) + 128] + 32]
                                _8356 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                _8358 = sha3(address(_8321), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                if uint256(stor[_8356]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8321)]):
                                    revert with 0, 'BAD CURVE'
                                _8394 = mem[mem[(32 * idx) + 128] + 96]
                                mem[mem[64] + 4] = uint8(stor[_8356])
                                mem[mem[64] + 36] = uint8(stor[_8358])
                                mem[mem[64] + 68] = _8285
                                require ext_code.size(address(_8394))
                                staticcall address(_8394).calculateSwap(uint8 arg1, uint8 arg2, uint256 arg3) with:
                                        gas gas_remaining wei
                                       args uint8(stor[_8356]), uint8(stor[_8358]), _8285
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8964 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8964] == mem[_8964]
                                if mem[_8964] < 1:
                                    revert with 'NH{q', 17
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4097]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4097 + 32] = mem[_8964] - 1
                            else:
                                if mem[mem[(32 * idx) + 128] + 160] != 8:
                                    if mem[mem[(32 * idx) + 128] + 160] != 13:
                                        require mem[mem[(32 * idx) + 128] + 160] == 14
                                        _8348 = mem[mem[(32 * idx) + 128] + 32]
                                        if idx >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        _8372 = mem[(32 * idx) + _4097 + 32]
                                        mem[mem[64] + 4] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                        mem[mem[64] + 36] = address(_8348)
                                        mem[mem[64] + 68] = _8372
                                        require ext_code.size(0x66357dcace80431aee0a7507e2e361b7e2402370)
                                        staticcall 0x66357dcace80431aee0a7507e2e361b7e2402370.quotePotentialSwap(address arg1, address arg2, uint256 arg3) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_8348), _8372
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9113 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9113] == mem[_9113]
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9113]
                                    else:
                                        _8315 = mem[mem[(32 * idx) + 128]]
                                        _8316 = mem[mem[(32 * idx) + 128] + 32]
                                        if idx >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        _8350 = mem[(32 * idx) + _4097 + 32]
                                        mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                        mem[mem[64] + 68] = address(_8316)
                                        mem[mem[64] + 100] = _8350
                                        require ext_code.size(0x9e372b445723e71117b59393aaba05ad3b54ad3f)
                                        staticcall 0x9e372b445723e71117b59393aaba05ad3b54ad3f.0xd7176ca9 with:
                                                gas gas_remaining wei
                                               args 0x9ab2de34a33fb459b538c43f251eb825645e8595, address(_8315), address(_8316), _8350
                                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9371 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 64
                                        require mem[_9371] == mem[_9371]
                                        require mem[_9371 + 32] == mem[_9371 + 32]
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4097]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9371]
                                else:
                                    if idx >= mem[_4097]:
                                        revert with 'NH{q', 50
                                    _8318 = mem[(32 * idx) + _4097 + 32]
                                    _8354 = mem[mem[(32 * idx) + 128] + 32]
                                    _8375 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                    mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                    mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                    _8377 = sha3(address(_8354), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                    if uint256(stor[_8375]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8354)]):
                                        revert with 0, 'BAD CURVE'
                                    _8402 = mem[mem[(32 * idx) + 128] + 96]
                                    if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
                                        if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                            if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                mem[mem[64] + 68] = _8318
                                                require ext_code.size(address(_8402))
                                                staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9347 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9347] == mem[_9347]
                                                if mem[_9347] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_9347] - 1
                                            else:
                                                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                    mem[mem[64] + 68] = _8318
                                                    require ext_code.size(address(_8402))
                                                    staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9372 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9372] == mem[_9372]
                                                    if mem[_9372] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_9372] - 1
                                                else:
                                                    if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                        mem[mem[64] + 68] = _8318
                                                        require ext_code.size(address(_8402))
                                                        staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9383 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9383] == mem[_9383]
                                                        if mem[_9383] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9383] - 1
                                                    else:
                                                        if mem[mem[(32 * idx) + 128] + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            revert with 'NH{q', 17
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                        mem[mem[64] + 68] = _8318
                                                        require ext_code.size(address(_8402))
                                                        staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9413 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9413] == mem[_9413]
                                                        if mem[_9413] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9413] - 1
                                        else:
                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                            mem[mem[64] + 68] = _8318
                                            require ext_code.size(address(_8402))
                                            staticcall address(_8402).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9114 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9114] == mem[_9114]
                                            if mem[_8196 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                mem[mem[64] + 68] = _8318
                                                require ext_code.size(address(_8402))
                                                staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9876 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9876] == mem[_9876]
                                                if mem[_9876] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_9876] - 1
                                            else:
                                                if mem[_8196 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                    mem[mem[64] + 68] = _8318
                                                    require ext_code.size(address(_8402))
                                                    staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9909 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9909] == mem[_9909]
                                                    if mem[_9909] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_9909] - 1
                                                else:
                                                    if mem[_8196 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                        mem[mem[64] + 68] = _8318
                                                        require ext_code.size(address(_8402))
                                                        staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9940 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9940] == mem[_9940]
                                                        if mem[_9940] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_9940] - 1
                                                    else:
                                                        if mem[_8196 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            if mem[_9114] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9114] - 1
                                                        else:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                            mem[mem[64] + 68] = _8318
                                                            require ext_code.size(address(_8402))
                                                            staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9977 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_9977] == mem[_9977]
                                                            if mem[_9977] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_9977] - 1
                                    else:
                                        mem[mem[64] + 4] = uint256(stor[_8375])
                                        mem[mem[64] + 36] = uint256(stor[_8377])
                                        mem[mem[64] + 68] = _8318
                                        require ext_code.size(address(_8402))
                                        staticcall address(_8402).get_dy_underlying(uint256 arg1, uint256 arg2, uint256 arg3) with:
                                                gas gas_remaining wei
                                               args uint256(stor[_8375]), uint256(stor[_8377]), _8318
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9076 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9076] == mem[_9076]
                                        if mem[_9076] and 9996 > -1 / mem[_9076]:
                                            revert with 'NH{q', 17
                                        if mem[_8196 + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                            if mem[_8196 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                mem[mem[64] + 68] = _8318
                                                require ext_code.size(address(_8402))
                                                staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10438 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_10438] == mem[_10438]
                                                if mem[_10438] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_10438] - 1
                                            else:
                                                if mem[_8196 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                    mem[mem[64] + 68] = _8318
                                                    require ext_code.size(address(_8402))
                                                    staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10490 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_10490] == mem[_10490]
                                                    if mem[_10490] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_10490] - 1
                                                else:
                                                    if mem[_8196 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                        mem[mem[64] + 68] = _8318
                                                        require ext_code.size(address(_8402))
                                                        staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10542 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_10542] == mem[_10542]
                                                        if mem[_10542] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_10542] - 1
                                                    else:
                                                        if mem[_8196 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            if 9996 * mem[_9076] / 10000 < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = (9996 * mem[_9076] / 10000) - 1
                                                        else:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                            mem[mem[64] + 68] = _8318
                                                            require ext_code.size(address(_8402))
                                                            staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _10587 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_10587] == mem[_10587]
                                                            if mem[_10587] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_10587] - 1
                                        else:
                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                            mem[mem[64] + 68] = _8318
                                            require ext_code.size(address(_8402))
                                            staticcall address(_8402).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10261 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_10261] == mem[_10261]
                                            if mem[_8196 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                mem[mem[64] + 68] = _8318
                                                require ext_code.size(address(_8402))
                                                staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _11804 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_11804] == mem[_11804]
                                                if mem[_11804] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4097]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4097 + 32] = mem[_11804] - 1
                                            else:
                                                if mem[_8196 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                    mem[mem[64] + 68] = _8318
                                                    require ext_code.size(address(_8402))
                                                    staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _11834 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_11834] == mem[_11834]
                                                    if mem[_11834] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4097]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4097 + 32] = mem[_11834] - 1
                                                else:
                                                    if mem[_8196 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                        mem[mem[64] + 68] = _8318
                                                        require ext_code.size(address(_8402))
                                                        staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _11872 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_11872] == mem[_11872]
                                                        if mem[_11872] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4097]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4097 + 32] = mem[_11872] - 1
                                                    else:
                                                        if mem[_8196 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            if mem[_10261] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_10261] - 1
                                                        else:
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8375'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8377'))))
                                                            mem[mem[64] + 68] = _8318
                                                            require ext_code.size(address(_8402))
                                                            staticcall address(_8402).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8375')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8377')))), _8318
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _11925 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_11925] == mem[_11925]
                                                            if mem[_11925] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4097]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4097 + 32] = mem[_11925] - 1
        if idx == -1:
            revert with 'NH{q', 17
        _8189 = mem[96]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    _8205 = mem[_4097]
    mem[mem[64] + 32] = mem[_4097]
    mem[mem[64] + 64 len 32 * _8205] = mem[_4097 + 32 len 32 * _8205]
    return 32, mem[mem[64] + 32 len (32 * _8205) + 32]
}



}
